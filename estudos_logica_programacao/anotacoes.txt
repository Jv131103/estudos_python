- Um programa ou software, é o que podemos chamar de inteligência do computador

- O hardware é a máquina, a parte física

- Em computação, dados são a representação simbólica de um fato ou acontecimento.
Os fatos podem ser, nomes, datas, valores numéricos, imagens, etc. Ou seja,
qualquer coisa que possa ser medido, comparado ou representados no computador.

- Os símbolos mais comuns são as letras e os números. (As imagens e os sons são representados
no computador por uma sequencia de número).

- Uma informação é um dado, ou conjunto de dados, ou o o resultado da transformação de um
conjunto de dados que, dentro de determinado contexto, faça sentido para alguém. Poe exemplo,
uma ficha médica, ou um formulário de cadastro.

- Qualquer fato, pode ser representado simbolicamente? Não. Por que certos, fatos,
não podem ser representados como são na realidade, por conta de não poderem ser interpretados
lógico-matematicamente. Outros, por conta de não serem duais, assim não interpretados, como zeros
e uns. Emoções, sabores e sentimentos são exemplos de fatos que não podem ser representados,
por serem complexas e por terem reprodução além do lógico.

SOBRE SISTEMA BINÁRIO

- São representados por 0s e 1s, embora, haja outros sistemas, como ternários,
decimais, hexadecimais e octais.

- O computador atualmente, entende apenas 0s e 1s que representam ligado e desligado,
tal que seguem o princípio de ebtrada e saída de energia no hardware.

- Possui um sistema de numeração onde cada dígito, aqui chamado de bit, tem apenas dois valores
possíveis, ou seja, 0 e 1

- No sistema decimal, podemos representar até 10 elementos com um único dígito:

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9

- No sistema binário, podemos representar apenas 2 com um único bit.

    0, 1

- Para se poder rtepresentar mais elementos, é necessário acrescentar outros dígitos e bits.

- O 11° elemento no sistema decimal e'representado por 10.

    IMPORTANTE: Na computação, o valor 0 é super significativo quanto a identificar elementos

- No sistema binário, o 3° elemento, já que só podemos representar o 2 como um único bit, será
o 10.

- Tabela de 0, 20

    Decimal | Binário
    0       | 0
    1       | 1
    2       | 10
    3       | 11
    4       | 100
    5       | 101
    6       | 110
    7       | 111
    8       | 1000
    9       | 1001
    10      | 1010
    11      | 1011
    12      | 1100
    13      | 1101
    14      | 1110
    15      | 1111
    16      | 10000
    17      | 10001
    18      | 10010
    19      | 10011
    20      | 10100

- No sistema decimal, cada dígito adicional aumenta em 10 vezes a capacidade de contagem, ao passo
que no binário, cada bit adicional aumenta em 2 vezes.

- Qual a capacidade de contagem de um número com 3 dígitos?

    10**3 = 1000

    - Vai de 0 a 999

- Qual a capacidade de contagem de um número com 3 bits?

    2**3 = 8

    - Vai de 0 a 7

- Como saber quanto um binário vale em decimal?

    EX:

        1       0       0       1       1       0       1       0       1       0       1       1       1       0
        2**13   2**12   2**11   2**10   2**9    2**8    2**7    2**6    2**5    2**4    2**3    2**2    2**1    2**0
        8192    4096    2048    1024    512     256     128     64      32      16      8       4       2       1
        8192    0       0       1024    512     0       128     0       32      0       8       4       2       0

        8192 + 0 + 0 + 1024 + 512 + 0 + 128 + 0 + 32 + 0 + 8 + 4 + 2 + 0 =  9902


        1° linha: Símbolo binário
        2° linha: Resutado do valor 2**n
        3° linha: Resultado do valor de 2**n * símbolo binário

        10011011

        2**7 = 128 * 1 = 128
        2**6 = 64 * 0 = 0
        2**5 = 32 * 0 = 0
        2**4 = 16 * 1 = 16
        2**3 = 8 * 1 = 8
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 1 = 1

        128 + 16 + 8 + 2 + 1 = 155

- Como saber quanto um decimal vale em binário?

    EX: 100

    100 / 2 = 50, resto 0
    50 / 2 = 25, resto 0
    25 / 2 = 12, resto 1
    12 / 2 = 6, resto 0,
    6 / 2 = 3, resto 0
    3 / 2 = 1, resto 1,
    1 / 2 = resto 1, pois 1 não divide 2

    resultado dos restos: 0010011

    inverte ficará: 1100100

- Prático:

    Exercício 1 - Foi vista na videoaula a conversão do número
    binário 10011010111001 para o seu equivalente decimal que
    resultou em 9913.

    Acrescente um bit 0 à direita (o menos significativo) deste
    número binário e veja que número decimal obterá.
    
    Divida este novo número decimal obtido pelo decimal anterior e
    analise o resultado.

        100110101110010

        2**14 = 16384 * 1 = 16384
        2**13 = 8192 * 0 = 0
        2**12 = 4096 * 0 = 0
        2**11 = 2048 * 1 = 2048
        2**10 = 1024 * 1 = 1024
        2**9 = 512 * 0 = 0
        2**8 = 256 * 1 = 256
        2**7 = 128 * 0 = 0
        2**6 = 64 * 1 = 64
        2**5 = 32 * 1 = 32
        2**4 = 16 * 1 = 16
        2**3 = 8 * 0 = 0
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 0 = 0

        16384 + 2048 + 1024 + 256 + 64 + 32 + 16 + 2 = 19826

        Divisão: 19826 // 9913 = 2


    Exercício 2 - Com o resultado decimal obtido no exercício 1, aplique a técnica da divisão 
    sucessiva por 2 para obter seu equivalente binário. O resultado deverá ser o número original

        19826

        19826 // 2 = 9913, resto 0
        9913 // 2 = 4956, resto 1
        4956 // 2 = 2478, resto 0
        2478 // 2 = 1239, resto 0
        1239 // 2 = 619, resto 1
        619 // 2 = 309, resto 1
        309 // 2 = 154, resto 1
        154 // 2 = 77, resto 0
        77 // 2 = 38, resto 1
        38 // 2 = 19, resto 0
        19 // 2 = 9, resto 1
        9 // 2 = 4, resto 1
        4 // 2 = 2, resto 0
        2 // 2 = 1, resto 0
        1 // 2 = 1

        Resultado dos restos: 010011101011001

        Resultado final, invertido: 100110101110010

SOBRE O COMPUTADOR:

- A Memória, é onde se armazena e endereça informações e dados. É nela onde se permite
guardar informações e registrá-las e mantê-las enquanto o programa ou a máquina estiver ligada.
É nela onde o processador se comunica retornando informações. Ela se divide em dois pontos:

    . Endereço fixo: O local referente onde os dados estão armazenados

    . Conteúdo vartiável: O conteúdo que está armazenado no endereço e pode ser mutável

- 1 byte contém 8 bits

- Os computadores tradicionais se compõem de uma grande sequencia de bytes de 8 bits

- A ideia original de que o byte deva ter 8 bits surgiu da necessidade de se ter um código
para representar cada um dos caracteres visíveis (letras, números, sinais de pontuação e
alguns símbolos mais utilizados como o $, %, @ e outros), além de caracteres de controle
(invisíveis) tais como o comando de saltar linha na tela ou soar o beep do PC. Chegou na
conclusão que 8 bits era mais que o suficiente

- A tabela ASCII, é um formato interpretador que serve de base para interpretação unicode
dos dados. Ela possui seus caracteres em 8 bits e foi uma das bases mais usadas e até hoje
é bastante utilizada. Nela, a letra 'a' têm o valor de 01100001 (97 em decimal) e o caracter
numérico '1' tem o valor de 00110001 (49 em decimal).

- No caso dos números, este valor é meramente um identificador do símbolo do número, porque
o seu valor matemático está nos bits conforme vimos anteriormente. E como disse acima,
49 não representa o valor matemático 1 e sim representa o tipo de texto 1, ou seja,
o valor simbólico, não literal.

- O byte é um agrupamento voltado aos conteúdos da memória, sendo que a quantidade de bits
para fazer o endereçamento da memória segue outra contagem. Os primiros Pcs pessoais tinham memória
com endereçamento de 8 bits, o que permitia apenas 256 endereços.

- A CPU (Central Processing Unit), é o mecanismo principal do computador. É nele onde as instruções
são processadas e ela é responsável por trabalhar com o conteúdo das memória, recebendo dados
e retornando-as / escrevendo para tal. Ela realiza um procedimento de coleta de cada item
endereçado na memória, e faz um trabalho X nela dependendo do dado, procedimento pedido e 
comportamento do sistema com o hardware.

- Os conteúdos da CPU são:

    . Instruções:

        - Dizem a CPU o que fazer

        - Cada instrução, possui um SET, que é responsável por dizer a CPU que coisas devem acontecer

            EX de um computador elementar de 4 bits a nível binário:

                x----------x--------------------------------------------------------------------x
                | Conteúdo |                            Ação                                    |
                x----------x--------------------------------------------------------------------x
                |   0000   | Interrompe a execução do programa                                  |
                x----------x--------------------------------------------------------------------x
                |   0100   | Lê o conteúdo da memória que está no endereço logo a seguir a esta |
                |          | instrução e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |   0110   | Lê o conteúdo da memória que está no endereço logo a seguir a esta |
                |          | instrução e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |          | Soma o conteúdo do registrador 1 com o conteúdo do registrador 2   |
                |   0111   | e armazena o resultado no endereço de memória cujo número equivale |
                |          | ao conteúdo do endereço a seguir a esta instrução                  |
                x----------x--------------------------------------------------------------------x

            PS: Cada código binário representa uma ação específica, previamente definida pela 
            arquitetura da CPU.

    . Dados:

        - Manipulados pelas instruções para que determinado pedido ou resultado seja obtido


- Linguagem binária ou de máquina: É a linguagem do computador, responsável por seguir
sequencias complexas de instruções, tudo isso seguindo no princípio binário.

- Linguagem Assembly: relação direta entre as instruções em linguagem binária e expressões
mnemônicas.

    Instrução Binária       Correspondente eletrônico
          0000                         stop
          0100                         read 1
          0110                         read 2
          0111                         add 1 2

- Esta "altitude" do nível de uma linguagem diz respeito, em linhas gerais, a facilidade e rapidez
com que se produz um programa. Ou seja, são necessárias menos instruções escritas pelo programador
para se obter um mesmo resultado. Em outras palavras uma instrução escrita produz mais instruções
binárias. Porém, linguagens de alto nível, costumam produzir programas de desempenho inferior

- Os compiladores leem o programa fonte e produzem um programa executável independente de qualquer
outro software que não seja o sistema operacional do computador.

            PROGRAMA -> COMPILADOR -> PROGRAMA.exe 
            
        ps: Em sistemas UNIX PROGRAMA.exe, retorna apenas PROGRAMA, mas no fundo é um executável 
        também

- Os interpretadores leem o programa fonte, criam este programa na memória (binário) e o executam.
Não existe programa executavel gerado.Tudo é realizado pelo interpretador.

    . Os interpretadores facilitam o trabalho de manutenção principalmente em grandes sistemas
    compostos de muitos programas

    . Em ambientes de muitos programas rodando simultaneamente, os interpretadores consomem menos
    memória

    . Considerando uma mesma linguagem, o seu computador produz programas mais rápidos do que
    o seu interpretador.

SOBRE PROGRAMAS

- Um programa é um conjunto de passos e instruções, organizadas de maneira lógica, que realiza um ou mais serviços
de processamento de dados.

- Processamento de dados é o ato de tratar dados brutos e obter dados tranformados, seguindo especificações previamente
estabelecidas, ou obter infortmações com esses dados contextualizados.


                    DADOS BRUTOS -> PROGRAMA -> DADOS TRABALHADOS

- Um programa pode ser simples ou composto por diversos outros programas

- Um algoritmo é uma sequencia finita de passos, etapas ou instruções que resolvem determinados
problemas. Um algoritmo é dito determinístico quando se obtém sempre o mesmo resultado a partir dos
mesmos dados. Um programa pode ter 1 ou N algorítmos.

- Um exemplo de um algoritmo funcional:

    . Cada linguagem têm uma estrutura ou sintaxe

    . Cada programa possui uma linha de execução. Dependendo da linguagem, ela precisa ser fechada
    ou concluída, para referenciar outra linha ou se fecha automaticamente.

    . variáveis são definições e referencias a objetos ou valores no programa. Eles são escopos
    de memória onde se realizará procedimentos e armazenazem tempórária de dados e informações.
    Elas não podem começar com números e símbolos que não sejam _ e também com espaços.

    EX: ISSO FOI CRIADO POR MIM, UMA FORMA INTERPRETATIVA MINHA DE MOLDAR ALGORITMO FORA DA MÁQUINA
    É MERA INTERPRETAÇÃO, PODEMOS USAR FERRAMENTAS JÁ PRONTAS QUE LEIAM EM PORTUGUÊS OU PODE MONTAR DO
    SEU JEITO, CONTANTO, QUE SIGA NORMAS E PADRÕES DA COMPUTAÇÃO E QUE FIQUE FÁCIL DE VOCÊ APLICAR,
    LER E IMPLEMENTAR EM OUTRAS LINGUAGENS.

        TÍTULO: "Soma"
        OBSERVACAO: "Vai realizar a soma de dois número"

        INICIO

        num1: int = int(ler("N1: "))
        num2: int = int(ler("N2: "))

        soma: int = num1 + num2   # Realiza a soma

        exibir f"Resultado = {soma}"

        FIM

- Um outro exemplo no qual usamos funções. Fuções são blocos de códigos, especializados
para executar funções específicas de código, ou seja, realizam procedimentos dentro de um escopo,
para que seja implementado no escopo principal. Ela facilita a leitura e entendimento do código e 
traz mais eficiência, legibilidade e pode ser usada e reaproveitada em outros programas.

    TÍTULO: "Função"
    OBSERVACAO: "Vai realizar uma demonstração do que é uma função"

    INICIO

    REALIZAR MÉDIA DE DOIS NÚMEROS
    [funçao] media
        params:
            n1: int
            n2: int
        ações:
            retornar (n1 + n2) / 2
    [fimfuncao]


    num1: float = float(ler("N1: "))
    num2: float = float(ler("N2: "))

    media: float = media(num1, num2)

    exibir f"A média é {media:.2f}"

    FIM

- Ide vs Editor de código fonte:

    . Ide (Integrated Development Environment): Uma IDE é um ambiente completo 
    de desenvolvimento. Ela integra várias ferramentas em um só lugar.

        O que uma IDE já traz integrada:

            + Editor de código

            + Compilador / interpretador

            + Debugger (passo a passo)

            + Gerenciador de projetos

            + Gerenciador de dependências
            
            + Build / Run com um clique
            
            + Testes integrados

        A IDE entende:

            o projeto

            a linguagem

            a estrutura

            as dependências

        Exemplos típicos

            . PyCharm

            . IntelliJ IDEA

            . Eclipse

            . Visual Studio

            . NetBeans

        → “Eu desenvolvo software aqui”

    . Editor de código fonte: Um editor de código é uma ferramenta focada em 
    escrever e editar texto/código. Ele não se preocupa com o projeto inteiro,
    só com o arquivo que você está editando. 
    
        Um editor oferece:

            + Destaque de sintaxe (cores)

            + Numeração de linhas

            + Busca e substituição

            + Autocompletar básico

            + Leve e rápido
        
        Exemplos típicos

            . VS Code (editor avançado)

            . Sublime Text

            . Notepad++

            . Vim / Nano

        → “Eu escrevo código aqui”


UM POUCO SOBRE LÓGICA DE PROGRAMAÇÃO:


    Variáveis:

        - Variável é um nome que guarda um valor na memória para ser usado depois.

        . Variável = caixa com nome

        . Valor = conteúdo da caixa

        . O valor pode mudar ao longo do programa

        . Serve para guardar dados temporários

        Por que variáveis existem?

            . Evitam repetir valores

            . Facilitam cálculos

            . Permitem decisões (if)

            . Permitem repetições (while, for)

        Antes de criar qualquer variável, pergunte:

            1. Que informação eu preciso guardar?

            2. Essa informação muda ou é fixa?

            3. Vou usar esse valor depois?

            4. Esse nome está claro para um humano?

        - Nome bom de variável explica o que ela guarda.

        TIPOS MAIS COMUNS DE VARIÁVEIS (conceito):

            | Tipo    | Guarda o quê?       | Exemplo         |
            | ------- | ------------------- | --------------- |
            | inteiro | números sem vírgula | idade = 20      |
            | real    | números com vírgula | altura = 1.75   |
            | texto   | palavras/frases     | nome = "Renato" |
            | lógico  | verdadeiro ou falso | aprovado = True |

        EXEMPLOS SIMPLES:

            Exemplo 1 — Guardar valor

                idade = 20

            Mental: “Criei uma caixa chamada idade e coloquei o valor 20 dentro.”

            Exemplo 2 — Usar variável

                preco = 10
                total = preco + 5
            
            Mental: “Usei o valor guardado para calcular outro.”

            Exemplo 3 — Valor muda

                contador = 0
                contador = contador + 1

            Mental: “A variável continua existindo, mas o valor mudou.”
        
        ERROS COMUNS:

            Usar nomes confusos:

                x = 10   # ruim

            Melhor:

                quantidade = 10

            Usar variável sem valor:

                print(total)  # erro se total não existir

            Pensar que variável é o valor:

                - Não é

                Variável é o nome, não o conteúdo.

        FRASE-CHAVE (decora essa)

            . Variável não é número, nem texto.

            . Variável é um nome que aponta para um valor.

        DICAS:

            . Pense no nome antes do valor
            . Variável deve ter sentido humano
            . Uma variável = uma informação
            . Se travar, pergunte: “O que eu preciso guardar?”
    
    =====================================================================

    Constantes:

        - Constante é um valor que NÃO deve mudar durante o programa.

        . Constante = valor fixo

        . Serve para representar regras, limites ou padrões

        . Evita “números mágicos” espalhados no código

        . Deixa o programa mais claro e seguro

        Ideia-chave:

            - Se não pode mudar, não deve ser variável.

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO):

            Perguntas obrigatórias antes de decidir:

                1. Esse valor pode mudar durante a execução?

                2. Ele representa uma regra do problema?

                3. Se mudar no futuro, deveria mudar em um só lugar?

                4. Esse valor tem significado fixo no mundo real?

            Se a resposta for “não muda” → constante

        DIFERENÇA CLARA: VARIÁVEL × CONSTANTE:

            | Conceito  | Pode mudar?  | Exemplo        |
            | --------- | ------------ | -------------- |
            | Variável  | ✅ Sim       | idade, saldo   |
            | Constante | ❌ Não       | PI, taxa fixa  |

        - Constante não depende do usuário, nem do tempo.

        COMO REPRESENTAR CONSTANTES (boa prática):

            Em Python, usa-se:

                . Nome em MAIÚSCULO

                . Separação com _

                EX:

                    PI = 3.14
                    TAXA_JUROS = 0.05
                    IDADE_MINIMA = 18
        
            Mesmo que Python permita mudar, a regra é lógica, não da linguagem.

        Exemplo 1 — Regra matemática

            PI = 3.14
            area = PI * 10 * 10

        Mental: “PI não muda. O raio pode mudar.”

        Exemplo 2 — Regra de negócio
            
            IDADE_MINIMA = 18
            idade = 20

        Mental: “A idade muda, a regra não.”

        Exemplo 3 — Evitando número mágico

            Ruim:

                total = preco * 0.1

            Bom:

                DESCONTO = 0.1
                total = preco * DESCONTO
            
        ERROS COMUNS:

            . Usar valor fixo direto no código

            . Espalhar o mesmo número em vários lugares

            . Tratar regra como variável

            . Nomear constante como variável comum

        Regra prática:

            - Se você precisar procurar o número no código para entender, ele 
            deveria ser uma constante.

        FRASE-CHAVE PARA MEMORIZAR:

            . Variável guarda estado.

            . Constante guarda regra.

        DICAS:

            . Regra → constante
            . Dado do usuário → variável
            . Constante no topo do código
            . Nome claro e em maiúsculo
            . Menos números “soltos” = menos erro

    =====================================================================

    Tipos de dados:

        - Tipo de dado define o que uma informação é e o que pode ser feito 
        com ela.

        Existem duas grandes visões:

            . Primitivos × Compostos

            . Objeto × Não-objeto

            Essas visões se complementam, não competem.
        
        TIPOS PRIMITIVOS (ou simples):

            - Guardam um único valor simples.

            Características:

                Valor único

                Não possuem partes internas

                Representam dados básicos

            Exemplos comuns:

                Número inteiro → 10

                Número real → 2.5

                Texto → "Olá"

                Lógico → True / False

            Ideia-chave:

                - Primitivo = uma informação só.

        TIPOS COMPOSTOS:

            - Guardam vários valores ou estruturas internas.

            Características:

                Podem conter vários dados

                Organizam informações relacionadas

                Facilitam trabalhar com conjuntos

            Exemplos comuns:

                Lista

                Tupla

                Conjunto

                Dicionário

            Ideia-chave:

                - Composto = várias informações agrupadas.

        COMPARAÇÃO RÁPIDA:

            | Tipo      | Quantidade de dados |
            | --------- | ------------------- |
            | Primitivo | 1 valor             |
            | Composto  | Vários valores      |

        NÃO-OBJETO (visão lógica):

            - Dado sem comportamento próprio.

            . Só representa um valor

            . Não “faz coisas”
            
            . Usado diretamente em cálculos e decisões

            Exemplos:

                Número

                Texto

                Booleano

            Pense assim:

                . É só dado, não é coisa.

        OBJETO (visão mais avançada):

            - Objeto = dado + comportamento.

            Características:

                . Tem valor

                . Tem ações

                . Possui estrutura interna

                . Pode ser manipulado por métodos

            Exemplo conceitual:

                . Uma lista guarda valores e sabe adicionar, remover, ordenar.

            Objeto é algo que:

                - Guarda dados

                - Sabe operar sobre si mesmo

                - Referencia moldes específicos para se realizar ações

        OBJETO × NÃO-OBJETO (resumo mental):

            | Conceito   | O que é      |
            | ---------- | ------------ |
            | Não-objeto | Dado puro    |
            | Objeto     | Dado + ações |

        Em Python:
        
            Tudo é objeto, mas conceitualmente essa separação ajuda muito a 
            entender POO.

        Exemplo 1 — Primitivo

            idade = 20

        Mental: Um único valor.

        Exemplo 2 — Composto

            notas = [7, 8, 9]

        Mental: Vários valores agrupados.

        Exemplo 3 — Objeto em ação

            notas.append(10)

        Mental: A lista faz algo.

        Exemplo 4 — Não-objeto

            soma = 10 + 5

        Mental: Apenas valores sendo usados.

        ERROS COMUNS:

            - Achar que tudo é só número
            - Confundir tipo com valor
            - Não perceber quando precisa de estrutura
            - Tentar resolver tudo com primitivos

            Regra prática:

                . Muitos dados relacionados → tipo composto.

        FRASES-CHAVE PARA MEMORIZAR:

            Primitivo = um valor
            Composto = vários valores
            Objeto = dado que sabe agir
            Não-objeto = dado puro

    =====================================================================

    Verificação de tipo (type, issinstance, issubclass):

        - Verificar tipo é perguntar: “que tipo de coisa é isso?”

        Em Python, usamos isso para:

            Evitar erros

            Tomar decisões

            Garantir que um dado é do tipo esperado

            Trabalhar com objetos e herança

        VISÃO LÓGICA (ANTES DO CÓDIGO):

            Sempre pense assim:

                1. Isso é um valor ou um objeto?

                2. Preciso saber exatamente o tipo ou apenas se pertence a um 
                grupo?

                3. Estou lidando com classe ou instância?

            Essas perguntas definem qual ferramenta usar.

        type() — qual é o tipo exato:

            - Retorna o tipo exato do valor ou objeto.

            Ideia-chave:

                . type compara identidade de tipo, não parentesco.

            Exemplo:
                
                x = 10
                type(x)

            Leitura humana:

                “O tipo exato de x é inteiro.”

            Comparação direta:

                type(x) == int

            Só será True se for exatamente int.

            Quando usar type?

                . Testes simples
                . Depuração
                . Verificação rígida

                . Não é ideal para POO e herança

        isinstance() — pertence a esse tipo?

            - Verifica se um valor é instância de um tipo ou de seus subtipos.

            Ideia-chave:

                . isinstance respeita herança.

            Exemplo:

                x = 10
                isinstance(x, int)

            Leitura humana:

                “x é um inteiro ou algo derivado de inteiro?”

            Múltiplos tipos:

                isinstance(x, (int, float))

            Mental: “É número?”

            Quando usar isinstance?

                . Código real
                . Funções genéricas
                . Validação de entrada
                . POO

            É o mais usado na prática.

        issubclass() — classe filha de outra?

            - Verifica se uma classe herda de outra classe.

            PS: Não funciona com valores, só com classes.

            Exemplo:

                issubclass(bool, int)

            Leitura humana:

                “bool é uma subclasse de int?”

            Sim (True)

            Outro exemplo:

                issubclass(list, object)

            Sim — tudo herda de object.

        COMPARAÇÃO FINAL (anote isso):

            | Função       | Pergunta que responde       |
            | ------------ | --------------------------- |
            | `type`       | Qual é o tipo exato?        |
            | `isinstance` | É desse tipo ou derivado?   |
            | `issubclass` | Essa classe herda de outra? |

        ERROS COMUNS:

            . Usar type quando deveria usar isinstance
            . Usar issubclass com objetos
            . Comparar tipos sem entender herança
            . Verificar tipo quando não precisa

            Regra prática:

                - Prefira isinstance em código de verdade.

        FRASES-CHAVE PARA MEMORIZAR

            type é rígido
            isinstance é flexível
            issubclass é estrutural

    ===================================================================== 

    Entrada e saída de dados (Input / Output — I/O):

        - Entrada de dados é quando o programa recebe informação de fora.
        
        - Saída de dados é quando o programa mostra informação para fora.

        . Entrada → usuário, arquivo, sistema

        . Saída → tela, arquivo, sistema

        . Todo programa útil recebe algo e entrega algo

        ENTRADA DE DADOS (conceito):

            Em Python, a entrada padrão vem do teclado:

                input()

            Importante:

                input() sempre retorna TEXTO (string).

            Exemplo simples:

                nome = input("Digite seu nome: ")
                print(nome)

        SAÍDA DE DADOS (conceito):

            Saída padrão é feita com:

                print()

            Serve para:

                Mostrar resultados

                Informar erros

                Exibir mensagens

            Exemplo com texto:

                print("Olá, mundo!")
        
        CONVERSÃO DE TIPO (obrigatório entender):

            Como input() retorna texto, precisamos converter:

                idade = int(input("Digite sua idade: "))

            Se não converter → erro em cálculo.

            Exemplo 1 — Número:

                numero = int(input("Digite um número: "))
                print(numero)

            Exemplo 2 — Soma:

                a = int(input("Digite o primeiro número: "))
                b = int(input("Digite o segundo número: "))
                soma = a + b
                print(soma)

            Exemplo 3 — Texto formatado:

                nome = input("Nome: ")
                idade = int(input("Idade: "))
                print(f"{nome} tem {idade} anos")

        ERROS COMUNS:

            . Esquecer conversão de tipo
            . Fazer cálculo com string
            . Entrada confusa para o usuário
            . Não guardar o valor em variável

            Regra de ouro:

                . Entrada → variável → processamento → saída

        FRASE-CHAVE PARA MEMORIZAR:

            - Programa sem entrada e saída não conversa com o mundo.

        DICAS:

            . Leia a entrada com calma
            . Converta logo após o input
            . Guarde tudo em variáveis
            . Só depois faça contas
            . Mostre saída clara para o usuário

    =====================================================================

    Interpolação e concatenação e formatação:

        - Concatenação junta textos manualmente.
        
        - Interpolação insere valores dentro do texto automaticamente.
        
        - Formatação controla como o texto e os números aparecem.

        Objetivo principal:

            - mostrar informações de forma clara para humanos.

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO):

            Pergunte sempre:

                Vou juntar textos?

                Vou mostrar valores dentro do texto?

                Preciso controlar casas decimais, alinhamento ou formato?

                O usuário entenderia essa saída facilmente?

        CONCATENAÇÃO (forma antiga):

            . Juntar textos usando +

            EX:

                nome = "Renato"
                idade = "20"
                print("Nome: " + nome + " | Idade: " + idade)

            Observação importante:

                . Só funciona bem com texto

                . Fica confuso com números

                . Pouco usado hoje

            Problema comum:

                print("Idade: " + 20)  # erro

        INTERPOLAÇÃO (forma moderna — RECOMENDADA):

            - Inserir valores dentro do texto automaticamente

            Em Python, usamos f-strings:

                print(f"Nome: {nome} | Idade: {idade}")

            Vantagens:

                Mais legível

                Aceita qualquer tipo

                Mais profissional

                Menos erro

            Use isso sempre que possível.

        FORMATAÇÃO DE VALORES:

            - Controlar como o valor aparece

            + Casas decimais:

                preco = 10.56789
                print(f"Preço: {preco:.2f}")

            Mostra apenas 2 casas decimais.

            + Texto alinhado:

                print(f"{nome:<10} {idade:>3}")

            . < esquerda

            . > direita

            . número = largura

            + Formatação monetária (simples):

                total = 1234.5
                print(f"Total: R$ {total:.2f}")

        Ruim (concatenação excessiva):

            print("Total: R$ " + str(total))

        Bom (interpolação):

            print(f"Total: R$ {total:.2f}")

        ERROS COMUNS:

            . Usar concatenação com números
            . Converter tudo para string sem necessidade
            . Saída confusa para o usuário
            . Não formatar valores financeiros

        Regra prática:

            - Se tem variável no texto → use f-string.

        FRASES-CHAVE PARA MEMORIZAR:

            Concatenação é manual
            
            Interpolação é automática
            
            Formatação é controle visual

        DICAS:

            . Use f"" sempre
            . Formate números financeiros
            . Saída clara vale mais que código curto
            . Pense no usuário lendo

        Outras saídas:

            Saída com vírgula no print:

                Você pode passar vários valores no print separados por vírgula:

                    nome = "Renato"
                    idade = 20
                    print("Nome:", nome, "| Idade:", idade)

            Por padrão o print coloca um espaço entre os itens.
            Você pode controlar com sep e end:

                print("A", "B", "C", sep="-")   # A-B-C
                print("Oi", end="!")           # Oi!

            Formatação com % (antiga, mas cai em exercícios):

                Sintaxe:

                    %s texto

                    %d inteiro

                    %.2f float com 2 casas

                EX:

                    nome = "Renato"
                    idade = 20
                    print("Nome: %s | Idade: %d" % (nome, idade))

                    preco = 10.567
                    print("Preço: R$ %.2f" % preco)

            Formatação com .format():

                Por posição:

                    nome = "Renato"
                    idade = 20
                    print("Nome: {} | Idade: {}".format(nome, idade))

                Por nome:

                    print("Nome: {n} | Idade: {i}".format(n=nome, i=idade))

                Casas decimais:

                    total = 1234.5
                    print("Total: R$ {:.2f}".format(total))

    =====================================================================

    Operadores aritméticos:

        - Operadores aritméticos servem para fazer cálculos matemáticos no 
        programa.

        Eles permitem:

            Somar

            Subtrair

            Multiplicar

            Dividir

            Divisão inteira

            Resto da divisão

            Potência

        Sem operadores, o programa não calcula nada.

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO)

            Pergunte sempre:

                Que cálculo o problema pede?
                
                É conta de escola (soma, divisão, média, etc.)?
                
                O resultado precisa ser inteiro ou decimal?
                
                Preciso do resto ou só do resultado?

            A lógica vem antes do símbolo.

        OPERADORES ARITMÉTICOS EM PYTHON:

            | Operador | Nome            | Exemplo  |
            | -------- | --------------- | -------- |
            | `+`      | Soma            | `a + b`  |
            | `-`      | Subtração       | `a - b`  |
            | `*`      | Multiplicação   | `a * b`  |
            | `/`      | Divisão         | `a / b`  |
            | `//`     | Divisão inteira | `a // b` |
            | `%`      | Resto (módulo)  | `a % b`  |
            | `**`     | Potência        | `a ** b` |
        
        Soma:

            a = 10
            b = 3
            print(a + b)   # 13

        Divisão (sempre gera decimal):

            print(10 / 3)  # 3.3333...

        Divisão inteira:

            print(10 // 3) # 3

        . Quantas vezes cabe, sem quebrar.

        Resto da divisão:

            print(10 % 3)  # 1
        
        . Muito usado para:

            Par ou ímpar

            Ciclos

            Quebras de grupo

        Potência:

            print(2 ** 3)  # 8

            print(pow(2, 3))  # 8

        Subtração:

            a = 10
            b = 3
            print(a - b)   # 7

        Multiplicação:

            a = 10
            b = 3
            print(a * b)   # 30

        Adicional: Raizes

            indice = 2
            radicando = 4

            raiz = radicando**(1/indice)

            print(raiz)  # 2.0

        abs() — valor absoluto:

            - Retorna o valor sem sinal (distância até o zero).

            Ex:

                print(abs(10))    # 10
                print(abs(-10))   # 10

                # tpécnica em caso de negativos, fazer conversão explícita
                print(-(-10)) # 10

        round() — arredondamento:

            - Arredonda um número.

            Ex:

                print(round(3.6))      # 4
                print(round(3.14159, 2))  # 3.14

            Pode receber:

                - 1 argumento → arredonda inteiro

                - 2 argumentos → casas decimais

        min() e max() — menor e maior:

            print(min(3, 7, 2))  # 2
            print(max(3, 7, 2))  # 7
            
            # Com iteraveis de tipo numérico:
            valores = [10, 3, 8]
            print(min(valores))
            print(max(valores))

        divmod() — divisão + resto:

            - Retorna quociente e resto juntos.

            q, r = divmod(10, 3)
            print(q, r)  # 3 1

        int(), float() — conversão numérica:

            - PS: int() corta, não arredonda.

                print(int(3.9))    # 3
                print(float(10))   # 10.0

        PRECEDÊNCIA (ordem das contas):

            - Python segue a matemática.

            Ordem:

                1. ()

                2. **

                3. * / // %

                4. + -

            Exemplo:

                resultado = 10 + 2 * 3

            Resultado: 16, não 36.

            Use parênteses para deixar claro:

                resultado = (10 + 2) * 3

             Resultado: 36.

        ERROS COMUNS

            . Esquecer conversão do input()
            . Usar / achando que retorna inteiro
            . Confundir % com porcentagem
            . Não usar parênteses quando precisa
            . Achar que abs arredonda
            . Confundir int() com round()
            . Não usar funções prontas
            . Repetir cálculo manual desnecessário

            % não é porcentagem, é resto da divisão.

            Se parece “básico demais”, provavelmente já existe função pronta.

        DICAS:

            . Converta o input imediatamente
            . Pense na matemática antes do operador
            . Use parênteses sem medo
            . Teste com números simples (2, 3, 10)

    =====================================================================

    Operadores de atribuição:

        - Operadores de atribuição servem para colocar ou atualizar valores em 
        variáveis.

        Eles fazem duas coisas ao mesmo tempo:

            1. Executam uma operação

            2. Guardam o resultado na variável

        Não é matemática pura, é estado do programa mudando.

        COMO PENSAR COMO LÓGICO:

            Sempre leia assim:

                “Pegue o valor atual da variável, faça algo, e guarde de volta.”

            Se você não entende isso, vai errar laço, contador e soma acumulada.

        ATRIBUIÇÃO SIMPLES:

            . =
                
                x = 10

            Mental: “Coloque 10 dentro de x.” / “x recebe 10” /
            “x atribui 10” / “x referencia 10”

        ATRIBUIÇÃO COM OPERAÇÃO:

            | Operador | Significado             |
            | -------- | ----------------------- |
            | `+=`     | soma e guarda           |
            | `-=`     | subtrai e guarda        |
            | `*=`     | multiplica e guarda     |
            | `/=`     | divide e guarda         |
            | `//=`    | divide inteiro e guarda |
            | `%=`     | resto e guarda          |
            | `**=`    | potência e guarda       |

        . +=

            total = 0
            total += 5

        Mesmo que:

            total = total + 5

        . -=

            saldo = 100
            saldo -= 30

        Mesmo que:

            saldo = saldo - 30

        . *=

            preco = 10
            preco *= 2

        Mesmo que:

            preco = preco * 2

        . /=

            media = 10
            media /= 2

        Mesmo que:

            media = media / 2

        . %= (muito usado em ciclos)

            x = 10
            x %= 3   # sobra 1

        Mesmo que:

            x = x % 3

        . **=

            n = 2
            n **= 3

        Mesmo que:

            n = n ** 3

        LEITURA HUMANA:

            Leia como:

                “x recebe x mais 1”

            Nunca como:

                “x mais igual 1”

        ERROS COMUNS

            . Usar sem entender o valor anterior
            . Confundir = com ==
            . Achar que cria variável nova
            . Usar antes de inicializar

            Regra de ouro:

                Nunca use += sem inicializar a variável antes.

        FRASE-CHAVE PARA MEMORIZAR

            - Operador de atribuição muda o estado da variável.

        DICAS:

            . Inicialize sempre
            . Leia o operador como frase
            . Use muito em contadores
            . Use em laços (em breve!)

    =====================================================================

    Operadores lógicos:

        - Operadores lógicos combinam condições e produzem verdadeiro ou falso.

        Eles trabalham com valores lógicos:

            True (verdadeiro)

            False (falso)

        São usados para:

            Decidir caminhos (if)

            Validar dados

            Criar regras compostas

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO):

            Sempre pergunte:

                1. Quantas condições existem?

                2. Todas precisam ser verdadeiras ou só uma?

                3. Existe negação de alguma condição?

            Traduza a frase humana para lógica.

        and — E:

            - Só é True se todas forem verdadeiras.

            EX:

                idade = 20
                tem_documento = True

                print(idade >= 18 and tem_documento)

            Tabela verdade (and):

                |    A    |   B    | A and B |
                | ------- | ------ | ------- |
                | True    | True   | True    |
                | True    | False  | False   |
                | False   | True   | False   |
                | False   | False  | False   |

        or — OU

            É True se pelo menos uma condição for verdadeira.

            EX:

                dia = "sábado"
                print(dia == "sábado" or dia == "domingo")

            Leitura humana:

                “É sábado ou domingo?”

            Tabela verdade (or):

                |    A    |   B    | A or B |
                | ------- | ------ | ------ |
                | True    | True   | True   |
                | True    | False  | True   |
                | False   | True   | True   |
                | False   | False  | False  |

        not — NÃO

            - Inverte o valor lógico.

            Exemplo:

                chovendo = False
                print(not chovendo)

            Leitura humana:

                “Não está chovendo.”

            Tabela Verdade:

                |   A   |   not A   |
                | ----- | --------- |
                | True  |   False   |
                | False |   True    |

        COMBINAÇÕES (muito comum):

            Ex1:

                idade = 17
                estudante = True

                print(idade < 18 and estudante)

            Ex2:

                senha_correta = False
                print(not senha_correta)

        PRECEDÊNCIA LÓGICA (importante):

            Ordem:

                1. not

                2. and

                3. or
            
            Use parênteses para clareza:

                (idade >= 18 and tem_documento) or autorizado

        ERROS COMUNS

            . Esquecer parênteses
            . Confundir and com or
            . Escrever frases mal traduzidas
            . Usar lógica sem pensar na frase humana

            Regra de ouro:

                Se não dá pra ler em português, a lógica está errada.

        FRASES-CHAVE PARA MEMORIZAR

            and exige tudo
            or aceita um
            not inverte

        DICAS:

            . Traduza para frase humana
            . Use parênteses sem medo
            . Teste com valores verdadeiros e falsos
            . Não complique a lógica cedo demais

    =====================================================================

    Operadores relacionais:

    =====================================================================

    in e is:

    =====================================================================

    Incremento / Decremento:

    =====================================================================

    Precedência:

    =====================================================================

    Swap:

    =====================================================================

    Casting:

    =====================================================================

    Coerção:

    =====================================================================

    Caracteres de controle:

    Números (inteiros e reais):

    Problema de arredondamento:

    strings e caracteres:

    parsings:

    Blocos e escopos:

    Estruturas condicionais / ternários:

    Estruturas de repetição:

    break, continue e pass:

    Variável acumuladora e Variável atribuidora

    Iterações e Iteráveis:

    Funções e lambdas:

    Recursões:

    Variáveis globais e locais:

    Operadores bit-wise:

    Listas, Arrays e Vetores:

    Índices:

    In place:

    Janelas:

    Slicing:

    Listas, Arrays e Vetores circulares:

    Matrizes:

    Diagonais:

    Matriz circular:

    Tuplas:

    Dicionários:

    Conjuntos:

    tecnica de ponteiros:

    Divisão e conquista:

    números aleatórios:

    Módulos, Bibliotecas e importações:

    Alias:

    Garbage:

    Arquivos:


Um pouco sobre POO:

    Objetos e classes

    Variáveis de classe e Construtor

    Métodos

    atributos e propriedades de classe

    atributos privados, protegidos e públicos

    métodos privados, protegidos e públicos

    Encapsulamento

    Composição, herança e delegação

    Polimorfismo

    Sub-tipagem

    Métodos de classe

    Métodos abstratos

    Métodos estáticos

    self e cls

    Métodos mágicos

    DataClass

    Setups, interfaces e Managers

    SOLID

Um pouco sobre Estruturas de dados:

    listas / vetores e matrizes não ordenadas

    listas / vetores e matrizes ordenadas

    matrizes

    algoritmos de busca

    algoritmo de Ordenações

    pilhas

    filas

    fila de prioridade

    fila circular

    fila de extremidade dupla

    deques

    Lista encadeada

    ávores

    hash tables

    grafos

    Busca em profundidade

    Busca em largura

    Busca gulosa

    Busca A*

    Algoritmo de Dijkstra
