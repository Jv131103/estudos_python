- Um programa ou software, √© o que podemos chamar de intelig√™ncia do computador

- O hardware √© a m√°quina, a parte f√≠sica

- Em computa√ß√£o, dados s√£o a representa√ß√£o simb√≥lica de um fato ou acontecimento.
Os fatos podem ser, nomes, datas, valores num√©ricos, imagens, etc. Ou seja,
qualquer coisa que possa ser medido, comparado ou representados no computador.

- Os s√≠mbolos mais comuns s√£o as letras e os n√∫meros. (As imagens e os sons s√£o representados
no computador por uma sequencia de n√∫mero).

- Uma informa√ß√£o √© um dado, ou conjunto de dados, ou o o resultado da transforma√ß√£o de um
conjunto de dados que, dentro de determinado contexto, fa√ßa sentido para algu√©m. Poe exemplo,
uma ficha m√©dica, ou um formul√°rio de cadastro.

- Qualquer fato, pode ser representado simbolicamente? N√£o. Por que certos, fatos,
n√£o podem ser representados como s√£o na realidade, por conta de n√£o poderem ser interpretados
l√≥gico-matematicamente. Outros, por conta de n√£o serem duais, assim n√£o interpretados, como zeros
e uns. Emo√ß√µes, sabores e sentimentos s√£o exemplos de fatos que n√£o podem ser representados,
por serem complexas e por terem reprodu√ß√£o al√©m do l√≥gico.

SOBRE SISTEMA BIN√ÅRIO

- S√£o representados por 0s e 1s, embora, haja outros sistemas, como tern√°rios,
decimais, hexadecimais e octais.

- O computador atualmente, entende apenas 0s e 1s que representam ligado e desligado,
tal que seguem o princ√≠pio de ebtrada e sa√≠da de energia no hardware.

- Possui um sistema de numera√ß√£o onde cada d√≠gito, aqui chamado de bit, tem apenas dois valores
poss√≠veis, ou seja, 0 e 1

- No sistema decimal, podemos representar at√© 10 elementos com um √∫nico d√≠gito:

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9

- No sistema bin√°rio, podemos representar apenas 2 com um √∫nico bit.

    0, 1

- Para se poder rtepresentar mais elementos, √© necess√°rio acrescentar outros d√≠gitos e bits.

- O 11¬∞ elemento no sistema decimal e'representado por 10.

    IMPORTANTE: Na computa√ß√£o, o valor 0 √© super significativo quanto a identificar elementos

- No sistema bin√°rio, o 3¬∞ elemento, j√° que s√≥ podemos representar o 2 como um √∫nico bit, ser√°
o 10.

- Tabela de 0, 20

    Decimal | Bin√°rio
    0       | 0
    1       | 1
    2       | 10
    3       | 11
    4       | 100
    5       | 101
    6       | 110
    7       | 111
    8       | 1000
    9       | 1001
    10      | 1010
    11      | 1011
    12      | 1100
    13      | 1101
    14      | 1110
    15      | 1111
    16      | 10000
    17      | 10001
    18      | 10010
    19      | 10011
    20      | 10100

- No sistema decimal, cada d√≠gito adicional aumenta em 10 vezes a capacidade de contagem, ao passo
que no bin√°rio, cada bit adicional aumenta em 2 vezes.

- Qual a capacidade de contagem de um n√∫mero com 3 d√≠gitos?

    10**3 = 1000

    - Vai de 0 a 999

- Qual a capacidade de contagem de um n√∫mero com 3 bits?

    2**3 = 8

    - Vai de 0 a 7

- Como saber quanto um bin√°rio vale em decimal?

    EX:

        1       0       0       1       1       0       1       0       1       0       1       1       1       0
        2**13   2**12   2**11   2**10   2**9    2**8    2**7    2**6    2**5    2**4    2**3    2**2    2**1    2**0
        8192    4096    2048    1024    512     256     128     64      32      16      8       4       2       1
        8192    0       0       1024    512     0       128     0       32      0       8       4       2       0

        8192 + 0 + 0 + 1024 + 512 + 0 + 128 + 0 + 32 + 0 + 8 + 4 + 2 + 0 =  9902


        1¬∞ linha: S√≠mbolo bin√°rio
        2¬∞ linha: Resutado do valor 2**n
        3¬∞ linha: Resultado do valor de 2**n * s√≠mbolo bin√°rio

        10011011

        2**7 = 128 * 1 = 128
        2**6 = 64 * 0 = 0
        2**5 = 32 * 0 = 0
        2**4 = 16 * 1 = 16
        2**3 = 8 * 1 = 8
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 1 = 1

        128 + 16 + 8 + 2 + 1 = 155

- Como saber quanto um decimal vale em bin√°rio?

    EX: 100

    100 / 2 = 50, resto 0
    50 / 2 = 25, resto 0
    25 / 2 = 12, resto 1
    12 / 2 = 6, resto 0,
    6 / 2 = 3, resto 0
    3 / 2 = 1, resto 1,
    1 / 2 = resto 1, pois 1 n√£o divide 2

    resultado dos restos: 0010011

    inverte ficar√°: 1100100

- Pr√°tico:

    Exerc√≠cio 1 - Foi vista na videoaula a convers√£o do n√∫mero
    bin√°rio 10011010111001 para o seu equivalente decimal que
    resultou em 9913.

    Acrescente um bit 0 √† direita (o menos significativo) deste
    n√∫mero bin√°rio e veja que n√∫mero decimal obter√°.
    
    Divida este novo n√∫mero decimal obtido pelo decimal anterior e
    analise o resultado.

        100110101110010

        2**14 = 16384 * 1 = 16384
        2**13 = 8192 * 0 = 0
        2**12 = 4096 * 0 = 0
        2**11 = 2048 * 1 = 2048
        2**10 = 1024 * 1 = 1024
        2**9 = 512 * 0 = 0
        2**8 = 256 * 1 = 256
        2**7 = 128 * 0 = 0
        2**6 = 64 * 1 = 64
        2**5 = 32 * 1 = 32
        2**4 = 16 * 1 = 16
        2**3 = 8 * 0 = 0
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 0 = 0

        16384 + 2048 + 1024 + 256 + 64 + 32 + 16 + 2 = 19826

        Divis√£o: 19826 // 9913 = 2


    Exerc√≠cio 2 - Com o resultado decimal obtido no exerc√≠cio 1, aplique a t√©cnica da divis√£o 
    sucessiva por 2 para obter seu equivalente bin√°rio. O resultado dever√° ser o n√∫mero original

        19826

        19826 // 2 = 9913, resto 0
        9913 // 2 = 4956, resto 1
        4956 // 2 = 2478, resto 0
        2478 // 2 = 1239, resto 0
        1239 // 2 = 619, resto 1
        619 // 2 = 309, resto 1
        309 // 2 = 154, resto 1
        154 // 2 = 77, resto 0
        77 // 2 = 38, resto 1
        38 // 2 = 19, resto 0
        19 // 2 = 9, resto 1
        9 // 2 = 4, resto 1
        4 // 2 = 2, resto 0
        2 // 2 = 1, resto 0
        1 // 2 = 1

        Resultado dos restos: 010011101011001

        Resultado final, invertido: 100110101110010

SOBRE O COMPUTADOR:

- A Mem√≥ria, √© onde se armazena e endere√ßa informa√ß√µes e dados. √â nela onde se permite
guardar informa√ß√µes e registr√°-las e mant√™-las enquanto o programa ou a m√°quina estiver ligada.
√â nela onde o processador se comunica retornando informa√ß√µes. Ela se divide em dois pontos:

    . Endere√ßo fixo: O local referente onde os dados est√£o armazenados

    . Conte√∫do varti√°vel: O conte√∫do que est√° armazenado no endere√ßo e pode ser mut√°vel

- 1 byte cont√©m 8 bits

- Os computadores tradicionais se comp√µem de uma grande sequencia de bytes de 8 bits

- A ideia original de que o byte deva ter 8 bits surgiu da necessidade de se ter um c√≥digo
para representar cada um dos caracteres vis√≠veis (letras, n√∫meros, sinais de pontua√ß√£o e
alguns s√≠mbolos mais utilizados como o $, %, @ e outros), al√©m de caracteres de controle
(invis√≠veis) tais como o comando de saltar linha na tela ou soar o beep do PC. Chegou na
conclus√£o que 8 bits era mais que o suficiente

- A tabela ASCII, √© um formato interpretador que serve de base para interpreta√ß√£o unicode
dos dados. Ela possui seus caracteres em 8 bits e foi uma das bases mais usadas e at√© hoje
√© bastante utilizada. Nela, a letra 'a' t√™m o valor de 01100001 (97 em decimal) e o caracter
num√©rico '1' tem o valor de 00110001 (49 em decimal).

- No caso dos n√∫meros, este valor √© meramente um identificador do s√≠mbolo do n√∫mero, porque
o seu valor matem√°tico est√° nos bits conforme vimos anteriormente. E como disse acima,
49 n√£o representa o valor matem√°tico 1 e sim representa o tipo de texto 1, ou seja,
o valor simb√≥lico, n√£o literal.

- O byte √© um agrupamento voltado aos conte√∫dos da mem√≥ria, sendo que a quantidade de bits
para fazer o endere√ßamento da mem√≥ria segue outra contagem. Os primiros Pcs pessoais tinham mem√≥ria
com endere√ßamento de 8 bits, o que permitia apenas 256 endere√ßos.

- A CPU (Central Processing Unit), √© o mecanismo principal do computador. √â nele onde as instru√ß√µes
s√£o processadas e ela √© respons√°vel por trabalhar com o conte√∫do das mem√≥ria, recebendo dados
e retornando-as / escrevendo para tal. Ela realiza um procedimento de coleta de cada item
endere√ßado na mem√≥ria, e faz um trabalho X nela dependendo do dado, procedimento pedido e 
comportamento do sistema com o hardware.

- Os conte√∫dos da CPU s√£o:

    . Instru√ß√µes:

        - Dizem a CPU o que fazer

        - Cada instru√ß√£o, possui um SET, que √© respons√°vel por dizer a CPU que coisas devem acontecer

            EX de um computador elementar de 4 bits a n√≠vel bin√°rio:

                x----------x--------------------------------------------------------------------x
                | Conte√∫do |                            A√ß√£o                                    |
                x----------x--------------------------------------------------------------------x
                |   0000   | Interrompe a execu√ß√£o do programa                                  |
                x----------x--------------------------------------------------------------------x
                |   0100   | L√™ o conte√∫do da mem√≥ria que est√° no endere√ßo logo a seguir a esta |
                |          | instru√ß√£o e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |   0110   | L√™ o conte√∫do da mem√≥ria que est√° no endere√ßo logo a seguir a esta |
                |          | instru√ß√£o e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |          | Soma o conte√∫do do registrador 1 com o conte√∫do do registrador 2   |
                |   0111   | e armazena o resultado no endere√ßo de mem√≥ria cujo n√∫mero equivale |
                |          | ao conte√∫do do endere√ßo a seguir a esta instru√ß√£o                  |
                x----------x--------------------------------------------------------------------x

            PS: Cada c√≥digo bin√°rio representa uma a√ß√£o espec√≠fica, previamente definida pela 
            arquitetura da CPU.

    . Dados:

        - Manipulados pelas instru√ß√µes para que determinado pedido ou resultado seja obtido


- Linguagem bin√°ria ou de m√°quina: √â a linguagem do computador, respons√°vel por seguir
sequencias complexas de instru√ß√µes, tudo isso seguindo no princ√≠pio bin√°rio.

- Linguagem Assembly: rela√ß√£o direta entre as instru√ß√µes em linguagem bin√°ria e express√µes
mnem√¥nicas.

    Instru√ß√£o Bin√°ria       Correspondente eletr√¥nico
          0000                         stop
          0100                         read 1
          0110                         read 2
          0111                         add 1 2

- Esta "altitude" do n√≠vel de uma linguagem diz respeito, em linhas gerais, a facilidade e rapidez
com que se produz um programa. Ou seja, s√£o necess√°rias menos instru√ß√µes escritas pelo programador
para se obter um mesmo resultado. Em outras palavras uma instru√ß√£o escrita produz mais instru√ß√µes
bin√°rias. Por√©m, linguagens de alto n√≠vel, costumam produzir programas de desempenho inferior

- Os compiladores leem o programa fonte e produzem um programa execut√°vel independente de qualquer
outro software que n√£o seja o sistema operacional do computador.

            PROGRAMA -> COMPILADOR -> PROGRAMA.exe 
            
        ps: Em sistemas UNIX PROGRAMA.exe, retorna apenas PROGRAMA, mas no fundo √© um execut√°vel 
        tamb√©m

- Os interpretadores leem o programa fonte, criam este programa na mem√≥ria (bin√°rio) e o executam.
N√£o existe programa executavel gerado.Tudo √© realizado pelo interpretador.

    . Os interpretadores facilitam o trabalho de manuten√ß√£o principalmente em grandes sistemas
    compostos de muitos programas

    . Em ambientes de muitos programas rodando simultaneamente, os interpretadores consomem menos
    mem√≥ria

    . Considerando uma mesma linguagem, o seu computador produz programas mais r√°pidos do que
    o seu interpretador.

SOBRE PROGRAMAS

- Um programa √© um conjunto de passos e instru√ß√µes, organizadas de maneira l√≥gica, que realiza um ou mais servi√ßos
de processamento de dados.

- Processamento de dados √© o ato de tratar dados brutos e obter dados tranformados, seguindo especifica√ß√µes previamente
estabelecidas, ou obter infortma√ß√µes com esses dados contextualizados.


                    DADOS BRUTOS -> PROGRAMA -> DADOS TRABALHADOS

- Um programa pode ser simples ou composto por diversos outros programas

- Um algoritmo √© uma sequencia finita de passos, etapas ou instru√ß√µes que resolvem determinados
problemas. Um algoritmo √© dito determin√≠stico quando se obt√©m sempre o mesmo resultado a partir dos
mesmos dados. Um programa pode ter 1 ou N algor√≠tmos.

- Um exemplo de um algoritmo funcional:

    . Cada linguagem t√™m uma estrutura ou sintaxe

    . Cada programa possui uma linha de execu√ß√£o. Dependendo da linguagem, ela precisa ser fechada
    ou conclu√≠da, para referenciar outra linha ou se fecha automaticamente.

    . vari√°veis s√£o defini√ß√µes e referencias a objetos ou valores no programa. Eles s√£o escopos
    de mem√≥ria onde se realizar√° procedimentos e armazenazem temp√≥r√°ria de dados e informa√ß√µes.
    Elas n√£o podem come√ßar com n√∫meros e s√≠mbolos que n√£o sejam _ e tamb√©m com espa√ßos.

    EX: ISSO FOI CRIADO POR MIM, UMA FORMA INTERPRETATIVA MINHA DE MOLDAR ALGORITMO FORA DA M√ÅQUINA
    √â MERA INTERPRETA√á√ÉO, PODEMOS USAR FERRAMENTAS J√Å PRONTAS QUE LEIAM EM PORTUGU√äS OU PODE MONTAR DO
    SEU JEITO, CONTANTO, QUE SIGA NORMAS E PADR√ïES DA COMPUTA√á√ÉO E QUE FIQUE F√ÅCIL DE VOC√ä APLICAR,
    LER E IMPLEMENTAR EM OUTRAS LINGUAGENS.

        T√çTULO: "Soma"
        OBSERVACAO: "Vai realizar a soma de dois n√∫mero"

        INICIO

        num1: int = int(ler("N1: "))
        num2: int = int(ler("N2: "))

        soma: int = num1 + num2   # Realiza a soma

        exibir f"Resultado = {soma}"

        FIM

- Um outro exemplo no qual usamos fun√ß√µes. Fu√ß√µes s√£o blocos de c√≥digos, especializados
para executar fun√ß√µes espec√≠ficas de c√≥digo, ou seja, realizam procedimentos dentro de um escopo,
para que seja implementado no escopo principal. Ela facilita a leitura e entendimento do c√≥digo e 
traz mais efici√™ncia, legibilidade e pode ser usada e reaproveitada em outros programas.

    T√çTULO: "Fun√ß√£o"
    OBSERVACAO: "Vai realizar uma demonstra√ß√£o do que √© uma fun√ß√£o"

    INICIO

    REALIZAR M√âDIA DE DOIS N√öMEROS
    [fun√ßao] media
        params:
            n1: int
            n2: int
        a√ß√µes:
            retornar (n1 + n2) / 2
    [fimfuncao]


    num1: float = float(ler("N1: "))
    num2: float = float(ler("N2: "))

    media: float = media(num1, num2)

    exibir f"A m√©dia √© {media:.2f}"

    FIM

- Ide vs Editor de c√≥digo fonte:

    . Ide (Integrated Development Environment): Uma IDE √© um ambiente completo 
    de desenvolvimento. Ela integra v√°rias ferramentas em um s√≥ lugar.

        O que uma IDE j√° traz integrada:

            + Editor de c√≥digo

            + Compilador / interpretador

            + Debugger (passo a passo)

            + Gerenciador de projetos

            + Gerenciador de depend√™ncias
            
            + Build / Run com um clique
            
            + Testes integrados

        A IDE entende:

            o projeto

            a linguagem

            a estrutura

            as depend√™ncias

        Exemplos t√≠picos

            . PyCharm

            . IntelliJ IDEA

            . Eclipse

            . Visual Studio

            . NetBeans

        ‚Üí ‚ÄúEu desenvolvo software aqui‚Äù

    . Editor de c√≥digo fonte: Um editor de c√≥digo √© uma ferramenta focada em 
    escrever e editar texto/c√≥digo. Ele n√£o se preocupa com o projeto inteiro,
    s√≥ com o arquivo que voc√™ est√° editando. 
    
        Um editor oferece:

            + Destaque de sintaxe (cores)

            + Numera√ß√£o de linhas

            + Busca e substitui√ß√£o

            + Autocompletar b√°sico

            + Leve e r√°pido
        
        Exemplos t√≠picos

            . VS Code (editor avan√ßado)

            . Sublime Text

            . Notepad++

            . Vim / Nano

        ‚Üí ‚ÄúEu escrevo c√≥digo aqui‚Äù


TABELA ASCII (origem hist√≥rica):

- ASCII foi o primeiro padr√£o de caracteres.

- Caracter√≠sticas:

    . 7 bits (0 a 127)

    . Letras A‚ÄìZ, a‚Äìz

    . D√≠gitos 0‚Äì9

    . S√≠mbolos b√°sicos

    . Sem acentos

- ASCII n√£o suporta:

    . √ß

    . √°, √©, √≠

    . emojis
 
    . l√≠nguas n√£o latinas

UNICODE (padr√£o universal)

- Unicode √© um cat√°logo gigante de caracteres do mundo inteiro.

- Inclui:

    . Letras latinas com acento

    . Japon√™s, chin√™s, √°rabe

    . S√≠mbolos matem√°ticos

    . Emojis üòÑüî•

    . Alfabetos antigos

- Cada caractere tem um c√≥digo √∫nico

- Unicode √© abstrato (s√≥ define os c√≥digos).

UTF-8 (codifica√ß√£o)

- UTF-8 √© a forma de guardar Unicode em bytes.

- Caracter√≠sticas:

    . Compat√≠vel com ASCII

    . Usa 1 a 4 bytes por caractere

    . Padr√£o da internet

    . Padr√£o do Python

- Unicode = o que √©

- UTF-8 = como √© armazenado


UM POUCO SOBRE L√ìGICA DE PROGRAMA√á√ÉO:

    Vari√°veis:

        - Vari√°vel √© um nome que guarda um valor na mem√≥ria para ser usado depois.

        . Vari√°vel = caixa com nome

        . Valor = conte√∫do da caixa

        . O valor pode mudar ao longo do programa

        . Serve para guardar dados tempor√°rios

        Por que vari√°veis existem?

            . Evitam repetir valores

            . Facilitam c√°lculos

            . Permitem decis√µes (if)

            . Permitem repeti√ß√µes (while, for)

        Antes de criar qualquer vari√°vel, pergunte:

            1. Que informa√ß√£o eu preciso guardar?

            2. Essa informa√ß√£o muda ou √© fixa?

            3. Vou usar esse valor depois?

            4. Esse nome est√° claro para um humano?

        - Nome bom de vari√°vel explica o que ela guarda.

        TIPOS MAIS COMUNS DE VARI√ÅVEIS (conceito):

            | Tipo    | Guarda o qu√™?       | Exemplo         |
            | ------- | ------------------- | --------------- |
            | inteiro | n√∫meros sem v√≠rgula | idade = 20      |
            | real    | n√∫meros com v√≠rgula | altura = 1.75   |
            | texto   | palavras/frases     | nome = "Renato" |
            | l√≥gico  | verdadeiro ou falso | aprovado = True |

        EXEMPLOS SIMPLES:

            Exemplo 1 ‚Äî Guardar valor

                idade = 20

            Mental: ‚ÄúCriei uma caixa chamada idade e coloquei o valor 20 dentro.‚Äù

            Exemplo 2 ‚Äî Usar vari√°vel

                preco = 10
                total = preco + 5
            
            Mental: ‚ÄúUsei o valor guardado para calcular outro.‚Äù

            Exemplo 3 ‚Äî Valor muda

                contador = 0
                contador = contador + 1

            Mental: ‚ÄúA vari√°vel continua existindo, mas o valor mudou.‚Äù
        
        ERROS COMUNS:

            Usar nomes confusos:

                x = 10   # ruim

            Melhor:

                quantidade = 10

            Usar vari√°vel sem valor:

                print(total)  # erro se total n√£o existir

            Pensar que vari√°vel √© o valor:

                - N√£o √©

                Vari√°vel √© o nome, n√£o o conte√∫do.

        FRASE-CHAVE (decora essa)

            . Vari√°vel n√£o √© n√∫mero, nem texto.

            . Vari√°vel √© um nome que aponta para um valor.

        DICAS:

            . Pense no nome antes do valor
            . Vari√°vel deve ter sentido humano
            . Uma vari√°vel = uma informa√ß√£o
            . Se travar, pergunte: ‚ÄúO que eu preciso guardar?‚Äù
    
    =====================================================================

    Constantes:

        - Constante √© um valor que N√ÉO deve mudar durante o programa.

        . Constante = valor fixo

        . Serve para representar regras, limites ou padr√µes

        . Evita ‚Äún√∫meros m√°gicos‚Äù espalhados no c√≥digo

        . Deixa o programa mais claro e seguro

        Ideia-chave:

            - Se n√£o pode mudar, n√£o deve ser vari√°vel.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Perguntas obrigat√≥rias antes de decidir:

                1. Esse valor pode mudar durante a execu√ß√£o?

                2. Ele representa uma regra do problema?

                3. Se mudar no futuro, deveria mudar em um s√≥ lugar?

                4. Esse valor tem significado fixo no mundo real?

            Se a resposta for ‚Äún√£o muda‚Äù ‚Üí constante

        DIFEREN√áA CLARA: VARI√ÅVEL √ó CONSTANTE:

            | Conceito  | Pode mudar?  | Exemplo        |
            | --------- | ------------ | -------------- |
            | Vari√°vel  | ‚úÖ Sim       | idade, saldo   |
            | Constante | ‚ùå N√£o       | PI, taxa fixa  |

        - Constante n√£o depende do usu√°rio, nem do tempo.

        COMO REPRESENTAR CONSTANTES (boa pr√°tica):

            Em Python, usa-se:

                . Nome em MAI√öSCULO

                . Separa√ß√£o com _

                EX:

                    PI = 3.14
                    TAXA_JUROS = 0.05
                    IDADE_MINIMA = 18
        
            Mesmo que Python permita mudar, a regra √© l√≥gica, n√£o da linguagem.

        Exemplo 1 ‚Äî Regra matem√°tica

            PI = 3.14
            area = PI * 10 * 10

        Mental: ‚ÄúPI n√£o muda. O raio pode mudar.‚Äù

        Exemplo 2 ‚Äî Regra de neg√≥cio
            
            IDADE_MINIMA = 18
            idade = 20

        Mental: ‚ÄúA idade muda, a regra n√£o.‚Äù

        Exemplo 3 ‚Äî Evitando n√∫mero m√°gico

            Ruim:

                total = preco * 0.1

            Bom:

                DESCONTO = 0.1
                total = preco * DESCONTO
            
        ERROS COMUNS:

            . Usar valor fixo direto no c√≥digo

            . Espalhar o mesmo n√∫mero em v√°rios lugares

            . Tratar regra como vari√°vel

            . Nomear constante como vari√°vel comum

        Regra pr√°tica:

            - Se voc√™ precisar procurar o n√∫mero no c√≥digo para entender, ele 
            deveria ser uma constante.

        FRASE-CHAVE PARA MEMORIZAR:

            . Vari√°vel guarda estado.

            . Constante guarda regra.

        DICAS:

            . Regra ‚Üí constante
            . Dado do usu√°rio ‚Üí vari√°vel
            . Constante no topo do c√≥digo
            . Nome claro e em mai√∫sculo
            . Menos n√∫meros ‚Äúsoltos‚Äù = menos erro

    =====================================================================

    Tipos de dados:

        - Tipo de dado define o que uma informa√ß√£o √© e o que pode ser feito 
        com ela.

        Existem duas grandes vis√µes:

            . Primitivos √ó Compostos

            . Objeto √ó N√£o-objeto

            Essas vis√µes se complementam, n√£o competem.
        
        TIPOS PRIMITIVOS (ou simples):

            - Guardam um √∫nico valor simples.

            Caracter√≠sticas:

                Valor √∫nico

                N√£o possuem partes internas

                Representam dados b√°sicos

            Exemplos comuns:

                N√∫mero inteiro ‚Üí 10

                N√∫mero real ‚Üí 2.5

                Texto ‚Üí "Ol√°"

                L√≥gico ‚Üí True / False

            Ideia-chave:

                - Primitivo = uma informa√ß√£o s√≥.

        TIPOS COMPOSTOS:

            - Guardam v√°rios valores ou estruturas internas.

            Caracter√≠sticas:

                Podem conter v√°rios dados

                Organizam informa√ß√µes relacionadas

                Facilitam trabalhar com conjuntos

            Exemplos comuns:

                Lista

                Tupla

                Conjunto

                Dicion√°rio

            Ideia-chave:

                - Composto = v√°rias informa√ß√µes agrupadas.

        COMPARA√á√ÉO R√ÅPIDA:

            | Tipo      | Quantidade de dados |
            | --------- | ------------------- |
            | Primitivo | 1 valor             |
            | Composto  | V√°rios valores      |

        N√ÉO-OBJETO (vis√£o l√≥gica):

            - Dado sem comportamento pr√≥prio.

            . S√≥ representa um valor

            . N√£o ‚Äúfaz coisas‚Äù
            
            . Usado diretamente em c√°lculos e decis√µes

            Exemplos:

                N√∫mero

                Texto

                Booleano

            Pense assim:

                . √â s√≥ dado, n√£o √© coisa.

        OBJETO (vis√£o mais avan√ßada):

            - Objeto = dado + comportamento.

            Caracter√≠sticas:

                . Tem valor

                . Tem a√ß√µes

                . Possui estrutura interna

                . Pode ser manipulado por m√©todos

            Exemplo conceitual:

                . Uma lista guarda valores e sabe adicionar, remover, ordenar.

            Objeto √© algo que:

                - Guarda dados

                - Sabe operar sobre si mesmo

                - Referencia moldes espec√≠ficos para se realizar a√ß√µes

        OBJETO √ó N√ÉO-OBJETO (resumo mental):

            | Conceito   | O que √©      |
            | ---------- | ------------ |
            | N√£o-objeto | Dado puro    |
            | Objeto     | Dado + a√ß√µes |

        Em Python:
        
            Tudo √© objeto, mas conceitualmente essa separa√ß√£o ajuda muito a 
            entender POO.

        Exemplo 1 ‚Äî Primitivo

            idade = 20

        Mental: Um √∫nico valor.

        Exemplo 2 ‚Äî Composto

            notas = [7, 8, 9]

        Mental: V√°rios valores agrupados.

        Exemplo 3 ‚Äî Objeto em a√ß√£o

            notas.append(10)

        Mental: A lista faz algo.

        Exemplo 4 ‚Äî N√£o-objeto

            soma = 10 + 5

        Mental: Apenas valores sendo usados.

        ERROS COMUNS:

            - Achar que tudo √© s√≥ n√∫mero
            - Confundir tipo com valor
            - N√£o perceber quando precisa de estrutura
            - Tentar resolver tudo com primitivos

            Regra pr√°tica:

                . Muitos dados relacionados ‚Üí tipo composto.

        FRASES-CHAVE PARA MEMORIZAR:

            Primitivo = um valor
            Composto = v√°rios valores
            Objeto = dado que sabe agir
            N√£o-objeto = dado puro

    =====================================================================

    Verifica√ß√£o de tipo (type, issinstance, issubclass):

        - Verificar tipo √© perguntar: ‚Äúque tipo de coisa √© isso?‚Äù

        Em Python, usamos isso para:

            Evitar erros

            Tomar decis√µes

            Garantir que um dado √© do tipo esperado

            Trabalhar com objetos e heran√ßa

        VIS√ÉO L√ìGICA (ANTES DO C√ìDIGO):

            Sempre pense assim:

                1. Isso √© um valor ou um objeto?

                2. Preciso saber exatamente o tipo ou apenas se pertence a um 
                grupo?

                3. Estou lidando com classe ou inst√¢ncia?

            Essas perguntas definem qual ferramenta usar.

        type() ‚Äî qual √© o tipo exato:

            - Retorna o tipo exato do valor ou objeto.

            Ideia-chave:

                . type compara identidade de tipo, n√£o parentesco.

            Exemplo:
                
                x = 10
                type(x)

            Leitura humana:

                ‚ÄúO tipo exato de x √© inteiro.‚Äù

            Compara√ß√£o direta:

                type(x) == int

            S√≥ ser√° True se for exatamente int.

            Quando usar type?

                . Testes simples
                . Depura√ß√£o
                . Verifica√ß√£o r√≠gida

                . N√£o √© ideal para POO e heran√ßa

        isinstance() ‚Äî pertence a esse tipo?

            - Verifica se um valor √© inst√¢ncia de um tipo ou de seus subtipos.

            Ideia-chave:

                . isinstance respeita heran√ßa.

            Exemplo:

                x = 10
                isinstance(x, int)

            Leitura humana:

                ‚Äúx √© um inteiro ou algo derivado de inteiro?‚Äù

            M√∫ltiplos tipos:

                isinstance(x, (int, float))

            Mental: ‚Äú√â n√∫mero?‚Äù

            Quando usar isinstance?

                . C√≥digo real
                . Fun√ß√µes gen√©ricas
                . Valida√ß√£o de entrada
                . POO

            √â o mais usado na pr√°tica.

        issubclass() ‚Äî classe filha de outra?

            - Verifica se uma classe herda de outra classe.

            PS: N√£o funciona com valores, s√≥ com classes.

            Exemplo:

                issubclass(bool, int)

            Leitura humana:

                ‚Äúbool √© uma subclasse de int?‚Äù

            Sim (True)

            Outro exemplo:

                issubclass(list, object)

            Sim ‚Äî tudo herda de object.

        COMPARA√á√ÉO FINAL (anote isso):

            | Fun√ß√£o       | Pergunta que responde       |
            | ------------ | --------------------------- |
            | `type`       | Qual √© o tipo exato?        |
            | `isinstance` | √â desse tipo ou derivado?   |
            | `issubclass` | Essa classe herda de outra? |

        ERROS COMUNS:

            . Usar type quando deveria usar isinstance
            . Usar issubclass com objetos
            . Comparar tipos sem entender heran√ßa
            . Verificar tipo quando n√£o precisa

            Regra pr√°tica:

                - Prefira isinstance em c√≥digo de verdade.

        FRASES-CHAVE PARA MEMORIZAR

            type √© r√≠gido
            isinstance √© flex√≠vel
            issubclass √© estrutural

    ===================================================================== 

    Entrada e sa√≠da de dados (Input / Output ‚Äî I/O):

        - Entrada de dados √© quando o programa recebe informa√ß√£o de fora.
        
        - Sa√≠da de dados √© quando o programa mostra informa√ß√£o para fora.

        . Entrada ‚Üí usu√°rio, arquivo, sistema

        . Sa√≠da ‚Üí tela, arquivo, sistema

        . Todo programa √∫til recebe algo e entrega algo

        ENTRADA DE DADOS (conceito):

            Em Python, a entrada padr√£o vem do teclado:

                input()

            Importante:

                input() sempre retorna TEXTO (string).

            Exemplo simples:

                nome = input("Digite seu nome: ")
                print(nome)

        SA√çDA DE DADOS (conceito):

            Sa√≠da padr√£o √© feita com:

                print()

            Serve para:

                Mostrar resultados

                Informar erros

                Exibir mensagens

            Exemplo com texto:

                print("Ol√°, mundo!")
        
        CONVERS√ÉO DE TIPO (obrigat√≥rio entender):

            Como input() retorna texto, precisamos converter:

                idade = int(input("Digite sua idade: "))

            Se n√£o converter ‚Üí erro em c√°lculo.

            Exemplo 1 ‚Äî N√∫mero:

                numero = int(input("Digite um n√∫mero: "))
                print(numero)

            Exemplo 2 ‚Äî Soma:

                a = int(input("Digite o primeiro n√∫mero: "))
                b = int(input("Digite o segundo n√∫mero: "))
                soma = a + b
                print(soma)

            Exemplo 3 ‚Äî Texto formatado:

                nome = input("Nome: ")
                idade = int(input("Idade: "))
                print(f"{nome} tem {idade} anos")

        ERROS COMUNS:

            . Esquecer convers√£o de tipo
            . Fazer c√°lculo com string
            . Entrada confusa para o usu√°rio
            . N√£o guardar o valor em vari√°vel

            Regra de ouro:

                . Entrada ‚Üí vari√°vel ‚Üí processamento ‚Üí sa√≠da

        FRASE-CHAVE PARA MEMORIZAR:

            - Programa sem entrada e sa√≠da n√£o conversa com o mundo.

        DICAS:

            . Leia a entrada com calma
            . Converta logo ap√≥s o input
            . Guarde tudo em vari√°veis
            . S√≥ depois fa√ßa contas
            . Mostre sa√≠da clara para o usu√°rio

    =====================================================================

    Interpola√ß√£o e concatena√ß√£o e formata√ß√£o:

        - Concatena√ß√£o junta textos manualmente.
        
        - Interpola√ß√£o insere valores dentro do texto automaticamente.
        
        - Formata√ß√£o controla como o texto e os n√∫meros aparecem.

        Objetivo principal:

            - mostrar informa√ß√µes de forma clara para humanos.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Pergunte sempre:

                Vou juntar textos?

                Vou mostrar valores dentro do texto?

                Preciso controlar casas decimais, alinhamento ou formato?

                O usu√°rio entenderia essa sa√≠da facilmente?

        CONCATENA√á√ÉO (forma antiga):

            . Juntar textos usando +

            EX:

                nome = "Renato"
                idade = "20"
                print("Nome: " + nome + " | Idade: " + idade)

            Observa√ß√£o importante:

                . S√≥ funciona bem com texto

                . Fica confuso com n√∫meros

                . Pouco usado hoje

            Problema comum:

                print("Idade: " + 20)  # erro

        INTERPOLA√á√ÉO (forma moderna ‚Äî RECOMENDADA):

            - Inserir valores dentro do texto automaticamente

            Em Python, usamos f-strings:

                print(f"Nome: {nome} | Idade: {idade}")

            Vantagens:

                Mais leg√≠vel

                Aceita qualquer tipo

                Mais profissional

                Menos erro

            Use isso sempre que poss√≠vel.

        FORMATA√á√ÉO DE VALORES:

            - Controlar como o valor aparece

            + Casas decimais:

                preco = 10.56789
                print(f"Pre√ßo: {preco:.2f}")

            Mostra apenas 2 casas decimais.

            + Texto alinhado:

                print(f"{nome:<10} {idade:>3}")

            . < esquerda

            . > direita

            . n√∫mero = largura

            + Formata√ß√£o monet√°ria (simples):

                total = 1234.5
                print(f"Total: R$ {total:.2f}")

        Ruim (concatena√ß√£o excessiva):

            print("Total: R$ " + str(total))

        Bom (interpola√ß√£o):

            print(f"Total: R$ {total:.2f}")

        ERROS COMUNS:

            . Usar concatena√ß√£o com n√∫meros
            . Converter tudo para string sem necessidade
            . Sa√≠da confusa para o usu√°rio
            . N√£o formatar valores financeiros

        Regra pr√°tica:

            - Se tem vari√°vel no texto ‚Üí use f-string.

        FRASES-CHAVE PARA MEMORIZAR:

            Concatena√ß√£o √© manual
            
            Interpola√ß√£o √© autom√°tica
            
            Formata√ß√£o √© controle visual

        DICAS:

            . Use f"" sempre
            . Formate n√∫meros financeiros
            . Sa√≠da clara vale mais que c√≥digo curto
            . Pense no usu√°rio lendo

        Outras sa√≠das:

            Sa√≠da com v√≠rgula no print:

                Voc√™ pode passar v√°rios valores no print separados por v√≠rgula:

                    nome = "Renato"
                    idade = 20
                    print("Nome:", nome, "| Idade:", idade)

            Por padr√£o o print coloca um espa√ßo entre os itens.
            Voc√™ pode controlar com sep e end:

                print("A", "B", "C", sep="-")   # A-B-C
                print("Oi", end="!")           # Oi!

            Formata√ß√£o com % (antiga, mas cai em exerc√≠cios):

                Sintaxe:

                    %s texto

                    %d inteiro

                    %.2f float com 2 casas

                EX:

                    nome = "Renato"
                    idade = 20
                    print("Nome: %s | Idade: %d" % (nome, idade))

                    preco = 10.567
                    print("Pre√ßo: R$ %.2f" % preco)

            Formata√ß√£o com .format():

                Por posi√ß√£o:

                    nome = "Renato"
                    idade = 20
                    print("Nome: {} | Idade: {}".format(nome, idade))

                Por nome:

                    print("Nome: {n} | Idade: {i}".format(n=nome, i=idade))

                Casas decimais:

                    total = 1234.5
                    print("Total: R$ {:.2f}".format(total))

    =====================================================================

    Operadores aritm√©ticos:

        - Operadores aritm√©ticos servem para fazer c√°lculos matem√°ticos no 
        programa.

        Eles permitem:

            Somar

            Subtrair

            Multiplicar

            Dividir

            Divis√£o inteira

            Resto da divis√£o

            Pot√™ncia

        Sem operadores, o programa n√£o calcula nada.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO)

            Pergunte sempre:

                Que c√°lculo o problema pede?
                
                √â conta de escola (soma, divis√£o, m√©dia, etc.)?
                
                O resultado precisa ser inteiro ou decimal?
                
                Preciso do resto ou s√≥ do resultado?

            A l√≥gica vem antes do s√≠mbolo.

        OPERADORES ARITM√âTICOS EM PYTHON:

            | Operador | Nome            | Exemplo  |
            | -------- | --------------- | -------- |
            | `+`      | Soma            | `a + b`  |
            | `-`      | Subtra√ß√£o       | `a - b`  |
            | `*`      | Multiplica√ß√£o   | `a * b`  |
            | `/`      | Divis√£o         | `a / b`  |
            | `//`     | Divis√£o inteira | `a // b` |
            | `%`      | Resto (m√≥dulo)  | `a % b`  |
            | `**`     | Pot√™ncia        | `a ** b` |
        
        Soma:

            a = 10
            b = 3
            print(a + b)   # 13

        Divis√£o (sempre gera decimal):

            print(10 / 3)  # 3.3333...

        Divis√£o inteira:

            print(10 // 3) # 3

        . Quantas vezes cabe, sem quebrar.

        Resto da divis√£o:

            print(10 % 3)  # 1
        
        . Muito usado para:

            Par ou √≠mpar

            Ciclos

            Quebras de grupo

        Pot√™ncia:

            print(2 ** 3)  # 8

            print(pow(2, 3))  # 8

        Subtra√ß√£o:

            a = 10
            b = 3
            print(a - b)   # 7

        Multiplica√ß√£o:

            a = 10
            b = 3
            print(a * b)   # 30

        Adicional: Raizes

            indice = 2
            radicando = 4

            raiz = radicando**(1/indice)

            print(raiz)  # 2.0

        abs() ‚Äî valor absoluto:

            - Retorna o valor sem sinal (dist√¢ncia at√© o zero).

            Ex:

                print(abs(10))    # 10
                print(abs(-10))   # 10

                # tp√©cnica em caso de negativos, fazer convers√£o expl√≠cita
                print(-(-10)) # 10

        round() ‚Äî arredondamento:

            - Arredonda um n√∫mero.

            Ex:

                print(round(3.6))      # 4
                print(round(3.14159, 2))  # 3.14

            Pode receber:

                - 1 argumento ‚Üí arredonda inteiro

                - 2 argumentos ‚Üí casas decimais

        min() e max() ‚Äî menor e maior:

            print(min(3, 7, 2))  # 2
            print(max(3, 7, 2))  # 7
            
            # Com iteraveis de tipo num√©rico:
            valores = [10, 3, 8]
            print(min(valores))
            print(max(valores))

        divmod() ‚Äî divis√£o + resto:

            - Retorna quociente e resto juntos.

            q, r = divmod(10, 3)
            print(q, r)  # 3 1

        int(), float() ‚Äî convers√£o num√©rica:

            - PS: int() corta, n√£o arredonda.

                print(int(3.9))    # 3
                print(float(10))   # 10.0

        PRECED√äNCIA (ordem das contas):

            - Python segue a matem√°tica.

            Ordem:

                1. ()

                2. **

                3. * / // %

                4. + -

            Exemplo:

                resultado = 10 + 2 * 3

            Resultado: 16, n√£o 36.

            Use par√™nteses para deixar claro:

                resultado = (10 + 2) * 3

             Resultado: 36.

        ERROS COMUNS

            . Esquecer convers√£o do input()
            . Usar / achando que retorna inteiro
            . Confundir % com porcentagem
            . N√£o usar par√™nteses quando precisa
            . Achar que abs arredonda
            . Confundir int() com round()
            . N√£o usar fun√ß√µes prontas
            . Repetir c√°lculo manual desnecess√°rio

            % n√£o √© porcentagem, √© resto da divis√£o.

            Se parece ‚Äúb√°sico demais‚Äù, provavelmente j√° existe fun√ß√£o pronta.

        DICAS:

            . Converta o input imediatamente
            . Pense na matem√°tica antes do operador
            . Use par√™nteses sem medo
            . Teste com n√∫meros simples (2, 3, 10)

    =====================================================================

    Operadores de atribui√ß√£o:

        - Operadores de atribui√ß√£o servem para colocar ou atualizar valores em 
        vari√°veis.

        Eles fazem duas coisas ao mesmo tempo:

            1. Executam uma opera√ß√£o

            2. Guardam o resultado na vari√°vel

        N√£o √© matem√°tica pura, √© estado do programa mudando.

        COMO PENSAR COMO L√ìGICO:

            Sempre leia assim:

                ‚ÄúPegue o valor atual da vari√°vel, fa√ßa algo, e guarde de volta.‚Äù

            Se voc√™ n√£o entende isso, vai errar la√ßo, contador e soma acumulada.

        ATRIBUI√á√ÉO SIMPLES:

            . =
                
                x = 10

            Mental: ‚ÄúColoque 10 dentro de x.‚Äù / ‚Äúx recebe 10‚Äù /
            ‚Äúx atribui 10‚Äù / ‚Äúx referencia 10‚Äù

        ATRIBUI√á√ÉO COM OPERA√á√ÉO:

            | Operador | Significado             |
            | -------- | ----------------------- |
            | `+=`     | soma e guarda           |
            | `-=`     | subtrai e guarda        |
            | `*=`     | multiplica e guarda     |
            | `/=`     | divide e guarda         |
            | `//=`    | divide inteiro e guarda |
            | `%=`     | resto e guarda          |
            | `**=`    | pot√™ncia e guarda       |

        . +=

            total = 0
            total += 5

        Mesmo que:

            total = total + 5

        . -=

            saldo = 100
            saldo -= 30

        Mesmo que:

            saldo = saldo - 30

        . *=

            preco = 10
            preco *= 2

        Mesmo que:

            preco = preco * 2

        . /=

            media = 10
            media /= 2

        Mesmo que:

            media = media / 2

        . %= (muito usado em ciclos)

            x = 10
            x %= 3   # sobra 1

        Mesmo que:

            x = x % 3

        . **=

            n = 2
            n **= 3

        Mesmo que:

            n = n ** 3

        LEITURA HUMANA:

            Leia como:

                ‚Äúx recebe x mais 1‚Äù

            Nunca como:

                ‚Äúx mais igual 1‚Äù

        ERROS COMUNS

            . Usar sem entender o valor anterior
            . Confundir = com ==
            . Achar que cria vari√°vel nova
            . Usar antes de inicializar

            Regra de ouro:

                Nunca use += sem inicializar a vari√°vel antes.

        FRASE-CHAVE PARA MEMORIZAR

            - Operador de atribui√ß√£o muda o estado da vari√°vel.

        DICAS:

            . Inicialize sempre
            . Leia o operador como frase
            . Use muito em contadores
            . Use em la√ßos (em breve!)

    =====================================================================

    Operadores l√≥gicos:

        - Operadores l√≥gicos combinam condi√ß√µes e produzem verdadeiro ou falso.

        Eles trabalham com valores l√≥gicos:

            True (verdadeiro)

            False (falso)

        S√£o usados para:

            Decidir caminhos (if)

            Validar dados

            Criar regras compostas

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre pergunte:

                1. Quantas condi√ß√µes existem?

                2. Todas precisam ser verdadeiras ou s√≥ uma?

                3. Existe nega√ß√£o de alguma condi√ß√£o?

            Traduza a frase humana para l√≥gica.

        and ‚Äî E:

            - S√≥ √© True se todas forem verdadeiras.

            EX:

                idade = 20
                tem_documento = True

                print(idade >= 18 and tem_documento)

            Tabela verdade (and):

                |    A    |   B    | A and B |
                | ------- | ------ | ------- |
                | True    | True   | True    |
                | True    | False  | False   |
                | False   | True   | False   |
                | False   | False  | False   |

        or ‚Äî OU

            √â True se pelo menos uma condi√ß√£o for verdadeira.

            EX:

                dia = "s√°bado"
                print(dia == "s√°bado" or dia == "domingo")

            Leitura humana:

                ‚Äú√â s√°bado ou domingo?‚Äù

            Tabela verdade (or):

                |    A    |   B    | A or B |
                | ------- | ------ | ------ |
                | True    | True   | True   |
                | True    | False  | True   |
                | False   | True   | True   |
                | False   | False  | False  |

        not ‚Äî N√ÉO

            - Inverte o valor l√≥gico.

            Exemplo:

                chovendo = False
                print(not chovendo)

            Leitura humana:

                ‚ÄúN√£o est√° chovendo.‚Äù

            Tabela Verdade:

                |   A   |   not A   |
                | ----- | --------- |
                | True  |   False   |
                | False |   True    |

        COMBINA√á√ïES (muito comum):

            Ex1:

                idade = 17
                estudante = True

                print(idade < 18 and estudante)

            Ex2:

                senha_correta = False
                print(not senha_correta)

        PRECED√äNCIA L√ìGICA (importante):

            Ordem:

                1. not

                2. and

                3. or
            
            Use par√™nteses para clareza:

                (idade >= 18 and tem_documento) or autorizado

        ERROS COMUNS

            . Esquecer par√™nteses
            . Confundir and com or
            . Escrever frases mal traduzidas
            . Usar l√≥gica sem pensar na frase humana

            Regra de ouro:

                Se n√£o d√° pra ler em portugu√™s, a l√≥gica est√° errada.

        FRASES-CHAVE PARA MEMORIZAR

            and exige tudo
            or aceita um
            not inverte

        DICAS:

            . Traduza para frase humana
            . Use par√™nteses sem medo
            . Teste com valores verdadeiros e falsos
            . N√£o complique a l√≥gica cedo demais

        CONCEITO AVAN√áADO (MUITO IMPORTANTE):

            - and e or retornam operandos, n√£o booleanos

            - Eles usam short-circuit evaluation (avalia√ß√£o curta)

            Isso permite padr√µes como:

                valor = entrada or valor_padrao

            ou

                condicao and funcao()

        Opera√ß√£o de Curto Circuito:

            - Curto-circuito √© quando o Python para de avaliar uma express√£o
            l√≥gica assim que o resultado j√° est√° decidido.

            Ele acontece com:

                and
                or

            REGRAS SIMPLES:

                and

                    Para no primeiro falsy

                        0 and 5

                    . 0 j√° √© falsy

                    . Python nem olha o 5

                or

                    Para no primeiro truthy

                        0 or 5

                    . 0 √© falsy

                    . Vai para 5

                    . 5 √© truthy ‚Üí para aqui

                not

                    N√£o tem curto-circuito, s√≥ inverte o valor.

                        not 0   # True

            POR QUE ISSO √â IMPORTANTE?

                Evita erros

                        lista = []
                        lista and lista[0]

                    n√£o d√° erro, porque lista √© falsy

                Mais performance:

                    . Menos opera√ß√µes

                    . Menos avalia√ß√µes

            FRASE PARA MEMORIZAR:

                and para no falso
                or para no verdadeiro

    =====================================================================

    Operadores relacionais:

        - Operadores relacionais comparam valores e geram um resultado l√≥gico:
            
            True ou False.

        Eles respondem perguntas como:

            √â maior?

            √â menor?

            √â igual?

            √â diferente?

            Sem operadores relacionais, n√£o existe decis√£o no programa.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre leia como pergunta humana:

                . ‚ÄúEsse valor √© maior que aquele?‚Äù

                . ‚ÄúS√£o iguais?‚Äù

                . ‚Äú√â diferente?‚Äù

            O resultado nunca √© n√∫mero, √© verdadeiro ou falso.

        OPERADORES RELACIONAIS EM PYTHON:

            | Operador | Significado    |
            | -------- | -------------- |
            |  >       | maior que      |
            |  <       | menor que      |
            |  >=      | maior ou igual |
            |  <=      | menor ou igual |
            |  ==      | igual          |
            |  !=      | diferente      |

        EXEMPLOS EXPLICADOS:

            . Maior / Menor

                print(10 > 5)    # True
                print(3 < 1)     # False

            . Maior ou igual / Menor ou igual

                print(18 >= 18)  # True
                print(5 <= 3)    # False

            . Igualdade (==)

                print(10 == 10)  # True
                print(10 == 5)   # False

            . Diferente (!=)

                print(10 != 5)   # True
                print(10 != 10)  # False

        Aten√ß√£o:

            x = 10   # atribui√ß√£o
            x == 10  # compara√ß√£o


        Rela√ß√µes com texto:

            - Strings tamb√©m podem ser comparadas com operadores relacionais.


            COMPARANDO TEXTO:

                nome = "Renato"
                print(nome == "Renato")   # True
                print(nome != "Ana")      # True

            Compara√ß√£o de texto √© exata (mai√∫scula ‚â† min√∫scula).

            Python compara strings:

                . caractere por caractere

                . seguindo a ordem alfab√©tica (tabela Unicode / ASCII)

                PS: N√£o √© ‚Äútamanho‚Äù, √© ordem lexical.

            COMO O PYTHON COMPARA STRINGS:

                A compara√ß√£o acontece:

                    1 - Do primeiro caractere

                    2 - Depois o segundo

                    3 - At√© encontrar diferen√ßa

                Exemplo mental:

                    "casa" vs "carro"
                    c  == c
                    a  == a
                    s  >  r   ‚Üí decis√£o aqui

            EXEMPLOS IMPORTANTES:

                . Ordem alfab√©tica

                    print("ana" < "bia")   # True
                    print("casa" > "carro")  # True

                . Mai√∫scula x min√∫scula (pegadinha!)

                    print("ana" < "Ana")  # False

                PS: Letras mai√∫sculas v√™m antes das min√∫sculas.

                . Comparando palavras:

                    palavra = "banana"
                    print(palavra >= "abacate")

            COMPARA√á√ÉO COM len():

                √Äs vezes o que voc√™ quer n√£o √© ordem, √© tamanho:

                    print(len("casa") > len("sol"))

                Comparar tamanho ‚â† comparar string diretamente.

        COMPARA√á√ïES COMBINADAS:

            idade = 20
            print(idade >= 18 and idade <= 65)

        Mental: ‚ÄúEst√° entre 18 e 65?‚Äù

        ERROS COMUNS

            . Usar = no lugar de ==
            . Comparar tipos diferentes sem querer
            . Esquecer que o resultado √© True/False
            . Fazer compara√ß√£o sem sentido l√≥gico

            . Achar que "z" > "ab" por tamanho
            . Ignorar mai√∫sculas e min√∫sculas
            . Comparar string quando queria comparar tamanho
            . N√£o normalizar entrada do usu√°rio

            Regra de ouro:

                Operador relacional sempre responde uma pergunta.

                Python compara texto como dicion√°rio, n√£o como humano.

        FRASES-CHAVE PARA MEMORIZAR

            . Relacional compara
            . L√≥gico combina
            . Aritm√©tico calcula
            . Atribui√ß√£o guarda

            . String √© comparada por ordem, n√£o por tamanho.
            . Mai√∫scula vem antes de min√∫scula.
            . Normalize antes de comparar.

        DICAS:

            . Leia cada compara√ß√£o em voz alta
            . Teste com valores simples
            . Use par√™nteses para clareza
            . Combine com operadores l√≥gicos

            . Normalize strings
            . Leia compara√ß√£o como dicion√°rio
            . Use len() quando quiser tamanho
            . Teste com mai√∫sculas e min√∫sculas

    =====================================================================

    in e is:

        - in pergunta se algo est√° dentro de outra coisa.
        
        - is pergunta se duas vari√°veis apontam para o MESMO objeto.

        Eles n√£o fazem a mesma coisa e n√£o s√£o intercambi√°veis.

        COMO PENSAR COMO L√ìGICO:

            Antes de escolher:

                Quero saber se pertence? ‚Üí in

                Quero saber se √© o mesmo objeto na mem√≥ria? ‚Üí is

            Valor igual ‚â† objeto igual.

        in ‚Äî pertin√™ncia:

            - Verifica se um elemento est√° contido em uma sequ√™ncia ou cole√ß√£o.

            Funciona com:

                str

                list

                tuple

                set

                dict (verifica chaves)
            
            . Exemplos com string:

                print("a" in "casa")     # True
                print("z" in "casa")     # False

            . Exemplos com lista

                numeros = [1, 2, 3]
                print(2 in numeros)      # True
                print(5 in numeros)      # False

            . Exemplo com dicion√°rio

                dados = {"nome": "Renato", "idade": 20}
                print("nome" in dados)   # True
                print("Renato" in dados) # False

            Em dicion√°rios, in verifica chaves, n√£o valores.

        is ‚Äî identidade

            - Verifica se duas vari√°veis apontam para o mesmo objeto na mem√≥ria.

            Exemplo simples:

                a = None
                print(a is None)   # True

            Uso correto cl√°ssico de is.

            Exemplo com n√∫meros (pegadinha)

                a = 256
                b = 256
                print(a is b)   # True (por otimiza√ß√£o interna)

                a = 1000
                b = 1000
                print(a is b)   # Pode ser False

            N√£o confie em is para comparar valores.

            Exemplo com listas:

                a = [1, 2, 3]
                b = [1, 2, 3]

                print(a == b)   # True (valores iguais)
                print(a is b)   # False (objetos diferentes)

        COMPARA√á√ÉO FINAL

            | Operador | Pergunta           |
            | -------- | ------------------ |
            | `in`     | Est√° dentro?       |
            | `is`     | √â o mesmo objeto?  |
            | `==`     | Tem o mesmo valor? |

        ERROS COMUNS

            . Usar is no lugar de ==
            . Comparar string com is
            . Usar in achando que compara igualdade
            . N√£o entender dicion√°rio com in

            Regra de ouro:

                Para valores ‚Üí ==
                Para identidade ‚Üí is

        FRASES-CHAVE PARA MEMORIZAR:

            in √© pertin√™ncia
            
            is √© identidade

            Igual n√£o √© o mesmo

        DICAS:

            . Leia o operador como pergunta
            . Nunca use is para comparar valor
            . Use is None sempre
            . Teste com listas para entender mem√≥ria

    =====================================================================

    Incremento / Decremento:

        - Incrementar √© aumentar um valor passo a passo.

        - Decrementar √© diminuir um valor passo a passo.

        Em Python n√£o existe ++ ou --.

            Tudo √© feito com operadores de atribui√ß√£o.

        COMO PENSAR COMO L√ìGICO:

            Leia sempre assim:

                ‚ÄúPegue o valor atual, altere um pouco, e guarde de volta.‚Äù

            Isso √© mudan√ßa de estado.

        FORMAS DE INCREMENTAR:

            . Forma cl√°ssica

                x = x + 1

            . Forma recomendada

                x += 1
            
            Ambas fazem a mesma coisa.

            . Incrementar por outro valor

                x += 5

        FORMAS DE DECREMENTAR:

            . Forma cl√°ssica

                x = x - 1

            . Forma recomendada

                x -= 1

            . Decrementar por outro valor

                x -= 3
        
        EXEMPLOS PR√ÅTICOS:

            . Contador

                contador = 0
                contador += 1
                contador += 1
                print(contador)  # 2

            . Contagem regressiva

                x = 5
                x -= 1
                x -= 1
                print(x)  # 3

            . Acumulador

                soma = 0
                soma += 10
                soma += 5
                print(soma)  # 15

        ERROS COMUNS

            . Tentar usar x++ ou x-- (isso n√£o existe em Python)
            . Usar incremento sem inicializar
            . Confundir incremento com atribui√ß√£o simples

            Regra de ouro:

                Sempre inicialize antes de incrementar.

        FRASES-CHAVE PARA MEMORIZAR

            
            Incrementar soma
            
            Decrementar subtrai
            
            Python n√£o tem ++

        DICAS:

            . Inicialize sempre
            . Leia o c√≥digo em voz alta
            . Use para contar, somar, iterar
            . Pense em estado, n√£o em f√≥rmula

    =====================================================================

    Preced√™ncia dos operadores e uso de um ou mais operadores:

        - Preced√™ncia define a ordem em que os operadores s√£o avaliados.

        Se voc√™ n√£o controlar a ordem, o Python controla por voc√™ ‚Äî e isso
        nem sempre √© o que voc√™ quer.

        Par√™nteses sempre vencem.

        COMO PENSAR COMO L√ìGICO:

            Pergunte sempre:

                Qual parte deve ser calculada primeiro?

                Essa conta √© clara para um humano?

                Preciso for√ßar a ordem com par√™nteses?
            
            C√≥digo claro > c√≥digo curto.

        ORDEM DE PRECED√äNCIA:

            Aritm√©ticos:

                1. ()
                2. **
                3. * / // %
                4. + -

            Relacionais:

                5. > < >= <=
                6. == !=

            L√≥gicos

                7. not
                8. and
                9. or

            Atribui√ß√£o

                10. = += -= *= /= ...

            Atribui√ß√£o sempre por √∫ltimo.
        
        Exemplo 1 ‚Äî Aritm√©tica simples:

            resultado = 10 + 2 * 3
            print(resultado)   # 16

        PS: Multiplica√ß√£o vem antes da soma.

        Exemplo 2 ‚Äî For√ßando ordem

            resultado = (10 + 2) * 3
            print(resultado)   # 36

        Exemplo 3 ‚Äî Relacional + aritm√©tico

            print(10 + 2 > 11)   # True

        PS: Soma primeiro, depois compara√ß√£o.

        Exemplo 4 ‚Äî L√≥gico + relacional

            idade = 17
            print(idade >= 18 or idade >= 16 and idade < 18)

        Avalia√ß√£o real:

            >= e <
            and
            or

        Exemplo 5 ‚Äî Com par√™nteses (melhor)

            print(idade >= 18 or (idade >= 16 and idade < 18))

        PS: Mesmo resultado, mais leg√≠vel.

        USO DE M√öLTIPLOS OPERADORES:

            Ruim

                if a > b and c < d or e == f:

            Bom:

                if (a > b and c < d) or e == f:

        ERROS COMUNS

            . Confiar s√≥ na preced√™ncia
            . Esquecer par√™nteses
            . C√≥digo imposs√≠vel de ler
            . Misturar tudo na mesma linha

            Regra de ouro:

                Se precisa pensar demais para entender, use par√™nteses.

        FRASES-CHAVE PARA MEMORIZAR:

            Par√™nteses mandam
            Pot√™ncia vem cedo
            and vence or
            Atribui√ß√£o √© a √∫ltima

        DICAS:

            . Sempre pense na ordem
            . Use par√™nteses por clareza
            . Misture operadores conscientemente
            . Leia a express√£o em voz alta

        Tabela completa de preced√™ncia (maior ‚Üí menor):

            | Prioridade | Operadores / forma                                                                | Observa√ß√µes r√°pidas                                |                                                                       |
            | ---------: | --------------------------------------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------- |
            |          1 | **Agrupamento / acesso**: `(...)`, `x[...]`, `x(...)`, `x.attr`                   | Par√™nteses, indexa√ß√£o, chamada de fun√ß√£o, atributo |                                                                       |
            |          2 | **Await**: `await x`                                                              | Em async                                           |                                                                       |
            |          3 | **Pot√™ncia**: `**`                                                                | **Associativa √† direita**: `2**3**2 = 2**(3**2)`   |                                                                       |
            |          4 | **Un√°rios**: `+x`, `-x`, `~x`                                                     | Ex.: `-n`, `+n`, bitwise NOT `~`                   |                                                                       |
            |          5 | **Multiplicativos**: `*`, `@`, `/`, `//`, `%`                                     | `@` √© multiplica√ß√£o matricial                      |                                                                       |
            |          6 | **Aditivos**: `+`, `-`                                                            | Soma/subtra√ß√£o                                     |                                                                       |
            |          7 | **Shifts**: `<<`, `>>`                                                            | Deslocamento de bits                               |                                                                       |
            |          8 | **Bitwise AND**: `&`                                                              |                                                    |                                                                       |
            |          9 | **Bitwise XOR**: `^`                                                              |                                                    |                                                                       |
            |         10 | **Bitwise OR**: `                                                                 | `                                                  |                                                                       |
            |         11 | **Compara√ß√µes**: `<`, `<=`, `>`, `>=`, `!=`, `==`, `in`, `not in`, `is`, `is not` | Compara√ß√µes podem ‚Äúencadear‚Äù: `a < b < c`          |                                                                       |
            |         12 | **NOT l√≥gico**: `not x`                                                           | `not` vem antes de `and/or`                        |                                                                       |
            |         13 | **AND l√≥gico**: `and`                                                             |                                                    |                                                                       |
            |         14 | **OR l√≥gico**: `or`                                                               |                                                    |                                                                       |
            |         15 | **Condicional (tern√°rio)**: `x if cond else y`                                    | Avalia `cond` e escolhe `x` ou `y`                 |                                                                       |
            |         16 | **Lambda**: `lambda`                                                              | √â o mais fraco entre ‚Äúexpress√µes normais‚Äù          |                                                                       |
            |         17 | **Walrus**: `:=`                                                                  | Atribui√ß√£o como express√£o (bem baixa)              |                                                                       |
            |         18 | **Atribui√ß√µes**: `=`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`, `&=`, `^=`, `   | =`, `<<=`, `>>=`, `@=`                             | **N√£o √© express√£o** comum (√© statement); fica ‚Äúpor √∫ltimo‚Äù na pr√°tica |

        Detalhes important√≠ssimos:

            ** (pot√™ncia) √© mais forte que un√°rio, e √© √† direita:

                -2**2 vira -(2**2) = -4

                (-2)**2 = 4

            Compara√ß√µes t√™m uma faixa √∫nica: tudo de < at√© is e in tem a mesma
            prioridade, e pode encadear:

                1 < x < 10 (equivale a 1 < x and x < 10, mas sem avaliar x duas 
                            vezes)
            
            L√≥gicos: not > and > or.

    =====================================================================

    Swap:

        - Swap √© a troca de valores entre duas vari√°veis.

        Ap√≥s um swap:

            . o valor de a vai para b

            . o valor de b vai para a

        As vari√°veis continuam as mesmas ‚Äî s√≥ os valores mudam.

        COMO PENSAR COMO L√ìGICO (ESSENCIAL):

            Antes do c√≥digo, pense assim:

                Tenho dois valores

                Quero trocar os valores

                N√£o posso perder nenhum no processo

            O problema central do swap √© n√£o sobrescrever um valor antes de 
            salv√°-lo.

        O ERRO CL√ÅSSICO (N√ÉO FUNCIONA):

                a = 5
                b = 10

                a = b
                b = a

            O que acontece de verdade:

                . a vira 10

                . b recebe a (que j√° √© 10)

                . o 5 se perde

            Esse erro mostra por que o swap existe.

        SWAP COM VARI√ÅVEL AUXILIAR (FORMA UNIVERSAL):

            - Funciona em qualquer linguagem.

                a = 5
                b = 10
                
                temp = a
                a = b
                b = temp
            
            Leitura humana:

                1. Guarde a em temp

                2. Coloque b em a

                3. Coloque temp em b

            . Seguro
            . Did√°tico
            . √ìtimo para aprender l√≥gica

        SWAP EM PYTHON (FORMA IDIOM√ÅTICA):

            - Python permite swap sem vari√°vel auxiliar, usando desempacotamento.

                a = 5
                b = 10

                a, b = b, a

            O que acontece internamente:

                . Python cria uma tupla tempor√°ria

                . Depois distribui os valores

            N√£o √© m√°gica, √© recurso da linguagem.

        SWAP COM EXPRESS√ïES (IMPORTANTE):

                x = 3
                y = x + 2

                x, y = y, x

            Primeiro o Python avalia tudo do lado direito, depois faz as 
            atribui√ß√µes.

            Isso evita conflito de valores.

        SWAP ‚â† COMPARA√á√ÉO:

            Errado:

                a == b

            Correto:

                a, b = b, a

            == compara, n√£o troca.

        SWAP E MEM√ìRIA (IDEIA IMPORTANTE):

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            . As refer√™ncias s√£o trocadas
            . As listas n√£o s√£o copiadas

        ERROS COMUNS

            . Fazer a = b; b = a
            . Confundir swap com compara√ß√£o
            . Achar que Python copia valores
            . N√£o entender avalia√ß√£o do lado direito

            Regra de ouro:

                Nunca sobrescreva um valor antes de salv√°-lo.

        FRASES-CHAVE PARA MEMORIZAR

            Swap troca valores, n√£o vari√°veis
            Swap exige preservar informa√ß√£o
            Python avalia antes de atribuir

        DICAS:

            . Pense em preservar valores
            . Lado direito √© avaliado primeiro
            . Use swap Python quando poss√≠vel
            . Use vari√°vel auxiliar para entender l√≥gica

        SWAP COM ITER√ÅVEIS:

            - Swap em iter√°veis √© a troca de elementos dentro de uma estrutura.

            . Iter√°vel = algo que tem v√°rios valores (lista, string, tupla, etc.)

            . Swap = trocar posi√ß√µes ou refer√™ncias

            . Base de ordenacÃßaÃÉo, invers√£o, reorganiza√ß√£o

            Quase todo algoritmo cl√°ssico usa swap em iter√°veis.

            COMO PENSAR COMO L√ìGICO:

                Antes de fazer swap em iter√°vel, pergunte:

                    Vou trocar valores ou posi√ß√µes?

                    O iter√°vel √© mut√°vel ou imut√°vel?

                    A troca √© local (√≠ndices) ou global (estrutura inteira)?

                Isso define a t√©cnica.

            1) SWAP DE ELEMENTOS EM LISTAS (FORMA B√ÅSICA)

                - Listas s√£o mut√°veis, ent√£o podemos trocar posi√ß√µes.

                    lista = [10, 20, 30]
                    lista[0], lista[2] = lista[2], lista[0]

                Resultado:

                    [30, 20, 10]

                Troca de elementos, n√£o da lista inteira.

            2) SWAP COM VARI√ÅVEL AUXILIAR (DID√ÅTICO)

                    lista = [1, 2, 3]

                    temp = lista[0]
                    lista[0] = lista[1]
                    lista[1] = temp

            3) SWAP EM ITER√ÅVEIS IMUT√ÅVEIS (STRING / TUPLA)

                - Strings e tuplas n√£o podem ser alteradas diretamente.

                Errado:

                    s = "abc"
                    s[0], s[2] = s[2], s[0]

                Correto (converter):

                    s = "abc"
                    lista = list(s)
                    lista[0], lista[2] = lista[2], lista[0]
                    s = "".join(lista)

                Imut√°vel ‚Üí cria novo objeto.

            4) SWAP DE FATIAS (SLICES)

                Inverter partes

                    lista = [1, 2, 3, 4, 5]
                    lista[:2], lista[2:] = lista[2:], lista[:2]

                Resultado:

                    [3, 4, 5, 1, 2]

                Muito usado em rota√ß√µes.

            5) SWAP PARA INVERS√ÉO DE LISTA (ALGOR√çTMICO)

                . Manual (com dois √≠ndices)

                    lista = [1, 2, 3, 4]
                    i = 0
                    j = len(lista) - 1

                    while i < j:
                        lista[i], lista[j] = lista[j], lista[i]
                        i += 1
                        j -= 1

            Aqui o swap √© o motor da invers√£o.

            6) SWAP EM ALGORITMOS DE ORDENA√á√ÉO

                . Bubble sort (exemplo cl√°ssico)

                    for i in range(len(lista)):
                        for j in range(len(lista) - 1):
                            if lista[j] > lista[j + 1]:
                                lista[j], lista[j + 1] = lista[j + 1], lista[j]

                Sem swap, n√£o existe ordena√ß√£o.

            7) SWAP DE REFER√äNCIAS (LISTAS INTEIRAS)

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            Aqui n√£o troca elementos ‚Äî troca quem aponta para quem.

            ERROS COMUNS

                . Tentar trocar string direto
                . Confundir troca de elemento com troca de refer√™ncia
                . Errar √≠ndice
                . Sobrescrever valor antes do swap

                Regra de ouro:

                    Swap em iter√°veis sempre depende de √≠ndice ou refer√™ncia.

            FRASES-CHAVE PARA MEMORIZAR:

                Lista troca elemento
                String cria outra
                Swap move posi√ß√£o
                Algoritmo vive de swap

            DICAS:

                . Identifique mutabilidade
                . Use √≠ndices conscientemente
                . Swap √© ferramenta, n√£o fim
                . Algoritmo = repeti√ß√£o + compara√ß√£o + swap

    =====================================================================

    Casting:

        - Casting √© a convers√£o expl√≠cita de um tipo de dado para outro.

        Em Python, usamos fun√ß√µes para isso:

            . int()

            . float()

            . str()

            . bool()

            . list(), tuple(), set()

        Casting n√£o muda o valor em si, muda como o Python interpreta esse valor.

        COMO PENSAR COMO L√ìGICO:

            Sempre se pergunte:

                Que tipo esse dado tem agora?

                Que tipo eu preciso para operar?

                A convers√£o √© segura ou pode gerar erro?

            Erros de casting s√£o erros de l√≥gica, n√£o de sintaxe.

        CASTING NUM√âRICO:

            . int()

                - Converte para inteiro (corta decimais).

                    print(int(3.9))     # 3
                    print(int("10"))    # 10

                Erro:

                    int("abc")

            . float()

                Converte para decimal.

                    print(float(10))       # 10.0
                    print(float("3.14"))   # 3.14

            . str()

                Converte para texto.

                    idade = 20
                    print("Idade: " + str(idade))

                Muito usado em sa√≠da de dados.

        CASTING L√ìGICO (bool()):

            - Converte valores para True ou False.

            . Regras importantes

                bool(0)        # False
                bool(1)        # True
                bool(-5)       # True
                bool("")       # False
                bool("abc")    # True
                bool([])       # False
                bool([1, 2])   # True

            Falsy:

                0
                0.0
                ""
                []
                {}
                None

            Todo o resto √© Truthy.

        CASTING COM ITER√ÅVEIS:

            . String ‚Üí lista

                list("abc")   # ['a', 'b', 'c']

            . Lista ‚Üí tupla

                tuple([1, 2, 3])

            . Lista ‚Üí conjunto

                set([1, 1, 2, 3])   # {1, 2, 3}

            Conjunto remove duplicados.

        CASTING AUTOM√ÅTICO (IMPL√çCITO):

            Python faz isso em alguns casos:

                print(10 + 2.5)   # 12.5

            O inteiro vira float automaticamente.

            Mas n√£o confie demais nisso.

        ERROS COMUNS:

            . Esquecer que input() retorna str
            . Converter string inv√°lida para n√∫mero
            . Achar que int() arredonda
            . Usar casting sem entender o dado

            Regra de ouro:

                Sempre valide antes de converter.

        FRASES-CHAVE PARA MEMORIZAR:

            Casting muda o tipo, n√£o o dado
            int() corta
            bool() segue truthy/falsy
            input() sempre retorna string

        DICAS:

            . Converta logo ap√≥s a entrada
            . Teste casos inv√°lidos
            . Use try/except quando avan√ßar
            . Entenda truthy/falsy profundamente

    =====================================================================

    Coer√ß√£o:

        - Coer√ß√£o √© quando o Python converte automaticamente um tipo em outro 
        durante uma opera√ß√£o.

        . N√£o √© voc√™ que manda converter

        . √â o Python tentando n√£o quebrar o programa

        . Acontece principalmente em opera√ß√µes mistas

        Coer√ß√£o ‚â† Casting

            Casting ‚Üí voc√™ manda

            Coer√ß√£o ‚Üí Python decide

        COMO PENSAR COMO L√ìGICO:

            Pergunte sempre:

                Estou misturando tipos diferentes?

                Existe um tipo ‚Äúmais abrangente‚Äù?

                O Python precisa escolher um tipo comum?

            O Python nunca perde informa√ß√£o na coer√ß√£o (sempre sobe o tipo).

        REGRA FUNDAMENTAL DA COER√á√ÉO:

            - O Python promove o tipo mais simples para o mais geral.

            Exemplo cl√°ssico:

                int  ‚Üí  float  ‚Üí  complex

            Nunca o contr√°rio.

        COER√á√ÉO NUM√âRICA:

            . int + float ‚Üí float

                    print(10 + 2.5)      # 12.5
                    print(type(10 + 2.5))  # float

                O 10 vira 10.0 automaticamente.

            . float + complex ‚Üí complex

                print(2.5 + 1j)

        COER√á√ÉO EM OPERA√á√ïES L√ìGICAS:

            . Booleano como n√∫mero

                    print(True + 1)    # 2
                    print(False * 10)  # 0
            
                Porque:

                    True ‚Üí 1
                    False ‚Üí 0

                Isso √© coer√ß√£o impl√≠cita.

        COER√á√ÉO EM EXPRESS√ïES CONDICIONAIS:

                if 10:
                    print("Executa")

            O 10 vira True automaticamente.

                if "":
                    print("N√£o executa")

            String vazia ‚Üí False.

            Aqui entra truthy e falsy (coer√ß√£o para bool).

        COER√á√ÉO QUE N√ÉO EXISTE (IMPORTANTE):

            Python n√£o faz coer√ß√£o perigosa.

            N√£o existe:

                "10" + 5

            N√£o existe:

                "3" * 2.5

            Aqui o Python exige casting expl√≠cito.

        COER√á√ÉO EM OPERADORES L√ìGICOS (and, or):

            Pegadinha importante:

                    print(0 or 10)    # 10
                    print(10 and 5)   # 5

                and e or:

                    . n√£o retornam True/False

                    . retornam um dos operandos

                Eles usam coer√ß√£o para decidir, mas retornam valores reais.

        COER√á√ÉO EM COMPARA√á√ïES:

                print(1 == True)   # True
                print(0 == False)  # True

            Booleano √© subclasse de int.

            Compara√ß√£o funciona, mas n√£o √© boa pr√°tica.

        COER√á√ÉO √ó CASTING (tabela mental)

            | Conceito | Quem decide | Exemplo     |
            | -------- | ----------- | ----------- |
            | Casting  | Voc√™        | `int("10")` |
            | Coer√ß√£o  | Python      | `10 + 2.5`  |

        ERROS COMUNS

            . Confiar demais na coer√ß√£o
            . Misturar tipos sem perceber
            . Achar que Python converte string para n√∫mero
            . Usar coer√ß√£o como ‚Äúatalho l√≥gico‚Äù

            Regra de ouro:

                Coer√ß√£o ajuda, mas n√£o substitui casting consciente.

        FRASES-CHAVE PARA MEMORIZAR:

            Coer√ß√£o √© autom√°tica
            Python sobe o tipo
            Nunca perde informa√ß√£o
            String n√£o vira n√∫mero sozinha

        DICAS:

            . N√£o confie em coer√ß√£o silenciosa
            . Prefira casting expl√≠cito
            . Teste tipos com type()
            . C√≥digo claro > c√≥digo esperto

    =====================================================================

    Caracteres de controle:

        - Caracteres de controle s√£o sequ√™ncias especiais que come√ßam com \ e 
        alteram a forma como o texto √© interpretado ou exibido.

        Eles servem para:

            . Quebra de linha

            . Tabula√ß√£o

            . Aspas dentro de texto

            . Sons, cursores e efeitos

            . Unicode e caracteres especiais

        N√£o aparecem ‚Äúvisualmente‚Äù, mas controlam o comportamento do texto.

        COMO PENSAR COMO L√ìGICO:

            Sempre pense assim:

                Texto normal ‚Üí aparece

                Caractere de controle ‚Üí controla o texto

            Eles n√£o s√£o letras, s√£o comandos embutidos.

        TABELA COMPLETA ‚Äî CARACTERES DE CONTROLE EM PYTHON:

            | Sequ√™ncia | Nome            | O que faz                    |
            | --------- | --------------- | ---------------------------- |
            | `\n`      | New line        | Quebra de linha              |
            | `\t`      | Tab             | Tabula√ß√£o horizontal         |
            | `\\`      | Backslash       | Mostra `\`                   |
            | `\'`      | Aspa simples    | Mostra `'`                   |
            | `\"`      | Aspa dupla      | Mostra `"`                   |
            | `\r`      | Carriage return | Retorna ao in√≠cio da linha   |
            | `\b`      | Backspace       | Apaga um caractere anterior  |
            | `\f`      | Form feed       | Avan√ßa p√°gina (legado)       |
            | `\v`      | Vertical tab    | Tabula√ß√£o vertical           |
            | `\a`      | Bell            | Alerta sonoro (se suportado) |
            | `\0`      | Null            | Caractere nulo               |

        CARACTERES NUM√âRICOS (ASCII / OCTAL / HEX):

            . Octal

                "\101"   # 'A'

            . Hexadecimal

                "\x41"   # 'A'
            
            Pouco usados hoje, mas existem.

        UNICODE (ESSENCIAL EM PYTHON):

            . Unicode de 16 bits

                "\u2764"   # ‚ù§

            . Unicode completo (32 bits)

                "\U0001F600"   # üòÄ

            Python √© totalmente Unicode.

        STRING RAW (IMPORTANTE):

            - String raw ignora caracteres de controle.

                print(r"C:\Users\Renato\Docs")

            Sem r, isso quebraria (\U, \D, etc.).

        EXEMPLOS PR√ÅTICOS:

            Quebra de linha:

                print("Linha 1\nLinha 2")

            Tabula√ß√£o:

                print("Nome\tIdade\tCidade")

            Aspas dentro de texto:

                print("Ele disse: \"Ol√°\"")

            \r sobrescrevendo linha

                print("Carregando...\rFeito!")

            Unicode

                print("Cora√ß√£o: \u2764")

        ERROS COMUNS

            . Esquecer que \n quebra linha
            . Caminhos do Windows sem string raw
            . Usar \ achando que √© caractere normal
            . Confundir \t com espa√ßos

            Regra de ouro:

                Se come√ßa com \, n√£o √© letra ‚Äî √© comando.

        FRASES-CHAVE PARA MEMORIZAR:

            \n quebra
            \t organiza
            \r retorna
            r"" protege
            Unicode manda

        DICAS:

            . Use \n para clareza
            . Use \t para alinhamento simples
            . Sempre use r"" em caminhos
            . Unicode funciona em tudo

    =====================================================================

    N√∫meros (inteiros e reais):

        - N√∫meros representam valores matem√°ticos usados em c√°lculos, 
        compara√ß√µes e decis√µes.

        Em Python, os principais tipos num√©ricos b√°sicos s√£o:

            Inteiros (int) ‚Üí n√∫meros sem parte decimal

            Reais (float) ‚Üí n√∫meros com parte decimal

        Python n√£o limita o tamanho de inteiros (diferente de C, Java).

        COMO PENSAR COMO L√ìGICO:

            Antes de usar n√∫meros, pergunte:

                Esse valor pode ter v√≠rgula?

                Preciso de exatid√£o absoluta ou aproxima√ß√£o?

                Esse n√∫mero vai crescer muito?

                Vou usar em compara√ß√µes, c√°lculos ou controle de fluxo?

            A escolha entre int e float √© l√≥gica, n√£o sint√°tica.

        1) N√öMEROS INTEIROS (int)

            O que s√£o?

                . Valores sem parte decimal

                . Positivos, negativos ou zero

                . Precisos (exatos)

                EX:

                    a = 10
                    b = -3
                    c = 0

            Caracter√≠sticas importantes:

                . Precis√£o exata

                . Sem limite de tamanho:

                    x = 10**100

            Ideais para:

                . contadores

                . √≠ndices

                . quantidades

                . idade, unidades, pe√ßas

            Opera√ß√µes comuns com int:

                10 + 3     # soma
                10 - 3     # subtra√ß√£o
                10 * 3     # multiplica√ß√£o
                10 // 3    # divis√£o inteira
                10 % 3     # resto
                10 ** 3    # pot√™ncia

            Divis√£o com inteiros:

                10 / 2     # 5.0 (float!)

            Toda divis√£o / gera float, mesmo entre inteiros.

        2) N√öMEROS REAIS (float)

            O que s√£o?

                . Valores com parte decimal

                . Representados internamente em ponto flutuante

                . Aproximados (n√£o exatos)

                EX:

                    x = 3.14
                    y = -0.5
                    z = 10.0

            Caracter√≠sticas importantes:

                . Possuem erro de precis√£o

                . N√£o s√£o ideais para dinheiro

                . Bons para:

                    m√©dias

                    medidas

                    c√°lculos cient√≠ficos

                    porcentagens

            PROBLEMA CL√ÅSSICO DE PRECIS√ÉO:

                print(0.1 + 0.2)  # 0.30000000000000004

            Isso n√£o √© bug, √© limita√ß√£o matem√°tica do float.

        3) CONVERS√ÉO ENTRE INT E FLOAT

            . int()

                    int(3.9)    # 3

                PS: Corta, n√£o arredonda.

            . float()

                    float(10)   # 10.0

            . round()

                round(3.6)      # 4
                round(3.14159, 2)  # 3.14

        4) OPERA√á√ïES MISTAS (COER√á√ÉO)

            EX:

                10 + 2.5   # 12.5

            O int √© convertido automaticamente para float.

            Python sempre sobe o tipo, nunca desce.

        5) COMPARA√á√ïES COM N√öMEROS

                10 > 5
                3.5 <= 4
                10 == 10.0   # True

            Cuidado com float:

                0.1 + 0.2 == 0.3   # False

            Melhor:

                abs((0.1 + 0.2) - 0.3) < 1e-9

        6) FUN√á√ïES NUM√âRICAS IMPORTANTES

            | Fun√ß√£o     | Uso             |
            | ---------- | --------------- |
            | `abs()`    | valor absoluto  |
            | `round()`  | arredondar      |
            | `pow()`    | pot√™ncia        |
            | `min()`    | menor           |
            | `max()`    | maior           |
            | `sum()`    | soma            |
            | `divmod()` | divis√£o + resto |

        ERROS COMUNS

            . Usar float para dinheiro
            . Comparar floats diretamente
            . Achar que int() arredonda
            . Esquecer que / gera float

            Regra de ouro:

                Contagem ‚Üí int
                Medida ‚Üí float

        FRASES-CHAVE PARA MEMORIZAR:

            Inteiro √© exato
            Float √© aproximado
            Divis√£o sempre flutua
            Precis√£o importa

        int, long e limites de 32/64 bits:

            Em Python moderno (3.x), n√£o existe mais long separado.
            
            Todo inteiro √© do tipo int e cresce automaticamente.

            Limites de 32 e 64 bits n√£o se aplicam da mesma forma em Python.

            1) int √ó long (hist√≥rico importante)

                . Python 2 (ANTIGO)

                    int ‚Üí limitado (32 ou 64 bits)

                    long ‚Üí inteiros grandes (ex: 1234567890123456789L)

                . Python 3 (ATUAL)

                    long n√£o existe

                    Tudo √© int

                    Inteiros t√™m precis√£o arbitr√°ria

                    O Python cuida do tamanho automaticamente.

            2) O MITO DOS 32 E 64 BITS EM PYTHON

                Python n√£o limita inteiros a 32 ou 64 bits como C/Java.

                Em linguagens como C:

                    int ‚Üí 32 bits

                    long ‚Üí 64 bits (depende da arquitetura)

                Em Python:

                    int cresce conforme necess√°rio

                    O limite √© mem√≥ria dispon√≠vel

                N√£o ocorre overflow aritm√©tico em int.

            3) ENT√ÉO O QUE SIGNIFICA 32 OU 64 BITS?

                Isso se refere √† arquitetura da m√°quina e ao ponteiro de mem√≥ria, 
                n√£o ao n√∫mero em si.

                . Python 32-bit:

                    - Ponteiros de 32 bits

                    - Menos mem√≥ria endere√ß√°vel

                . Python 64-bit:

                    - Ponteiros de 64 bits

                    - Mais mem√≥ria endere√ß√°vel

                O valor inteiro continua ilimitado, s√≥ o consumo de mem√≥ria muda.

            4) CUSTO DE MEM√ìRIA DE INTEIROS GRANDES

                Inteiros grandes:

                    Usam mais mem√≥ria

                    S√£o mais lentos que inteiros pequenos

                Python usa m√∫ltiplas ‚Äúpalavras‚Äù internas para representar
                o n√∫mero.

                Python √© mais seguro, por√©m menos previs√≠vel em performance 
                extrema.

            5) FLOAT AINDA TEM LIMITE (IMPORTANTE)

                Apesar do int ser ilimitado:

                    - float continua limitado (IEEE 754)

                    - Aproximadamente:

                        . ~1.8 √ó 10¬≥‚Å∞‚Å∏ (m√°ximo)

                        . ~15‚Äì17 d√≠gitos de precis√£o
                
                EX:

                    x = 1e308
                    x * 10   # inf

                Overflow ainda existe em float.

        CAMPO DE ESTUDO ‚Äî FUN√á√ïES ESPECIAIS DE int E float:

            - int e float n√£o s√£o apenas n√∫meros: s√£o objetos com m√©todos 
            pr√≥prios.

            Esses m√©todos servem para:

                Inspecionar o n√∫mero

                Converter formatos

                Trabalhar com bits

                Lidar com precis√£o

                Representa√ß√£o interna
            
            Isso diferencia Python de linguagens ‚Äúmais simples‚Äù.

            FUN√á√ïES ESPECIAIS DE int:

                1. bit_length():

                    Retorna quantos bits s√£o necess√°rios para representar o 
                    inteiro.

                    EX:

                        n = 10
                        print(n.bit_length())  # 4

                    10 em bin√°rio ‚Üí 1010 (4 bits)

                2. to_bytes() e from_bytes()

                    . to_bytes()

                        Converte inteiro para bytes.

                            n = 1024
                            b = n.to_bytes(2, byteorder="big")
                            print(b)
                    
                    . from_bytes()

                        Faz o caminho inverso.

                            n2 = int.from_bytes(b, byteorder="big")
                            print(n2)

                3. __int__() (conceitual)

                    Convers√£o interna para inteiro.

                        int(3.7)  # usa __int__

                    Raramente usado diretamente, mas fundamental para coer√ß√£o.

                4. Representa√ß√µes: bin(), oct(), hex()

                    n = 42
                    print(bin(n))  # 0b101010
                    print(oct(n))  # 0o52
                    print(hex(n))  # 0x2a

                5. int() com base (MUITO IMPORTANTE)

                    int("1010", 2)   # 10
                    int("FF", 16)    # 255
                    int("77", 8)     # 63

                Converte string em n√∫mero usando base num√©rica.
            
            FUN√á√ïES ESPECIAIS DE float:

                1. is_integer()

                    Verifica se o float representa um inteiro exato.

                        x = 10.0
                        y = 10.5

                        print(x.is_integer())  # True
                        print(y.is_integer())  # False

                    Muito √∫til para valida√ß√µes.
                
                2. as_integer_ratio()

                    Retorna o float como fra√ß√£o exata.

                        x = 0.75
                        print(x.as_integer_ratio())  # (3, 4)

                    Mostra como o float √© representado matematicamente.

                3. hex() (do float!)

                        x = 3.14
                        print(x.hex())

                    E o inverso:

                        float.fromhex(x.hex())

                    Representa√ß√£o exata do float em hexadecimal.

                4. __float__() (conceitual)

                    Usado quando Python for√ßa convers√£o para float:

                        float(10)

                    Importante para coer√ß√£o autom√°tica.

            QUANDO USAR ISSO NA VIDA REAL

                bit_length() ‚Üí seguran√ßa, criptografia

                to_bytes() ‚Üí arquivos, rede

                is_integer() ‚Üí valida√ß√£o de c√°lculo

                as_integer_ratio() ‚Üí precis√£o matem√°tica

                int(base) ‚Üí parsing de dados

                hex/bin ‚Üí debug de baixo n√≠vel

    =====================================================================

    strings e caracteres:

        - String √© uma sequ√™ncia de caracteres.

        - Em Python, string √© um objeto do tipo str, imut√°vel e Unicode.

        . Caractere ‚Üí unidade b√°sica (letra, n√∫mero, s√≠mbolo)

        . String ‚Üí v√°rios caracteres juntos

        . Python n√£o tem tipo char, s√≥ str

        . Cada caractere √© um Unicode code point

        CARACTERE vs STRING:

            . Em Python:

                letra = "a"
                palavra = "abc"

            Ambos s√£o str:

                type("a")      # str
                type("abc")    # str

            N√£o existe diferen√ßa de tipo entre caractere e string curta.

        EM PYTHON (codifica√ß√£o):

                texto = "cora√ß√£o üòÑ"

            . Isso √© str

            . J√° √© Unicode

            . N√£o precisa configurar nada

            Em Python 3, str √© Unicode por padr√£o.

        str COMO OBJETO:

            - str √© uma classe, e strings s√£o objetos.

                s = "Python"
            
                type(s)        # str
                isinstance(s, str)  # True

            - Por isso strings t√™m m√©todos.

        PROPRIEDADES IMPORTANTES DE str

            . Imutabilidade

                    s = "abc"
                    # s[0] = "x"  # erro

                . Strings n√£o podem ser alteradas
                . Qualquer ‚Äúmodifica√ß√£o‚Äù cria outra string

            . Index√°vel

                    s = "Python"
                    print(s[0])    # 'P'
                    print(s[-1])   # 'n'

            . Iter√°vel

                    for c in "abc":
                        print(c)

            . Comprimento

                    len("Python")  # 6

        M√âTODOS ESSENCIAIS DE str

            - Transforma√ß√£o

                . Converter tudo em min√∫scula:

                    s.lower()

                . Converter tudo em mai√∫scula:

                    s.upper()

                . Converter as primeiras letras em mai√∫sculas:

                    s.capitalize()

                . Converter apenas a primeira letra da string em mai√∫scula:

                    s.title()

            - Remo√ß√£o de espa√ßos:

                . Remover espa√ßos a direita e esquerda:

                    s.strip()

                . Remover espa√ßos esquerda apenas:

                    s.lstrip()

                . Remover espa√ßos a direita apenas:

                    s.rstrip()

            - Testes (retornam bool)

                s.isalpha()     # s√≥ letras
                s.isdigit()     # s√≥ n√∫meros
                s.isalnum()     # letras e n√∫meros
                s.isspace()     # s√≥ espa√ßos
                s.islower()     # se est√° em min√∫scula
                s.isupper()     # se est√° em mai√∫scula

            - Busca

                s.find("a")        # √≠ndice ou -1
                "a" in s           # True / False
                s.startswith("a")  # Se o in√≠cio cont√©m string 'a'. Se sim True sen√£o False
                s.endswith("a")    # Se o final cont√©m string 'a'. Se sim True sen√£o False

            - Substitui√ß√£o:

                s.replace("a", "x")

            - Quebra e jun√ß√£o:

                "1,2,3".split(",")  # Quebra
                "-".join(["a", "b", "c"])  # Une apenas listas do tipo string

        FUN√á√ïES RELACIONADAS A CARACTERES

            - C√≥digo Unicode:

                ord("a")   # 97
                ord("√ß")   # 231

            - Caractere pelo c√≥digo

                chr(97)    # 'a'
                chr(231)   # '√ß'

        SLICING (FATIAMENTO):

            - Slicing √© extrair partes de uma string usando √≠ndices.

            Sintaxe geral:

                texto[in√≠cio:fim:passo]

            . in√≠cio ‚Üí √≠ndice inicial (inclusivo)

            . fim ‚Üí √≠ndice final (exclusivo)

            . passo ‚Üí de quantos em quantos caracteres

            Todos s√£o opcionais.

            EXEMPLOS B√ÅSICOS:

                s = "Python"

                Primeiro caractere:

                    s[0]      # 'P'

                √öltimo caractere

                    s[-1]     # 'n'

                Do √≠ndice 1 ao 3

                    s[1:4]    # 'yth'

                Do come√ßo at√© o √≠ndice 3

                    s[:4]     # 'Pyth'

                Do √≠ndice 2 at√© o final

                    s[2:]     # 'thon'

            SLICING COM PASSO

                Pulando caracteres

                    s[::2]    # 'Pto'

                Invertendo string

                    s[::-1]   # 'nohtyP'

                Forma curta para invers√£o.

                - Slicing cria nova string

        CONCATENA√á√ÉO

            - Concatena√ß√£o √© juntar strings.

            . Com operador +

                a = "Py"
                b = "thon"

                c = a + b

            Resultado:

                Python

            - Isso cria uma nova string.

            . Com +=

                s = "Py"
                s += "thon"

            - Tamb√©m cria nova string (imut√°vel).

        CUIDADO COM CONCATENA√á√ÉO EM LOOP:

                texto = ""
                for c in "abc":
                    texto += c

            Ineficiente para strings grandes.

            Melhor:

                lista = []
                for c in "abc":
                    lista.append(c)

                texto = "".join(lista)

        CONCATENA√á√ÉO COM TIPOS DIFERENTES

            Erro:

                "Idade: " + 20

            Correto:

                "Idade: " + str(20)

            Melhor:

                f"Idade: {20}"

        CONCATENA√á√ÉO x INTERPOLA√á√ÉO

            | Forma      | Quando usar           |
            | ---------- | --------------------- |
            | `+`        | Strings simples       |
            | `+=`       | Acumular poucas vezes |
            | `f-string` | Formata√ß√£o            |
            | `.join()`  | Muitas strings        |

        EXEMPLOS CL√ÅSSICOS

            Extrair dom√≠nio de e-mail

                email = "user@gmail.com"
                dominio = email[email.index("@")+1:]

            Remover prefixo/sufixo

                texto = "###dados###"
                limpo = texto.strip("#")

        PEGADINHAS IMPORTANTES

            . Tamanho visual ‚â† tamanho real

                    len("üòÑ")  # 1

                Mas em bytes:

                    len("üòÑ".encode("utf-8"))  # 4
            
            . Compara√ß√£o depende de Unicode

                    "Z" < "a"   # True

                Mai√∫sculas v√™m antes no Unicode.

        FRASES-CHAVE PARA MEMORIZAR

            Python n√£o tem char
            Tudo √© Unicode
            UTF-8 √© codifica√ß√£o
            String √© objeto imut√°vel
            Caractere √© uma string de tamanho 1
            Slicing fatia
            Fim n√£o inclui
            Passo controla salto
            Concatena√ß√£o cria nova string

        Erros comuns:

            Achar que existe char em Python (n√£o existe). "a" ainda √© str.
            
            Confundir str com bytes (texto vs dados bin√°rios).
            
            Achar que string √© mut√°vel: tentar s[0] = "x" d√° erro.
            
            Esquecer que input() vem com texto, e n√£o n√∫mero.
            
            Esquecer de normalizar: comparar sem .lower() / .strip().
            
            Usar .strip() achando que remove ‚Äúno meio‚Äù (ele s√≥ remove nas pontas).
            
            Comparar texto com is em vez de ==.
            
            Achar que "Z" > "a" segue ‚Äúalfabeto humano‚Äù (√© ordem Unicode)
            
            Usar in achando que √© ‚Äúpalavra inteira‚Äù (√© substring).
            
            Usar .find() e esquecer que -1 significa ‚Äún√£o achou‚Äù.
            
            Usar .replace() achando que altera a string original (n√£o altera; 
            cria outra).

            Achar que o fim em s[inicio:fim] √© inclusivo (n√£o √©).

            Errar √≠ndice negativo (ex.: s[-0] √© igual a s[0]).
            
            Confundir s[::-1] (invers√£o) com ‚Äúordenar‚Äù.

        Dicas:

            - Normalize antes de comparar

            - Pense em √≠ndice, fatia, busca, separa√ß√£o (split) e jun√ß√£o (join).

            - Escolha a ferramenta certa

            - Slicing: fim n√£o entra

            - Teste com casos chatos

            - Sempre mostre com aspas no debug

    =====================================================================

    parsings:

        - Parsing √© o processo de analisar uma string e extrair partes com 
        significado.

        Ou seja:

            Entrada √© texto bruto

            Sa√≠da s√£o dados organizados (n√∫meros, campos, estruturas)

        - Parsing ‚â† valida√ß√£o
        - Parsing ‚â† formata√ß√£o
        - Parsing = interpretar

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre responda:

                1. Qual √© o formato esperado do texto?

                2. Onde est√£o os delimitadores? (@, ,, ;, :‚Ä¶)

                3. O texto √© fixo ou vari√°vel?

                4. O que eu preciso extrair?

            Parsing come√ßa no formato, n√£o no c√≥digo.

        TIPOS COMUNS DE PARSING

            1. Parsing por delimitador

                Quando o texto tem separadores claros.

                Exemplo:

                    nome;idade;cidade

                C√≥digo:

                    linha = "Ana;20;SP"
                    nome, idade, cidade = linha.split(";")

            2. Parsing por posi√ß√£o fixa

                Quando cada campo tem posi√ß√£o conhecida.

                Exemplo:

                    20240115BRSP

                C√≥digo:

                    data = texto[0:8]
                    pais = texto[8:10]
                    estado = texto[10:12]

                Muito usado em arquivos antigos (mainframe).

            3. Parsing por busca (find, index)

                Quando o delimitador pode variar de posi√ß√£o.

                Exemplo:

                    email = "user.name+tag@gmail.com"
                    pos = email.find("@")

                    usuario = email[:pos]
                    dominio = email[pos+1:]

            4. Parsing progressivo (passo a passo)

                Quando voc√™ ‚Äúconsome‚Äù a string.

                    texto = "10:20:30"
                    partes = texto.split(":")
                    h, m, s = map(int, partes)

        FERRAMENTAS DE PARSING EM STRINGS

            + .split()

                "1,2,3".split(",")

            + .find() / .index

                s.find("@")   # -1 se n√£o achar
                s.index("@")  # erro se n√£o achar

            + .startswith() / .endswith()

                email.endswith(".com")

            + Slicing

                texto[a:b]

            + .replace() (pr√©-processamento)

                valor = "1.234,56".replace(".", "").replace(",", ".")

        PARSING + CONVERS√ÉO DE TIPO:

            Parsing geralmente vem antes de converter tipo.

            Exemplo:

                valor = "R$ 12,50"
                valor = valor.replace("R$", "").strip()
                valor = float(valor.replace(",", "."))

            Ordem correta:

                limpar ‚Üí extrair ‚Üí converter

        PARSING ‚â† REGEX (IMPORTANTE)

            . Parsing simples ‚Üí split, find, slicing

            . Parsing complexo/padr√µes ‚Üí regex (re)

            N√£o use regex quando split resolve.

        ERROS COMUNS EM PARSING

            Assumir que o formato sempre vem certo

            N√£o tratar caso de erro (find retornar -1)

            Fazer parsing e convers√£o tudo junto

            N√£o normalizar antes (strip, lower)

            Usar regex para tudo (overkill)

        FRASES-CHAVE PARA MEMORIZAR

            Parsing √© leitura estruturada
            Delimitador manda
            Limpa antes de converter
            Texto primeiro, n√∫mero depois

        DICAS

            Desenhe o formato

            Ache os delimitadores

            Extraia em partes

            S√≥ depois converta tipo

            Teste entradas ‚Äúfeias‚Äù

    =====================================================================

    Blocos e escopos:

        - Bloco √© um agrupamento de c√≥digo.

        - Escopo define onde uma vari√°vel √© vis√≠vel.

        Em Python:

            Blocos s√£o definidos por indenta√ß√£o

            Escopo n√£o depende de {} (como em C/Java)

            Nem todo bloco cria um novo escopo

        BLOCOS EM PYTHON

            - Um bloco come√ßa ap√≥s : e √© definido pela indenta√ß√£o.

            Exemplos de blocos:

                if condicao:
                    ...

                for x in lista:
                    ...

                while condicao:
                    ...

                def func():
                    ...

            Indenta√ß√£o errada = erro ou bug l√≥gico.

        ESCOPO (VISIBILIDADE)

            Escopo responde:

                ‚ÄúEssa vari√°vel existe aqui?‚Äù

            Python segue a regra LEGB:

                1. local
                2. Enclosing
                3. global
                4. Built-in

            . ESCOPO LOCAL:

                - Vari√°veis criadas dentro de fun√ß√µes.

                    def f():
                        x = 10

                    # x n√£o existe aqui
  
                S√≥ existem dentro da fun√ß√£o.

            . ESCOPO GLOBAL

                - Vari√°veis criadas fora de fun√ß√µes.

                    x = 5

                    def f():
                        print(x)

                . Pode ler

                . N√£o pode atribuir sem a palavra resrvada global

            . global (cuidado)

                    x = 10

                    def f():
                        global x
                        x = 20

                . Altera o valor global

                . Pode causar bugs dif√≠ceis

            . nonlocal

                - Usado em fun√ß√µes dentro de fun√ß√µes.

                    def externa():
                        x = 10
                        def interna():
                            nonlocal x
                            x = 20

        BLOCO ‚â† ESCOPO (PEGADINHA CL√ÅSSICA)

            if, for, while N√ÉO criam escopo:

                if True:
                    y = 10

                print(y)  # funciona

            Diferente de C/Java.

            Fun√ß√µes criam escopo:

                def f():
                    z = 5

                print(z)  # erro

        SOMBREAMENTO (SHADOWING)

            - Vari√°vel local com mesmo nome de uma global.

                x = 10

                def f():
                    x = 5   # sombra

            Global continua existindo, mas ‚Äúescondida‚Äù dentro da fun√ß√£o.

        ERROS COMUNS

            Achar que if cria escopo

            Esquecer indenta√ß√£o

            Usar global sem necessidade

            Modificar global dentro de fun√ß√£o sem perceber

            Criar vari√°veis dentro de loop achando que ‚Äúmorrem‚Äù

        DICAS DE ATAQUE

            Sempre leia a indenta√ß√£o

            Pergunte: ‚Äúonde essa vari√°vel nasceu?‚Äù

            Prefira retornar valores a usar global

            Evite nomes iguais em escopos diferentes

            Use fun√ß√µes para isolar l√≥gica

        FRASES-CHAVE PARA MEMORIZAR

            Indenta√ß√£o manda
            Fun√ß√£o cria escopo
            Loop n√£o cria
            global √© perigoso
            Escopo evita bugs

        UM POUCO MAIS SOBRE LEGB:

            Quando o Python encontra um nome (x, print, len‚Ä¶), ele procura 
            nesta ordem exata:

                1. Local
                2. Enclosing
                3. Global
                4. Built-in

            Ele para no primeiro que encontrar.

            LOCAL (L):

                - Vari√°veis criadas dentro da fun√ß√£o atual.

                    def f():
                        x = 10
                        print(x)

                    f()

                . x existe s√≥ dentro de f

                . √â o primeiro lugar que o Python procura

                Fora da fun√ß√£o:

                    print(x)  # erro

                Local √© o escopo mais forte.

            ENCLOSING (E):

                - Vari√°veis da fun√ß√£o externa que envolve a fun√ß√£o atual.

                    def externa():
                        y = 20
                        def interna():
                            print(y)
                        interna()

                    externa()

                . y n√£o √© local de interna

                . Tamb√©m n√£o √© global

                . √â enclosing

                + nonlocal (controla o enclosing):

                    def externa():
                        y = 20
                        def interna():
                            nonlocal y
                            y = 30
                        interna()
                        print(y)  # 30

                . Sem nonlocal, voc√™ n√£o pode atribuir ao enclosing.

            GLOBAL (G):

                - Vari√°veis criadas fora de qualquer fun√ß√£o.

                    x = 5

                    def f():
                        print(x)

                    f()

                . Pode ler vari√°vel global

                . N√£o pode atribuir sem global

                + global (cuidado!):

                    x = 5

                    def f():
                        global x
                        x = 10

                . Altera o valor global

                . Pode causar bugs dif√≠ceis de rastrear

            BUILT-IN (B):

                - Nomes que j√° v√™m com o Python.

                Exemplos:

                    print
                    len
                    int
                    str
                    range

                C√≥digo:

                    print(len("abc"))  # 3

                . √öltimo lugar onde o Python procura.

                Sombreamento perigoso (shadowing):

                        len = 10
                        print(len("abc"))  # ERRO

                    . Voc√™ escondeu o len built-in.

            ORDEM REAL DE BUSCA (PASSO A PASSO)

                Quando o Python v√™:

                    print(x)

                Ele faz:

                    1. x existe no local?

                    2. N√£o? existe no enclosing?

                    3. N√£o? existe no global?

                    4. N√£o? existe no built-in?

                    5. N√£o? ‚Üí NameError

            EXEMPLO COMPLETO LEGB:

                    x = "global"

                    def externa():
                        x = "enclosing"
                        def interna():
                            x = "local"
                            print(x)  # Built-in
                        interna()

                    externa()

                Sa√≠da:

                    local

                Se voc√™ remover x = "local":

                    enclosing

                Se remover tamb√©m:

                    global

                Se n√£o existir global:

                    NameError

            ERROS COMUNS COM LEGB:

                Achar que if cria escopo

                Usar global sem perceber

                N√£o entender nonlocal

                Sombrear print, list, str

                Pensar que Python ‚Äúadivinha‚Äù escopo

            DICAS:

                Sempre pergunte: onde esse nome nasceu?

                Fun√ß√£o ‚Üí cria escopo

                Loop ‚Üí n√£o cria

                Prefira retorno a global

                Evite nomes iguais aos built-ins

            FRASE FINAL PRA MEMORIZAR:

                . Python procura nomes como uma cebola:

                . local ‚Üí enclosing ‚Üí global ‚Üí built-in

    =====================================================================

    Estruturas condicionais / tern√°rios:

        - Estruturas condicionais controlam o fluxo de execu√ß√£o do programa com 
        base em express√µes l√≥gicas.

        Formalmente:

            Avaliam uma condi√ß√£o booleana

            Executam um bloco entre alternativas poss√≠veis

            S√£o a base de decis√£o, ramifica√ß√£o e l√≥gica de neg√≥cio

        Sem condicionais, um programa √© apenas sequencial.

        if:

            - Executa um bloco se a condi√ß√£o for verdadeira.

            Sintaxe:

                if condi√ß√£o:
                    bloco

            Exemplo:

                idade = 18

                if idade >= 18:
                    print("Maior de idade")

                if True:  # SE TROCAR POR False N√ÉO IR√Å ENTRAR NO BLOCO
                    print("Sempre vai passar aqui")

            Caracter√≠sticas:

                . Condi√ß√£o deve resultar em verdade l√≥gico (truthy)

                . Se for falsa, o bloco √© ignorado

                . Pode existir sozinho

            Uso t√≠pico:

                valida√ß√£o

                checagem simples

                guarda de execu√ß√£o

        if if if ... (ifs independentes):

            - M√∫ltiplos if n√£o s√£o ligados entre si.

            Sintaxe:

                if A:
                    bloco
                if B:
                    bloco
                if C:
                    bloco

            Exemplo:

                x = 10

                if x > 0:
                    print("x √© positivo")

                if x % 2 == 0:
                    print("x √© par")

                if x >= 10:
                    print("x √© maior ou igual a 10")

            . Cada condi√ß√£o √© avaliada sempre

            . Mais de um bloco pode executar

            . N√£o √© escolha exclusiva

            Use quando condi√ß√µes s√£o independentes.

        if / elif:

            - Estrutura de escolha exclusiva.

            Sintaxe:

                if A:
                    bloco
                elif B:
                    bloco
                elif C:
                    bloco

            Exemplo:

                nota = 7.5

                if nota >= 8:
                    print("Nota alta")
                elif nota > 6 and nota < 8:
                    print("Nota na m√©dia")

            Caracter√≠sticas:

                . Avalia√ß√£o sequencial

                . Apenas um bloco executa

                . Para no primeiro verdadeiro

                . elif √© um acr√¥nimo a else if

                . elif depende exclusivamente de um if, ou seja, n√£o consegue 
                rodar sozinho

            Modela decis√£o hier√°rquica.

        if / else:

            - Escolha bin√°ria: ou isso, ou aquilo.

            Sintaxe:
            
                if A:
                    bloco
                else:
                    bloco

            Exemplo:

                nome = "Carro"

                if nome == "Carro":
                    print("Automotor de 4 eixos")
                else:
                    print("Outro objeto")
                
            . Garante execu√ß√£o de um dos dois blocos

            . Muito usado para valida√ß√£o

            . Um else depende exclusivamente de if, ou seja, n√£o pode rodar
            sozinho

        if / elif / else:

            - Forma mais comum de decis√£o completa.

            Sintaxe:

                if A:
                    bloco
                elif B:
                    bloco
                elif C:
                    bloco
                else:
                    bloco

            Exemplo:

                permissao = 0

                if permissao == 0:
                    print("Sem permiss√£o")
                elif permissao == 1:
                    print("Permissao total")
                else:
                    print("Fora do limite de permiss√£o")

            . Todas as possibilidades s√£o cobertas

            . else √© o caso residual

            . Estrutura fechada e previs√≠vel

            Ideal quando h√° categorias mutuamente exclusivas.

        if ANINHADO (if dentro de if):

            - Condi√ß√µes dependentes de condi√ß√µes anteriores.

            Sintaxe:

                if A:
                    if B:
                        ...

            Exemplo:

                nome = "Jo√£o"
                idade = 22

                if nome == "Jo√£o":

                    if idade >= 18:
                        print("√â de maior")
                    elif 15 <= idade < 18:
                        print("√â adolescente")
                    else:
                        if idade == 14:
                            print("T√™m 14 anos")
                        print("√â menos de idade")

                else:
                    print("Nome inv√°lido")

            PS: Nota que podemos aninhar todas as vers√µes anteriores se
            necess√°rio.

            Caracter√≠sticas:

                . Cria √°rvore de decis√£o

                . Pode aumentar complexidade rapidamente

                . Pode ser reescrito como elif em muitos casos

            Aninhamento profundo = alerta de design.

        IF TERN√ÅRIO (express√£o condicional)

            - Condicional como express√£o, n√£o como bloco.

            Forma geral:

                valor = X if condi√ß√£o else Y

            Exemplo:

                acesso_a_entrada = True
                pode_passar = True if acesso_a_entrada else False

            Caracter√≠sticas:

                Retorna um valor

                Mais conciso

                N√£o cria bloco

            Use para atribui√ß√µes simples, n√£o para l√≥gica complexa.

        IF TERN√ÅRIO ANINHADO

            - V√°rios tern√°rios encadeados.

            Forma geral:

                valor = A if c1 else B if c2 else C

            Exemplo:

                x = -3

                resultado = (  # () Serve nesse caso para linhar e deixar mais leg√≠vel
                    "positivo" if x > 0
                    else "zero" if x == 0
                    else "negativo"
                )

                print(resultado)

            Caracter√≠sticas:

                . Funciona

                . Legibilidade cai r√°pido

                . Deve ser usado com extremo cuidado

                Em geral, prefira if / elif / else.

        match (Python 3.10+)

            - Estrutura de pattern matching (equivalente moderno ao switch).

            Sintaxe:

                match valor:
                    case X:
                    case Y:
                    case _:

            Exemplo:

                opcao = input("Escolha uma op√ß√£o (1, 2, 3, a, b): ")

                match opcao:
                    case "1":
                        print("Op√ß√£o 1 selecionada")

                    case "2" | "3":
                        print("Op√ß√£o 2 ou 3 selecionada")

                    case x if x in ("a", "b", "c"):
                        print("Op√ß√£o de letra v√°lida (a, b ou c)")

                    case _:
                        print("Op√ß√£o inv√°lida")

            Caracter√≠sticas:

                . Compara√ß√£o estrutural

                . Melhor que if/elif para muitos casos fixos

                . _ √© o caso padr√£o (else)

                . Match s√≥ aceita condi√ß√µes l√≥gicas bit-wise, exemplo acima: |

                . Pode fazer verifica√ß√µes com ifs tern√°rios

            Excelente para:

                enums

                comandos

                protocolos

                parsing

        IFs MAL PROJETADOS (M√ÅS PR√ÅTICAS)

            . Condi√ß√µes longas e ileg√≠veis:

                if a and b or c and not d and e:

            . Aninhamento profundo:

                if A:
                    if B:
                        if C:
                            if D:

            . Repeti√ß√£o de condi√ß√£o:

                if x > 10:
                    ...
                elif x > 10 and y > 5:
                    ...

            . Uso excessivo de else:

                - else escondendo erro

                - l√≥gica impl√≠cita perigosa

        BOAS PR√ÅTICAS COM CONDICIONAIS:

            . Prefira retornos antecipados
            . Use elif em vez de aninhar
            . Quebre condi√ß√µes complexas em vari√°veis
            . Use par√™nteses para clareza
            . Cada if deve ter uma responsabilidade

        if + return (PADR√ÉO PROFISSIONAL EM FUN√á√ïES E M√âTODOS DE CLASSE)

            - Retornar cedo simplifica l√≥gica.

            Ruim:

                if cond:
                    resultado = X
                else:
                    resultado = Y
                return resultado

            Bom:

                if cond:
                    return X
                return Y

            Benef√≠cios:

                Menos indenta√ß√£o

                Fluxo mais claro

                C√≥digo mais leg√≠vel

            Early return √© padr√£o profissional.
        
        FRASES-CHAVE PARA MEMORIZAR

            if decide
            elif organiza
            else cobre o resto
            Tern√°rio √© express√£o
            match √© escolha estrutural
            Muitos ifs = sinal de design ruim

        ERROS COMUNS EM ESTRUTURAS CONDICIONAIS

            1) Confundir if independentes com if/elif

                    if x > 0:
                        ...
                    if x > 10:
                        ...

                PS: Ambos podem executar.

                Use elif quando a decis√£o for exclusiva.

            2) Aninhamento excessivo

                    if A:
                        if B:
                            if C:
                                if D:

                - C√≥digo dif√≠cil de ler e manter

                Correto: Reescreva com elif, and ou early return

            3) Condi√ß√µes longas e ileg√≠veis

                    if a and b or c and not d and e:

                - Alto risco de bug

                Correto: Quebre em vari√°veis intermedi√°rias

            4) else gen√©rico escondendo erro

                    if valido:
                        processa()
                    else:
                        processa_outra_coisa()

                PS: O else pode engolir casos inesperados

                Correto: Trate casos expl√≠citos

            5) Comparar booleanos explicitamente

                    if cond == True:

                - Desnecess√°rio

                Use apenas:
                
                    if cond:

            6) Tern√°rio complexo demais

                    x = a if c1 else b if c2 else d if c3 else e

                Legibilidade p√©ssima

                Correto: Use if/elif/else

            7) Repeti√ß√£o de condi√ß√£o

                    if x > 10:
                        ...
                    elif x > 10 and y > 5:

                - Redund√¢ncia

                Correto: Reorganize a l√≥gica

            8) match usado como if comum

                - Usar match para poucas condi√ß√µes simples

                Correto: Use quando h√° m√∫ltiplos padr√µes claros

            9) Usar is para comparar valor

                    if x is 10:

                - Errado
                
                Correto: if x == 10:

            10) N√£o entender truthy/falsy

                    if valor:

                PS: "0" √© True

            11) Condi√ß√µes impl√≠citas demais

                    if a and b or c:

                - Amb√≠guo

                Correto: Use par√™nteses ou vari√°veis intermedi√°rias

            12) Usar in achando que √© igualdade

                    if "a" in "ana":

                PS: Isso √© substring, n√£o palavra inteira

        DICAS:

            - Decis√£o √© exclusiva ou independente?

            - Liste os casos poss√≠veis antes de codar

            - Use early return sempre que poss√≠vel

            - Prefira clareza a concis√£o

            - Se tem muitos elif, pense em match.

            - Se o if cresce demais, √© sinal de design ruim

            - Leia a condi√ß√£o em voz alta

            - Pergunte: que objeto est√° sendo avaliado?

            - Qual operador est√° sendo usado?

            - Esse operador retorna bool ou objeto?

            - Esse objeto √© truthy ou falsy?

            - Preciso comparar valor (==) ou identidade (is)?

            - Preciso normalizar antes (strip, lower)?

        OPERADORES E OBJETOS EM CONDI√á√ïES:

            - Em Python, condi√ß√µes avaliam objetos, n√£o apenas valores booleanos.

            Qualquer express√£o em um if passa por:

                bool(express√£o)

            Por isso, objetos t√™m comportamento condicional.

            1. Operadores Relacionais:

                - Usados para comparar valores.

                    if idade >= 18:
                    if nome == "Ana":

                Resultado: bool

            2. Operadores L√≥gicos:

                - Combinam condi√ß√µes.

                    if idade >= 18 and tem_doc:

                    if n1 * n2 == n1 + n2 or is_prime():

                    if not (valor_zerado):

                Retornam operandos, mas em if s√£o avaliados como booleanos.

            3. Operadores de Pertin√™ncia:

                - Verificam pertencimento.

                    if "@" in email:

                    if nome not in lista:

                Chamam internamente m√©todos como __contains__.

            4. Operadores de Identidade:

                - Verificam identidade de objeto, n√£o valor.

                    if x is None:

                Usado para sentinelas, n√£o para compara√ß√£o de valor.

            OBJETOS EM CONDI√á√ïES (TRUTHY / FALSY):

                Objetos Falsy (avaliam como False):

                    False
                    None
                    0, 0.0
                    ""
                    [], {}, set()

                    EX:

                        if lista:
                            ...

                    S√≥ entra se a lista n√£o estiver vazia.
            
                Objetos Truthy:

                    Todo objeto que n√£o √© falsy.

                    EX:

                        if "abc":
                        if [1]:
                        if 10:

                    Conte√∫do n√£o importa ‚Äî s√≥ o estado l√≥gico.

            M√âTODOS DE OBJETOS EM CONDI√á√ïES:

                Strings:

                    if nome.strip():
                    if texto.isdigit():

                Listas:

                    if lista:

                Dicion√°rios:

                    if "chave" in d:

                Condi√ß√µes frequentemente usam m√©todos do objeto, n√£o operadores 
                puros.

            OPERADORES CHAMAM M√âTODOS (IMPORTANTE)

                Quando voc√™ escreve:

                    a == b

                Python executa:

                    a.__eq__(b)

                Isso significa:

                    . Objetos controlam como s√£o comparados

                    . Classes podem redefinir comportamento condicional

                Isso √© base de polimorfismo.

            CONDI√á√ïES COM FUN√á√ïES (RETORNO)

                    if func():

                . A fun√ß√£o √© chamada

                . O retorno √© convertido com bool()

                . Decide o fluxo

                Fun√ß√µes devem retornar algo sem√¢ntico para condi√ß√µes.


    =====================================================================

    Estruturas de repeti√ß√£o:

        - Estruturas de repeti√ß√£o executam um bloco de c√≥digo m√∫ltiplas vezes 
        enquanto uma condi√ß√£o for satisfeita ou enquanto houver elementos a 
        percorrer.

        Formalmente:

            Reduzem repeti√ß√£o de c√≥digo

            Modelam processos iterativos

            S√£o base de algoritmos, busca, acumula√ß√£o e simula√ß√£o

        while:

            - Repeti√ß√£o controlada por condi√ß√£o

            - Executa o bloco enquanto a condi√ß√£o for verdadeira.

            EX:

                while condi√ß√£o:
                    bloco

            Exemplo classico:

                cont = 0

                while cont < 10:
                    print(cont)
                    cont += 1

            . Leia-se, enquanto a vari√°vel chamada cont for menor que 10
            . Mostre cont
            . Incremente + 1 em cont

            Caracter√≠sticas:

                Teste ocorre antes da execu√ß√£o

                Pode executar zero ou mais vezes

                Ideal quando n√£o se sabe o n√∫mero de itera√ß√µes

            Iter√°veis com while:

                Uso cl√°ssico com √≠ndice:

                        i = 0
                        while i < len(lista):
                            lista[i]
                            i += 1

                    Exige:

                        controle manual de √≠ndice

                        incremento expl√≠cito

                        maior chance de erro

                Uso de operadores com while:

                    Relacionais: controlam a condi√ß√£o

                    Aritm√©ticos: contadores

                    L√≥gicos: m√∫ltiplas condi√ß√µes

                        while i < 10 and ativo:

            while aninhado:

                - Um while dentro de outro.

                EX:
                    
                    while A:
                        while B:

                C√≥digo:

                    linha = 0

                    while linha < 3:
                        coluna = 0

                        while coluna < 4:
                            print(f"linha={linha}, coluna={coluna}")
                            coluna += 1

                        linha += 1


                    i = 1

                    while i <= 3:
                        j = 1

                        while j <= 5:
                            print(f"{i} x {j} = {i * j}")
                            j += 1

                        print("-----")
                        i += 1

                . Modela repeti√ß√µes bidimensionais

                . Usado em matrizes, tabelas, for√ßa bruta

                . Risco alto de complexidade O(n¬≤)

            while True:

                - Loop incondicional.

                EX:

                    while True:
                        if condicao_de_saida:
                            break   # Para o loop

                Usado quando:

                    . a condi√ß√£o de parada √© interna

                    . leitura cont√≠nua

                    . menus

                    . eventos

                Sempre deve existir break.

            Loop infinito:

                    while True:
                        pass

                . Pode travar o programa

                . √Äs vezes √© intencional (servidores, sistemas reativos)

                . Em scripts comuns ‚Üí bug

            Fun√ß√µes especiais no while:

                break ‚Üí sai do loop

                continue ‚Üí pula para pr√≥xima itera√ß√£o

                pass ‚Üí n√£o faz nada (placeholder)

            while else:

                Executa o else se o loop terminar sem break.

                EX:

                    while cond:
                        ...
                        if erro:
                            break
                    else:
                        # terminou normalmente

                Pouco usado, mas poderoso para:

                    . busca

                    . valida√ß√£o

                    . detec√ß√£o de falha

        for:

            - Repeti√ß√£o controlada por iter√°vel

            - Percorre cada elemento de um iter√°vel.

            Sintaxe:

                for elemento in iter√°vel:
                    bloco

            Caracter√≠sticas:

                Mais seguro que while

                N√£o exige √≠ndice manual

                Preferido em Python

            Iter√°veis com for:

                Exemplos:

                    string
                    lista
                    tupla
                    set
                    dict
                    range

                EX Sintaxe:

                    for c in "Python":

                . range:

                    - Gerador de sequ√™ncia num√©rica.

                        range(inicio, fim, passo)

                    . fim √© exclusivo

                    . Muito usado para contagem

                        for i in range(10):

                . Uso de operadores com for:

                        soma = 0
                        for x in range(10):
                            soma += x

                    Modelo cl√°ssico: acumulador

                . Aplica√ß√µes cl√°ssicas de for:

                    1. Contador

                            contador = 0
                            for _ in range(10):
                                contador += 1

                        . _: significa, n√£o chamar nada, apenas executar

                    2. Acumulador

                            total = 0
                            for n in lista:
                                total += n

                    3. Busca

                            for x in lista:
                                if x == alvo:
                                    break

                    4. Filtragem

                            for x in lista:
                                if x > 0:

                    5. Transforma√ß√£o

                            for x in lista:
                                novo = x * 2

            for aninhado:

                Sintaxe:

                    for i in range(n):
                        for j in range(m):

                EX:

                    for i in range(1, 5):
                        for j in range(1, 5):
                            if i != j:
                                print(f"({i}, {j})")


                    letras = ["A", "B", "C"]
                    for l1 in letras:
                        for l2 in letras:
                            if l1 != l2:
                                print(l1 + l2)

                . Matrizes

                . Tabelas

                . Combina√ß√µes

                . Complexidade cresce r√°pido

            Fun√ß√µes especiais no for

                break
                continue
                pass
                enumerate
                zip

                Exemplo:

                    for i, valor in enumerate(lista):

            for else:

                - Executa o else se o loop terminar sem break.

                Sintaxe:

                    for x in lista:
                        if x == alvo:
                            break
                    else:
                        # n√£o encontrou

                Muito usado em busca.

            ERROS COMUNS EM LOOPS:

                Esquecer incremento no while

                Loop infinito acidental

                Usar while quando for √© melhor

                Aninhamento excessivo

                Misturar l√≥gica demais dentro do loop

                N√£o usar break quando deveria

                Usar while sem atualizar estado

                Tentar controlar √≠ndice dentro de for

                Misturar responsabilidades (contador + condi√ß√£o confusa)

                Off-by-one (< vs <=)

                Incrementar fora do lugar correto

            DICAS:

                Sabe quantas vezes? ‚Üí for
                N√£o sabe quando para? ‚Üí while
                Percorre cole√ß√£o? ‚Üí for
                Menu / evento / leitura cont√≠nua? ‚Üí while True
                Busca? ‚Üí for + break + else
                Muito aninhamento? ‚Üí repense o algoritmo
                Pergunte: quem controla o passo? voc√™ ‚Üí while | Python ‚Üí for
                Se precisar decrementar, pense em range com passo negativo
                Se tem contador manual em for, talvez precise de enumerate
                Se o loop n√£o termina, procure o incremento
                Atualiza√ß√£o do estado deve ser √≥bvia ao ler o c√≥digo

            FRASES-CHAVE PARA MEMORIZAR:

                while depende de condi√ß√£o
                for depende de cole√ß√£o
                break encerra
                continue pula
                else s√≥ roda sem break
                loop ruim = design ruim
                while exige atualiza√ß√£o expl√≠cita
                for itera sozinho
                Incremento move o estado
                Sem incremento, n√£o h√° progresso


        INCREMENTO E DECREMENTO EM LOOPS:

            - Como o estado do loop evolui

            - Incrementar/decrementar √© alterar o estado que controla a repeti√ß√£o.
            
            - Sem isso, o loop n√£o progride ‚Üí loop infinito.

            Em termos formais:

                Loop = condi√ß√£o + estado + atualiza√ß√£o

                Incremento/decremento = atualiza√ß√£o do estado

            Papel no while:

                - No while, VOC√ä √© respons√°vel por atualizar a vari√°vel de 
                controle.

                Estrutura conceitual:

                    estado_inicial
                    while condi√ß√£o(estado):
                        bloco
                        atualiza√ß√£o_do_estado

                . Incremento cl√°ssico:

                        i = 0
                        while i < 5:
                            print(i)
                            i += 1

                    Leitura l√≥gica:

                        i come√ßa em 0
                        enquanto i < 5
                        imprime
                        incrementa i
                        volta para testar

                    Sem i += 1 ‚Üí loop infinito.

                . Decremento cl√°ssico:

                        i = 5
                        while i > 0:
                            print(i)
                            i -= 1

                    Leitura:

                        contador regressivo
                        usado em temporizadores, contagem reversa

                Incremento/decremento com operadores:

                        while x < 10:
                            x = x + 2      # incremento de 2

                        while saldo > 0:
                            saldo -= gasto
                    
                    Incremento n√£o precisa ser de 1.

                Exemplo cl√°ssico de bug:

                    i = 0
                    while i < 10:
                        print(i)
                    # i nunca muda

            while True + incremento

                    i = 0
                    while True:
                        print(i)
                        i += 1
                        if i == 5:
                            break

                Aqui o incremento controla a sa√≠da, n√£o a condi√ß√£o do while.

        INCREMENTO / DECREMENTO NO for:

            . Conceito fundamental

                No for, o incremento √© impl√≠cito.

            Voc√™ n√£o controla o √≠ndice manualmente.

                for i in range(5):
                    print(i)

            Internamente:

                . Python pega o pr√≥ximo valor do iter√°vel

                . N√£o existe i += 1 vis√≠vel

                N√£o tente controlar i manualmente dentro do for.

            Incremento com range:

                    for i in range(0, 10, 2):
                        print(i)

                Incremento de 2:

                    0 ‚Üí 2 ‚Üí 4 ‚Üí 6 ‚Üí 8

            Decremento com range:

                    for i in range(5, 0, -1):
                        print(i)

                . Passo negativo ‚Üí decremento.

            Acumuladores (incremento indireto)

                Muito comum em for:

                        soma = 0
                        for x in range(10):
                            soma += x

                    Aqui:

                        x muda automaticamente

                        soma √© incrementada manualmente

                    Dois tipos de ‚Äúincremento‚Äù coexistem:

                        do iterador

                        do acumulador

            N√ÉO FA√áA ISSO EM for

                    for i in range(10):
                        i += 1  # in√∫til

                . Isso n√£o altera o loop

                . S√≥ muda a vari√°vel local naquela itera√ß√£o

        QUANDO USAR CADA LOOP:

            Use for quando:

                Voc√™ tem uma cole√ß√£o
                Voc√™ sabe quantas vezes vai iterar
                Est√° percorrendo lista, string, dicion√°rio
                Est√° acumulando valores
                Est√° fazendo busca simples

                - Em Python, for √© a escolha padr√£o.

            Use while quando:

                A condi√ß√£o de parada √© din√¢mica
                Voc√™ n√£o sabe quantas itera√ß√µes haver√°
                O loop depende de eventos, entradas ou estados
                Menus interativos
                Leitura at√© erro/sentinela

                - while √© mais poderoso ‚Äî e mais perigoso.

        LOOPS COM CONDICIONAIS:

            - Loop sem if quase n√£o decide nada.

            - if fora de loop quase n√£o escala.

            O poder est√° na combina√ß√£o.

            1) Condicional controla perman√™ncia no loop

                while:
                
                        while x < 10:

                    Aqui:

                        Condi√ß√£o mant√©m ou encerra o loop

            2) Condicional controla sa√≠da antecipada (break)

                    for x in lista:
                        if x == alvo:
                            break

                Busca eficiente: para quando encontra.
            
            3) Condicional controla pulo (continue)

                    for x in lista:
                        if x < 0:
                            continue
                        processa(x)

                Filtragem elegante.

            4) Condicional controla processamento

                    for x in lista:
                        if x % 2 == 0:
                            pares += 1
    
                L√≥gica de neg√≥cio dentro do loop.

            5) Condicional decide acumula√ß√£o

                    total = 0
                    for x in lista:
                        if x > 0:
                            total += x

                S√≥ acumula quando faz sentido.

            6) Condicional controla finaliza√ß√£o (for/while else)

                for x in lista:
                    if x == alvo:
                        break
                else:
                    print("N√£o encontrado")

            ERROS CL√ÅSSICOS (LOOP + IF):

                1) Condi√ß√£o errada ‚Üí loop infinito

                        while i < 10:
                            if i == 5:
                                pass
                
                2) if no lugar errado

                        if x > 0:
                            for x in lista:

                    (geralmente o if deveria estar dentro)

                3) break fora do contexto correto

                    sai do loop errado
                    encerra cedo demais

                4) continue pulando atualiza√ß√£o

                        while i < 10:
                            if i == 5:
                                continue
                            i += 1

                    Loop infinito (i nunca muda quando i == 5)

                5) Misturar l√≥gica demais dentro do loop

                    loop vira ‚Äúbola de lama‚Äù
                    dif√≠cil de provar correto

            BOAS PR√ÅTICAS (LOOPS + IF)

                . Prefira for a while
                . Condi√ß√£o de parada clara
                . Atualiza√ß√£o do estado sempre vis√≠vel
                . Use break para encurtar busca
                . Use continue para filtrar
                . Use else para sucesso/falha
                . Se ficou complexo ‚Üí extraia fun√ß√£o

    =====================================================================

    Itera√ß√µes e Iter√°veis:

        - Itera√ß√£o √© o processo de percorrer elementos um a um.
        
        - Iter√°vel √© algo que pode ser percorrido.
        
        - Iterador √© quem faz a itera√ß√£o acontecer.

        Em Python:

            for n√£o percorre diretamente

            Ele usa iteradores

            Isso √© um modelo formal e poderoso

        ITERA√á√ÉO:

            Iterar significa executar um processo repetidamente, avan√ßando 
            passo a passo em uma sequ√™ncia de dados.

            Exemplos de itera√ß√£o:

                . Percorrer uma lista

                . Ler caracteres de uma string

                . Consumir valores de um gerador

                . Avan√ßar em um range
            
            Itera√ß√£o ‚â† repeti√ß√£o cega

            Itera√ß√£o envolve estado + avan√ßo + t√©rmino

        ITER√ÅVEL (Iterable):

            Um iter√°vel √© um objeto que pode fornecer um iterador.

            Formalmente:

                iter√°vel ‚Üí pode ser passado para iter()

            Exemplos de iter√°veis:

                str

                list

                tuple

                set

                dict

                range

                arquivos

                geradores

                    iter("abc")
                    iter([1, 2, 3])

                - Se iter(obj) funciona ‚Üí √© iter√°vel.

            Iter√°vel N√ÉO percorre sozinho:

                    lista = [1, 2, 3]

                . A lista n√£o anda

                . Ela apenas permite ser percorrida

                Quem anda √© o iterador.

        ITERADOR (Iterator):

            - Um iterador √© o objeto que mant√©m o estado da itera√ß√£o.

            Formalmente, um iterador:

                Possui m√©todo __next__()

                Lembra onde parou

                Lan√ßa StopIteration quando acaba

                EX:

                    it = iter([1, 2, 3])

                    next(it)  # 1
                    next(it)  # 2
                    next(it)  # 3
                    next(it)  # StopIteration

                Iterador √© consum√≠vel.

        Iterador ‚â† Iter√°vel (diferen√ßa crucial):

            | Caracter√≠stica      | Iter√°vel | Iterador |
            | ------------------- | -------- | -------- |
            | Pode gerar iterador | Sim      | N√£o      |
            | Mant√©m estado       | N√£o      | Sim      |
            | Pode ser reiniciado | Sim      | N√£o      |
            | Possui `__next__`   | N√£o      | Sim      |

            Um iterador geralmente n√£o pode ser reutilizado.
        
        COMO O for FUNCIONA (POR DENTRO):

            Quando voc√™ escreve:

                for x in lista:
                    ...

            O Python faz (conceitualmente):

                it = iter(lista)
                while True:
                    try:
                        x = next(it)
                    except StopIteration:
                        break
                    ...

            O for √© um while com iterador.

            Isso √© MUITO importante.

        ITERA√á√ÉO EM DIFERENTES TIPOS:

            . String

                    for c in "abc":

                Itera caractere por caractere.

            . Lista

                    for chave in d:

                Itera elemento por elemento.

            . Dicion√°rio

                    for chave in d:

                Itera chaves por padr√£o.

                    for k, v in d.items():

            . Range

                    for i in range(5):

                range √© iter√°vel pregui√ßoso, n√£o lista.

        ITERADORES S√ÉO ESTADO + PROGRESSO

            Exemplo de problema comum:

                it = iter([1, 2, 3])

                for x in it:
                    print(x)

                for x in it:
                    print(x)  # n√£o imprime nada

            O iterador foi consumido.

        FUN√á√ïES RELACIONADAS √Ä ITERA√á√ÉO

            . iter()

                Cria um iterador:

                    iter(obj)

            . next()

                Avan√ßa o iterador:

                    next(it)

            . enumerate()

                Itera com √≠ndice:

                    for i, v in enumerate(lista):

            . zip()

                Itera em paralelo:

                    for a, b in zip(lista1, lista2):

            . any() / all()

                Consomem iter√°veis:

                    any(x > 0 for x in lista)
                    all(x > 0 for x in lista)

        ERROS COMUNS

            . Confundir iter√°vel com iterador
            . Tentar reutilizar iterador consumido
            . Converter tudo para lista sem necessidade
            . Usar √≠ndice quando o for j√° resolve
            . Alterar cole√ß√£o enquanto itera

        DICAS:

            . Pergunte: isso √© iter√°vel ou iterador?
            . Preciso percorrer mais de uma vez? ‚Üí use iter√°vel
            . Quero economizar mem√≥ria? ‚Üí use iterador
            . Quero simplicidade? ‚Üí use for
            . Quero controle fino? ‚Üí use iter + next

        FRASES-CHAVE PARA MEMORIZAR

            Iter√°vel permite
            Iterador percorre
            for consome iterador
            Iterador tem estado
            StopIteration encerra

    =====================================================================

    Fun√ß√µes e lambdas:

        - Fun√ß√£o √© uma unidade de comportamento reutiliz√°vel, que recebe entrada, 
        processa e pode produzir sa√≠da.

        Formalmente:

            . Encapsula l√≥gica
            
            . Reduz repeti√ß√£o
            
            . Controla fluxo
            
            . Cria abstra√ß√£o

        Fun√ß√µes simples:

                def f():
                    bloco

            . N√£o recebe par√¢metros

            . Pode ou n√£o retornar valor

            . Executa uma tarefa espec√≠fica

        Fun√ß√µes com par√¢metros e sem par√¢metros:

            Sem par√¢metros

                def mostrar_menu():

            Com par√¢metros
            
                def soma(a, b):

            Par√¢metros s√£o entradas expl√≠citas do comportamento

        Fun√ß√µes com par√¢metros definidos (default):

                def saudacao(nome="Usu√°rio"):

            Permitem chamadas flex√≠veis

            Devem vir ap√≥s par√¢metros obrigat√≥rios

            Usar defaults reduz quantidade de par√¢metros.
        
        NORMA DE C√ìDIGO LIMPO:

            - Quanto menos par√¢metros, melhor.

            0‚Äì2 ‚Üí ideal

            3 ‚Üí aceit√°vel

            4+ ‚Üí sinal de design ruim

            Muitos par√¢metros indicam:

                . fun√ß√£o fazendo coisas demais

                . falta de encapsulamento

                . necessidade de objeto/dict

        Escopo em Python ‚Äî regra LEGB:

            - Python procura vari√°veis nesta ordem como vimos antes:

                L ‚Üí Local
                E ‚Üí Enclosing
                G ‚Üí Global
                B ‚Üí Built-in

                Isso se chama regra LEGB.

            1. Local (L) ‚Äî dentro da fun√ß√£o:

                    def f():
                        x = 10   # local
                        print(x)

                    f()

                - S√≥ existe dentro da fun√ß√£o

                - N√£o pode ser acessada fora

            2. Enclosing (E) ‚Äî fun√ß√£o dentro de fun√ß√£o:

                    def externa():
                        x = 20  # enclosing

                        def interna():
                            print(x)  # acessa enclosing

                        interna()

                    externa()

                - x n√£o √© local da interna, mas est√° no escopo envolvente 
                (enclosing).

            3. Global (G) ‚Äî topo do c√≥digo (arquivo)

                    x = 30  # global

                    def f():
                        print(x)  # l√™ global

                    f()

                - Fun√ß√µes podem ler vari√°veis globais
                
                - N√£o podem alterar sem global

            4. Built-in (B) ‚Äî nomes do Python

                    print(len([1, 2, 3]))

                . len, print, sum, int etc.

                PS: N√£o sobrescreva isso (p√©ssima ideia). Cuidado com
                sombreamento.

            Como usar vari√°vel do topo (global) dentro de fun√ß√£o:

                Apenas ler ‚Üí funciona direto:

                    x = 5

                    def f():
                        print(x)

                    f()

                Alterar sem global ‚Üí erro

                    x = 5

                    def f():
                        x = x + 1  # UnboundLocalError

            Alterar usando global:

                    x = 5

                    def f():
                        global x
                        x += 1

                    f()
                    print(x)  # 6

                global diz:

                    ‚Äúessa vari√°vel n√£o √© local, use a global‚Äù

            nonlocal ‚Äî quando existe fun√ß√£o dentro de fun√ß√£o:

                Situa√ß√£o:

                    vari√°vel n√£o √© local

                    n√£o √© global

                    est√° na fun√ß√£o externa

                C√≥digo:

                    def externa():
                        x = 10

                        def interna():
                            nonlocal x
                            x += 1

                        interna()
                        print(x)

                    externa()

                Sem nonlocal, isso daria erro.

            - global ‚Üí arquivo inteiro

            - nonlocal ‚Üí fun√ß√£o imediatamente externa

            Fun√ß√£o deve receber dados por par√¢metro e devolver por retorno.
            global e nonlocal s√£o exce√ß√µes, n√£o regra.

        COMPORTAMENTO E FLUXO:

            Fun√ß√µes:

                Criam fronteira de execu√ß√£o

                Controlam in√≠cio, meio e fim

                Facilitam racioc√≠nio local

            O fluxo entra, executa, retorna.

        return:

            - return encerra a fun√ß√£o e devolve um valor.

            Sintaxe:

                return valor

            . Pode haver v√°rios return

            . Usado para controle de fluxo

        return vs print (CRUCIAL):

            | `return`      | `print`          |
            | ------------- | ---------------- |
            | devolve valor | mostra na tela   |
            | afeta fluxo   | efeito colateral |
            | test√°vel      | n√£o test√°vel     |
            | reutiliz√°vel  | n√£o reutiliz√°vel |

            - Fun√ß√µes devem retornar, n√£o imprimir.

        Fun√ß√µes com loops e condicionais:

                def soma_positivos(lista):
                    total = 0
                    for x in lista:
                        if x > 0:
                            total += x
                    return total

            - Fun√ß√£o = comportamento

            - Loop = repeti√ß√£o

            - If = decis√£o

        Fun√ß√µes compostas:

            - Fun√ß√µes que chamam outras fun√ß√µes.

            Ex:

                    def processar():
                        validar()
                        calcular()
                        salvar()

                - Base da arquitetura de software.

        Fun√ß√µes aninhadas:

                def externa():
                    def interna():
                        ...

            . Escopo enclosing

            . Usadas para encapsular l√≥gica auxiliar

        FUN√á√ïES COMO OBJETO:

            - Em Python, fun√ß√µes s√£o objetos de primeira classe.

            Isso significa:

                podem ser atribu√≠das a vari√°veis

                passadas como argumento

                retornadas por outras fun√ß√µes

            Ex:

                f = soma

        CLOSURES:

            Closure = fun√ß√£o + ambiente capturado.

            EX:

                def externa(x):
                    def interna():
                        return x
                    return interna

            - x permanece vivo mesmo ap√≥s externa terminar.

            Usos:

                configura√ß√£o

                encapsulamento

                estado privado

        CURRYING:

            - Transformar fun√ß√£o de m√∫ltiplos par√¢metros em fun√ß√µes parciais.

            EX:

                def soma(a):
                    def soma_b(b):
                        return a + b
                    return soma_b

            Muito usado em programa√ß√£o funcional.

        DECORADORES:

            - Fun√ß√£o que envolve outra fun√ß√£o para modificar comportamento.

            EX:

                @decorador
                def f():

            Conceito:

                fun√ß√£o recebe fun√ß√£o
                retorna nova fun√ß√£o

            Usos:

                logging
                autentica√ß√£o
                cache
                valida√ß√£o

            Decoradores = aplica√ß√£o pr√°tica de closures.

        FUN√á√ïES COMO CALLBACKS:

            - Callback √© uma fun√ß√£o passada como argumento para ser chamada 
            depois.

            Ou seja:

                Voc√™ n√£o executa a fun√ß√£o agora

                Voc√™ entrega o comportamento

                Quem chama decide quando executar

            Invers√£o de controle.

            Pensamento: ‚ÄúN√£o me diga como fazer, diga o que fazer quando algo 
            acontecer.‚Äù

            Exemplo conceitual:

                def processar(valor, acao):
                    return acao(valor)

                def dobrar(x):
                    return x * 2

                processar(10, dobrar)

            dobrar √© callback.

        FUN√á√ïES COMO ESTRAT√âGIAS (Strategy Pattern):

            - Estrat√©gia √© trocar o comportamento sem mudar o c√≥digo que usa.

            Voc√™ tem:

                uma interface de comportamento

                v√°rias implementa√ß√µes

            √â um padr√£o cl√°ssico de design.

            Pensamento: ‚ÄúO algoritmo √© o mesmo, o comportamento muda.‚Äù

            Exemplo conceitual:

                def ordenar(lista, estrategia):
                    return estrategia(lista)

                def crescente(l):
                    return sorted(l)

                def decrescente(l):
                    return sorted(l, reverse=True)

            A estrat√©gia define como ordenar.

            Quando usar:

                regras de neg√≥cio vari√°veis

                c√°lculos diferentes

                pol√≠ticas (pre√ßo, desconto, imposto)

                valida√ß√µes alternativas

        DISPATCH POR FUN√á√ÉO:

            - Dispatch √© escolher qual fun√ß√£o executar com base em uma chave.

            Em vez de:

                if cmd == "add":
                elif cmd == "remove":
                elif cmd == "list":

            Voc√™ usa:

                fun√ß√µes

                mapeamento direto

            Remove condicionais desnecess√°rios.

            Pensamento: ‚ÄúDados escolhem comportamento.‚Äù

            Exemplo conceitual:

                def add():
                    ...

                def remove():
                    ...

                def listar():
                    ...

                acoes = {
                    "add": add,
                    "remove": remove,
                    "list": listar
                }

                acoes[cmd]()

            Isso √© dispatch por fun√ß√£o.

        FUN√á√ïES GERADORAS (yield):

            - Produzem valores sob demanda.

            EX:

                def gerador():
                    yield valor

            . Retornam iterador

            . Mant√™m estado interno

            . Muito eficientes em mem√≥ria

            yield pausa a fun√ß√£o.

        *args e **kwargs:

            . *args

                - argumentos posicionais vari√°veis

                    def f(*args):

            . **kwargs

                - argumentos nomeados vari√°veis

                    def f(**kwargs):

            Use com modera√ß√£o.

        LAMBDAS (lambda):

            - Lambda √© uma fun√ß√£o an√¥nima de express√£o √∫nica.

            - Lambda n√£o substitui fun√ß√£o.

            - Lambda remove ru√≠do quando o comportamento √© simples.

            Sintaxe:

                lambda x: x + 1

            COMPORTAMENTO E FLUXO

                . Executa express√£o

                . Retorna valor automaticamente

                . N√£o tem return expl√≠cito

                . N√£o tem bloco

            Lambda com par√¢metros e sem par√¢metros:

                lambda: 10
                lambda x: x * 2
                lambda x, y: x + y

            NORMA DE C√ìDIGO LIMPO (LAMBDA)

                - Se n√£o cabe em uma linha clara, n√£o √© lambda.

                Lambdas complexas s√£o m√° pr√°tica.

            Lambda com par√¢metros definidos (default):

                lambda x=10: x * 2

            Lambda key (uso mais comum):

                    sorted(lista, key=lambda x: x.valor)

                - Essencial para ordena√ß√£o e agrupamento.

            Lambda com condicionais:

                    lambda x: x if x > 0 else 0

                - Forma tern√°ria apenas.

                - N√£o existe loop em lambda. Se precisar de loop ‚Üí use def.

            Lambda funcional:

                Usadas com:

                    map
                    filter
                    sorted
                    min, max

                EX:

                    map(lambda x: x*2, lista)

            FUN√á√ïES INLINE:

                - Fun√ß√£o inline √© um comportamento definido no ponto de uso,
                sem nome.

                EX:

                    sorted(lista, key=lambda x: x.idade)

                . N√£o merece um def

                . Usada uma √∫nica vez

                . Express√£o simples

                Lambda = fun√ß√£o inline por natureza.

                PS: Se voc√™ precisa pensar para ler ‚Üí n√£o √© inline.

            ESTRAT√âGIAS R√ÅPIDAS:

                - Estrat√©gia r√°pida √© trocar comportamento sem criar v√°rias 
                fun√ß√µes nomeadas.

                    EX:

                        operacao = lambda a, b: a + b

                    Depois:

                        operacao = lambda a, b: a * b

                Estrat√©gia definida no local.

            CALLBACKS SIMPLES:

                - Callback simples √© um comportamento pequeno passado para ser 
                executado depois.

                EX:

                    processar(lista, lambda x: x > 0)

                Mental: ‚ÄúQuando isso acontecer, fa√ßa isso.‚Äù

                Exemplo cl√°ssico:

                    filter(lambda x: x % 2 == 0, lista)

            ADAPTA√á√ÉO DE INTERFACE:

                - Adapter com lambda ajusta uma fun√ß√£o ao formato esperado por 
                outra.

                Voc√™ tem:

                    def soma(a, b):
                        return a + b

                Mas precisa de:

                    f(x)

                Solu√ß√£o:

                    f = lambda x: soma(x, 10)

                Lambda atua como adaptador.

        ERROS COMUNS

            Lambdas longas

            Lambdas com efeitos colaterais

            Usar lambda no lugar de def complexo

            Fun√ß√£o com muitos par√¢metros

            Confundir print com retorno

        FRASES-CHAVE PARA MEMORIZAR

            . Fun√ß√£o √© comportamento
            . return encerra
            . Fun√ß√£o √© objeto
            . Closure captura estado
            . Decorador envolve
            . Lambda √© express√£o

    =====================================================================

    Recurs√µes:

        Resolver um problema chamando o pr√≥prio problema

        - Recurs√£o √© uma t√©cnica em que uma fun√ß√£o chama a si mesma para 
        resolver um problema menor do mesmo tipo.

        Toda recurs√£o correta tem:

            1. Caso base ‚Üí quando parar

            2. Caso recursivo ‚Üí chamada para um problema menor

            3. Progresso ‚Üí cada chamada se aproxima do caso base

            Se faltar qualquer um ‚Üí bug.

        COMO A RECURS√ÉO FUNCIONA (POR DENTRO):

            Exemplo conceitual:

                f(3)
                ‚îî‚îÄ f(2)
                    ‚îî‚îÄ f(1)
                        ‚îî‚îÄ f(0)  ‚Üê caso base

            . Cada chamada cria um novo frame na pilha (stack)

            . Vari√°veis s√£o locais √†quela chamada

            . Quando o caso base retorna, a pilha desempilha

            Isso se chama call stack.
        
        CALL STACK (PILHA DE EXECU√á√ÉO):

            . Estrutura LIFO (Last In, First Out)

            . Cada chamada ocupa mem√≥ria

            . Python n√£o otimiza tail recursion

            Recurs√£o profunda ‚Üí risco real.

        STACK OVERFLOW:

            - Stack overflow ocorre quando a recurs√£o cria chamadas demais
            antes de retornar.

            Causas:

                . caso base inexistente
                . caso base errado
                . problema grande demais
                . recurs√£o infinita

            Exemplo cl√°ssico de erro:

                def f(n):
                    return f(n + 1)

            Em Python:

                RecursionError: maximum recursion depth exceeded

        QUANDO USAR RECURS√ÉO (E QUANDO N√ÉO):

            Use recurs√£o quando:

                problema √© naturalmente recursivo

                estrutura em √°rvore

                divis√£o em subproblemas claros

                clareza > performance

            Evite recurs√£o quando:

                h√° la√ßo simples equivalente

                profundidade pode ser grande

                performance e mem√≥ria s√£o cr√≠ticas

            Em Python, loops geralmente s√£o melhores.

        T√âCNICAS E ESTRAT√âGIAS DE RECURS√ÉO:

            1. Recurs√£o direta simples

                - A fun√ß√£o chama a si mesma.

                Exemplo conceitual:

                    f(n) = f(n-1)

                Usos:

                    fatorial

                    soma

                    contagem

            2. Recurs√£o linear

                - Uma chamada recursiva por execu√ß√£o.

                EX:

                    f(n) ‚Üí f(n-1)

                Profundidade = n

            3. Recurs√£o m√∫ltipla (ramificada)

                - Mais de uma chamada recursiva.

                Ex:

                    f(n) ‚Üí f(n-1) + f(n-2)

                . Crescimento exponencial

                . Cuidado com performance

            4. Recurs√£o em estruturas:

                Muito comum em:

                    listas aninhadas

                    √°rvores

                    dicion√°rios aninhados

                EX:

                    processa(no):
                        para cada filho:
                            processa(filho)

            5. Dividir para conquistar

                - Quebra o problema em partes.

                Exemplos:

                    busca bin√°ria

                    merge sort

                    quicksort

            6. Recurs√£o com acumulador (quase tail recursion)

                EX:

                    f(n, acc)

                . reduz trabalho p√≥s-retorno

                . Python n√£o otimiza, mas melhora clareza

        RECURS√ÉO ‚Äî COMPLEMENTOS ESSENCIAIS:

            - Toda recurs√£o √© um if disfar√ßado.

            A forma geral √©:

                if caso_base:
                    return valor
                else:
                    return chamada_recursiva(...)

            - Sem if ‚Üí n√£o existe parada ‚Üí loop infinito na stack.

            . Caso base √© uma condi√ß√£o:

                if n == 0:
                    return 1

            . Caso recursivo √© outra condi√ß√£o

                return n * f(n - 1)

            Recurs√£o √© controle de fluxo condicional, n√£o m√°gico.

            RECURS√ÉO √ó LOOPS (RELA√á√ÉO REAL):

                - Recurs√£o substitui loops, mas n√£o elimina repeti√ß√£o.

                . N√£o use loop para SIMULAR a recurs√£o

                . Use loop para ITERAR n√≠veis, e recurs√£o para ESTRUTURA

                Conceitualmente:

                    for / while ‚Üí repeti√ß√£o expl√≠cita

                    recurs√£o ‚Üí repeti√ß√£o impl√≠cita via chamadas

                    Exemplo mental:

                        for i in range(n):

                    ‚âà

                        f(n):
                            f(n-1)

                Cada chamada equivale a uma itera√ß√£o.

                N√ÉO misture loop e recurs√£o sem motivo:

                        def f(n):
                            for i in range(n):
                                f(i)

                    PS: Complexidade explode

                    - Use uma t√©cnica por vez, salvo casos espec√≠ficos.

            return EM RECURS√ÉO (PONTO CRUCIAL):

                - Em recurs√£o, return n√£o √© opcional.

                Erro comum:

                        def f(n):
                            if n == 0:
                                return
                            f(n - 1)

                    - Retorna None

                    - Resultado in√∫til

                Forma correta:

                        def f(n):
                            if n == 0:
                                return 0
                            return 1 + f(n - 1)

                    - Cada chamada deve retornar algo para a anterior.

            PAR√ÇMETRO AUXILIAR:

                - √© um par√¢metro acumulador ou par√¢metro de controle.

                Tamb√©m conhecido como:

                    . √≠ndice de progresso

                    . estado da recurs√£o

                    . contador recursivo

                    Ele representa onde a recurs√£o est√°.

                . EX Forma conceitual:

                        soma(lista, i):
                            se i chegou no fim:
                                retorna 0
                            sen√£o:
                                retorna lista[i] + soma(lista, i+1)

                    Esse padr√£o √© chamado de:

                        recurs√£o com estado expl√≠cito

            RECURS√ÉO COM ACUMULADOR:

                Outro padr√£o cl√°ssico:

                    def soma_lista(lista, i=0, total=0):

                . i ‚Üí controle
                . total ‚Üí acumulador

                Equivale a:

                    total = 0
                    for x in lista:
                        total += x

            T√âCNICA: DIVIDIR E CONQUISTAR:

                - Dividir e conquistar quebra o problema em partes 
                independentes, resolve cada parte e combina os resultados.

                Estrutura formal:

                    Dividir o problema

                    Resolver subproblemas

                    Combinar resultados

                . Exemplo conceitual (soma)

                    soma(lista):
                        divide em duas metades
                        soma_esq = soma(esq)
                        soma_dir = soma(dir)
                        retorna soma_esq + soma_dir

                Profundidade menor que recurs√£o linear.


        ERROS COMUNS EM RECURS√ÉO

            . esquecer o caso base
            . caso base nunca ser alcan√ßado
            . mudar vari√°vel errada
            . retornar antes da recurs√£o
            . achar que recurs√£o √© sempre melhor
            . confundir recurs√£o com loop

        DICAS:

            . Defina o caso base primeiro
            . Pergunte: qual √© a vers√£o menor do problema?
            . Cada chamada deve reduzir o problema
            . Teste manualmente com n = 0, 1, 2
            . Desenhe a √°rvore de chamadas
            . Se ficou confuso ‚Üí escreva vers√£o iterativa

        FRASES-CHAVE PARA MEMORIZAR

            Caso base manda
            Problema menor a cada passo
            Stack cresce
            Python n√£o otimiza tail recursion
            Recurs√£o √© modelo mental
            Loop percorre n√≠vel
            Recurs√£o percorre profundidade
            N√£o simule recurs√£o com loop
            Use loop dentro da recurs√£o, n√£o o contr√°rio

    =====================================================================

    tabelas de decis√£o:

        - Tabela de decis√£o √© uma estrutura que mapeia combina√ß√µes de 
        condi√ß√µes ‚Üí a√ß√µes.

        Em vez de:

            . muitos if / elif / else

            . l√≥gica espalhada

        Voc√™ tem:

            . regras expl√≠citas

            . decis√£o orientada a dados

            . baixo acoplamento

        √â uma t√©cnica de design, n√£o apenas de c√≥digo.

        O PROBLEMA QUE A TABELA DE DECIS√ÉO RESOLVE:

            Considere l√≥gica assim:

                if A and B:
                elif A and not B:
                elif not A and B:
                else:

            Isso gera:

                . explos√£o combinat√≥ria

                . c√≥digo dif√≠cil de manter

                . bugs silenciosos

                Tabela de decis√£o resolve isso.

        O QUE √â UMA TABELA DE DECIS√ÉO (FORMALMENTE):

            Uma tabela de decis√£o possui:

                1. Condi√ß√µes (entradas)

                2. Combina√ß√µes poss√≠veis

                3. A√ß√£o associada a cada combina√ß√£o

            Matematicamente:

                (condi√ß√£o1, condi√ß√£o2, ..., condi√ß√£oN) ‚Üí a√ß√£o

        MODELO MENTAL CORRETO:

            - Dados escolhem comportamento.

            Voc√™ n√£o pergunta:

                ‚ÄúQual if eu escrevo agora?‚Äù

            Voc√™ pergunta:

                ‚ÄúQuais estados existem e o que deve acontecer em cada um?‚Äù

        TABELA DE DECIS√ÉO EM PYTHON (FORMA NATURAL):

            Em Python, a forma mais comum √©:

                - dict

                - chaves compostas (tuple)

                - valores como fun√ß√µes ou resultados

            . Exemplo conceitual simples

                Regras:

                    usu√°rio vip?

                    possui cart√£o?

                | VIP | Cart√£o | A√ß√£o                |
                | --- | ------ | ------------------- |
                | Sim | Sim    | desconto_vip_cartao |
                | Sim | N√£o    | desconto_vip        |
                | N√£o | Sim    | desconto_cartao     |
                | N√£o | N√£o    | sem_desconto        |

            Representa√ß√£o:

                tabela = {
                    (True, True): acao1,
                    (True, False): acao2,
                    (False, True): acao3,
                    (False, False): acao4
                }

            Isso √© uma tabela de decis√£o expl√≠cita.

        TABELA DE DECIS√ÉO √ó IF/ELIF:

            | Crit√©rio       | `if/elif` | Tabela  |
            | -------------- | --------- | ------- |
            | Clareza        | M√©dia     | Alta    |
            | Escalabilidade | Baixa     | Alta    |
            | Manuten√ß√£o     | Dif√≠cil   | F√°cil   |
            | Testes         | Complexos | Simples |
            | Extens√£o       | Perigosa  | Segura  |

            Quanto mais regras ‚Üí mais a tabela vence.

        QUANDO USAR TABELA DE DECIS√ÉO:

            Use quando:

                . h√° muitas combina√ß√µes
                . regras s√£o est√°veis
                . l√≥gica √© determin√≠stica
                . regras s√£o parte do neg√≥cio

            Exemplos reais:

                . regras de desconto
                . permiss√µes
                . valida√ß√µes
                . impostos
                . workflows

        QUANDO N√ÉO USAR:

            N√£o use quando:

                . l√≥gica depende de sequ√™ncia temporal
                . decis√µes s√£o probabil√≠sticas
                . regras mudam durante execu√ß√£o
                . poucas condi√ß√µes simples

            N√£o √© bala de prata.
        
        TABELA DE DECIS√ÉO + FUN√á√ïES:

            A√ß√£o n√£o precisa ser valor ‚Äî pode ser fun√ß√£o.

                tabela[(True, False)]()

            Isso une:

                tabela de decis√£o

                dispatch por fun√ß√£o

                estrat√©gia

        TABELA DE DECIS√ÉO PARCIAL:

            - Nem todas as combina√ß√µes precisam existir.

                tabela.get(chave, acao_padrao)

            Isso substitui else.

        ERROS COMUNS:

            . chaves mal definidas
            . duplicar l√≥gica dentro das a√ß√µes
            . misturar regra com execu√ß√£o
            . usar tabela para l√≥gica sequencial
            . n√£o tratar caso padr√£o

        DICAS:

            . Liste todas as condi√ß√µes
            . Liste todos os estados poss√≠veis
            . Defina a a√ß√£o de cada estado
            . Crie chave composta (tuple)
            . Separe decis√£o de execu√ß√£o
            . Teste cada linha da tabela

        FRASES-CHAVE PARA MEMORIZAR:

            Regra vira dado
            Dado escolhe a√ß√£o
            Menos ifs, mais clareza
            Tabela escala melhor

    =====================================================================

    Operadores bit-wise:

        - Pensando como o computador

        - Operadores bit-wise operam diretamente nos bits (0 e 1) de um n√∫mero 
        inteiro.

        Eles n√£o trabalham com valores, mas com a representa√ß√£o bin√°ria do valor.

        BIN√ÅRIO, VERDADE E FALSO:

            No n√≠vel mais baixo:

                0 ‚Üí False

                1 ‚Üí True

            Mas aten√ß√£o:

                Em bit-wise, cada bit √© avaliado individualmente, n√£o o n√∫mero 
                inteiro.

            Exemplo:

                6  ‚Üí 110
                3  ‚Üí 011

            Cada coluna √© uma ‚Äúverdade‚Äù independente.

        OPERADORES BIT-WISE EM PYTHON:

            | Operador | Nome        | Leitura            |
            | -------- | ----------- | ------------------ |
            | `&`      | AND         | e                  |
            | `|`      | OR          | ou                 |
            | `^`      | XOR         | ou exclusivo       |
            | `~`      | NOT         | nega√ß√£o            |
            | `<<`     | SHIFT LEFT  | desloca √† esquerda |
            | `>>`     | SHIFT RIGHT | desloca √† direita  |

        . 1) AND (&)

            Regra l√≥gica

                1 & 1 = 1
                1 & 0 = 0
                0 & 1 = 0
                0 & 0 = 0

            C√°lculo bit a bit:

                6  = 110
                3  = 011
                ---------
                &  = 010  ‚Üí 2

            Interpreta√ß√£o:

                O bit s√≥ √© 1 se ambos forem 1.

        . 2) OR (|)

            Regra l√≥gica

                1 | 1 = 1
                1 | 0 = 1
                0 | 1 = 1
                0 | 0 = 0

            C√°lculo:

                6  = 110
                3  = 011
                ---------
                |  = 111 ‚Üí 7

            Interpreta√ß√£o

                O bit √© 1 se qualquer um for 1.

        . 3) XOR (^) ‚Äî OU EXCLUSIVO:

            Regra l√≥gica:

                1 ^ 1 = 0
                1 ^ 0 = 1
                0 ^ 1 = 1
                0 ^ 0 = 0

            C√°lculo:

                6  = 110
                3  = 011
                ---------
                ^  = 101 ‚Üí 5

            Interpreta√ß√£o

                O bit √© 1 somente se forem diferentes.

        . 4) NOT (~):

            Regra l√≥gica:

                ~1 = 0
                ~0 = 1

            Mas em Python:

                ~x == -(x + 1)

            Exemplo:

                ~5   # -6

            Por qu√™?

                Python usa complemento de dois, com tamanho infinito de bits.

        . 5) SHIFT LEFT (<<)

            Desloca bits para a esquerda (multiplica por 2‚Åø).

            EX:

                3 = 011
                3 << 1 = 110 ‚Üí 6
                3 << 2 = 1100 ‚Üí 12

                3 << 1  # 6
                3 << 2  # 12

            Regra matem√°tica:

                x << n = x * (2‚Åø)

        . 6) SHIFT RIGHT (>>)

            Desloca bits para a direita (divide por 2‚Åø).

            EX:

                8 = 1000
                8 >> 1 = 0100 ‚Üí 4
                8 >> 2 = 0010 ‚Üí 2

                8 >> 1  # 4

            Regra matem√°tica:

                x >> n = x // (2‚Åø)

        BIT-WISE √ó OPERADORES L√ìGICOS:

            | Tipo     | Operador           | Atua sobre  |
            | -------- | ------------------ | ----------- |
            | L√≥gico   | `and`, `or`, `not` | valores     |
            | Bit-wise | `&`, `|`, `^`, `~` | bits        |

            Erro comum:

                if x & y:   # bit-wise
                if x and y: # l√≥gico

            S√£o coisas diferentes.

        USO COM CONDICIONAIS (FLAGS):

            READ  = 0b001
            WRITE = 0b010
            EXEC  = 0b100

            permissao = READ | WRITE

        Verificar permiss√£o:

            if permissao & READ:
                print("Pode ler")

        Isso √© bit-masking.

        USO COM match:

            match permissao:
                case p if p & READ and p & WRITE:
                    print("Leitura e escrita")
                case p if p & READ:
                    print("Somente leitura")

        match + bit-wise = leitura expressiva.

        USO COM LOOPS:

            - Iterar bits de um n√∫mero

                n = 13  # 1101
                while n:
                    print(n & 1)
                    n >>= 1

        USO COM FUN√á√ïES:

            Verificar se n√∫mero √© par:

                def eh_par(n):
                    return (n & 1) == 0

            Mais baixo n√≠vel que:

                n % 2 == 0

        EXEMPLOS LEGAIS (CL√ÅSSICOS):

            1. Testar se √© pot√™ncia de 2

                def potencia_de_dois(n):
                    return n > 0 and (n & (n - 1)) == 0

            2. Contar bits 1

                def conta_bits(n):
                    count = 0
                    while n:
                        count += 1
                        n &= n - 1
                    return count

            3. Flags com enumera√ß√£o

                FLAG_A = 1 << 0
                FLAG_B = 1 << 1
                FLAG_C = 1 << 2

        O QUE S√ÉO ESSES BIN√ÅRIOS DE SA√çDA?

            - Eles s√£o novos estados compostos.

            Eles N√ÉO s√£o:

                n√∫meros m√°gicos

                valores arbitr√°rios

            Eles S√ÉO:

                representa√ß√µes compactas de m√∫ltiplas verdades independentes

        MODELO MENTAL CORRETO (MUITO IMPORTANTE):

            Pense assim:

                Cada bit = uma pergunta SIM / N√ÉO

            Exemplo:

                bit 0 ‚Üí pode ler?
                bit 1 ‚Üí pode escrever?
                bit 2 ‚Üí pode executar?

            Ent√£o:

                6 = 110 ‚Üí escrever + executar
                3 = 011 ‚Üí ler + escrever

                Bits n√£o t√™m significado natural.
                O significado √© voc√™ quem define.

                . OS BITS N√ÉO ‚ÄúSABEM‚Äù O QUE √â LER OU ESCREVER

                    O n√∫mero 6 = 110 significa apenas:

                        bit2  bit1  bit0
                        1     1     0

                    Isso √© tudo que o computador sabe.

                    ‚Äúler‚Äù, ‚Äúescrever‚Äù, ‚Äúexecutar‚Äù n√£o existem no n√∫mero.
                    Eles surgem quando voc√™ define uma conven√ß√£o.

                . A CONVEN√á√ÉO PRECISA SER FIXA

                    Quando eu escrevi:

                        bit 0 ‚Üí ler
                        bit 1 ‚Üí escrever
                        bit 2 ‚Üí executar

                    isso foi uma escolha arbitr√°ria, mas consistente.

                    Vamos escrever isso formalmente:

                        LER       = 1 << 0  # 001
                        ESCREVER  = 1 << 1  # 010
                        EXECUTAR  = 1 << 2  # 100

                    Agora sim temos um dicion√°rio de significado.

                . AGORA VAMOS REFAZER OS EXEMPLOS SEM AMBIGUIDADE

                    . N√∫mero 6

                        6 = 110

                    Bits ligados:

                        bit1 (010) ‚Üí ESCREVER

                        bit2 (100) ‚Üí EXECUTAR

                    6 = escrever + executar
                
                . N√∫mero 3

                    3 = 011

                Bits ligados:

                    bit0 (001) ‚Üí LER

                    bit1 (010) ‚Üí ESCREVER

                3 = ler + escrever

                . POR QUE 6 N√ÉO √â ‚ÄúLER + ESCREVER‚Äù?

                    Porque o bit de LER √© o bit 0, e no n√∫mero 6 ele est√° 
                    desligado:

                        6 = 110
                                ‚Üë
                              bit0 = 0  ‚Üí n√£o l√™

                    J√° no n√∫mero 3:

                        3 = 011
                                ‚Üë
                            bit0 = 1  ‚Üí l√™

                O ERRO MAIS COMUM (E FOI ESSE O SEU INC√îMODO):

                    Pensar que ‚Äúposi√ß√£o visual‚Äù do bit define significado.

                    ERRADO:

                        110 ‚Üí ‚Äúos dois primeiros‚Äù

                    CERTO:

                        cada posi√ß√£o = uma pot√™ncia de 2 fixa

                - Bit n√£o √© r√≥tulo.
                - Bit √© posi√ß√£o.
                - O significado vem da constante associada.

            Agora veja:

                AND (&):

                    comum aos dois ‚Üí escrever

                OR (|)

                    tudo que qualquer um pode ‚Üí ler + escrever + executar

                XOR (^)

                    o que s√≥ um deles pode ‚Üí ler + executar

            Isso √© l√≥gica de estados, n√£o matem√°tica comum.


        ERROS COMUNS

            . confundir & com and
            . usar bit-wise com floats
            . usar ~ sem entender complemento de dois
            . esquecer preced√™ncia (& < ==)
            . achar que bit-wise substitui l√≥gica comum

        DICAS:

            Pense em bits, n√£o em n√∫meros
            Use bit-wise quando:
                estados s√£o combin√°veis
                flags independentes
                performance importa
            Use m√°scaras para clareza
            Prefira nomes sem√¢nticos (READ, WRITE)
            Teste com bin√°rio (bin(x))

        FRASES-CHAVE PARA MEMORIZAR:

            Bit-wise √© l√≥gica por bit
            AND restringe
            OR ativa
            XOR alterna
            Shift multiplica/divide por 2
            Flags simplificam decis√µes
            Operadores bit-wise n√£o produzem n√∫meros.
            Eles produzem estados.

    =====================================================================

    Listas, Arrays e Vetores:

        - Estrutura de dados que armazena m√∫ltiplos valores em sequ√™ncia,
        acessados por √≠ndice.

        . Em Python

            . list √© a estrutura nativa

            . √â:

                ordenada

                mut√°vel

                heterog√™nea

                din√¢mica

        Python n√£o tem array fixo nativo como C.

        Para arrays num√©ricos reais: array, numpy (outro assunto).

        CRIA√á√ÉO DE LISTAS:

            lista = []
            lista = [1, 2, 3]
            lista = list(range(5))

        √çNDICES:

            √çndices come√ßam em 0

            √çndices negativos contam do final

                lista[0]    # primeiro
                lista[-1]   # √∫ltimo

            √çndice inv√°lido ‚Üí IndexError

        ACESSO A ELEMENTOS:

            leitura

            constante O(1)

        MODIFICANDO ELEMENTOS:

                lista[0] = 10

            Lista √© mut√°vel.

        SWAP COM LISTAS:

                lista[i], lista[j] = lista[j], lista[i]

            Swap nativo, sem vari√°vel auxiliar.

        TAMANHO DA LISTA:

            len(lista)

        SLICING:

                lista[inicio:fim:passo]

            Exemplos:

                lista[:3]
                lista[2:]
                lista[::-1]

            Slicing cria nova lista.

        C√ìPIA DE LISTA vs ENDERE√áAMENTO:

            Refer√™ncia (mesmo objeto):

                lista = [1, 2, 3]
                listab = lista

            C√≥pia rasa:

                lista = [1, 2, 3]
                listab = lista[:]
                listab = lista.copy()

            Modificar b n√£o afeta a.

        LISTA COM OPERADORES:

                [1, 2] + [3, 4]     # concatena
                [0] * 5             # repete

            - + cria nova lista

            - * replica refer√™ncias (cuidado com listas aninhadas)

        LISTA COM CONDICIONAIS:

                for x in lista:
                    if x > 0:
                        ...

            Muito comum em filtragem.

        LISTA COM LOOPS:

            FOR:

                    for x in lista:

                Com √≠ndice:

                    for i in range(len(lista)):

                Melhor:

                    for i, v in enumerate(lista):

            while:

                i = 0
                while i <= len(lista):

        LISTA COM N√öMEROS

            Usos comuns:

                soma

                m√©dia

                m√°ximo

                m√≠nimo

                contagem

        LISTA COM STRINGS

                nomes = ["Ana", "Jo√£o"]

            Comuns:

                normaliza√ß√£o

                busca

                compara√ß√£o

                parsing

        in / not in vs is / is not:

            . in: Verifica valor

                x in lista

            . is: Verifica objeto. Nunca use is para comparar valores de lista.

                x is y

        sort vs sorted:

            - Ordenam a lista

            . sort()

                    lista.sort()
                    lista.sort(reverse=True)

                . modifica a lista

                . retorna None

            . sorted()

                    nova = sorted(lista)
                    nova = sorted(lista, reverse=True)

                . cria nova lista

                . original intacta

        index:

                lista.index(valor)

            . retorna √≠ndice

            . erro se n√£o existir

        min e max:

            min(lista)  # Menor valor
            max(lista)  # Maior valor

        sum: Apenas para n√∫meros.

            sum(lista)  # Soma o conte√∫do da lista

        count:

            Faz contagem de um elemento na lista

            PS: √â usado com strings e outros iter√°veis tamb√©m

                lista.count(valor)

        reverse:

                lista.reverse()

            . In-place

            . Diferente de lista[::-1]

        zip:

                zip(lista1, lista2)

            . itera√ß√£o paralela

            . gera tuplas

        enumerate:

                enumerate(lista)

            . √≠ndice + valor

            . padr√£o profissional

        append, insert, extend, concatena√ß√£o:

            append: Adiciona no final daa lista

                lista.append(x)

            insert: Adiciona em uma posi√ß√£o espec√≠fica da lista.
            PS: Fica inificiente em rela√ß√£o a posi√ß√£o escolhidas e tamanho da
            lista, pois ele movimenta os dados para o pr√≥ximo ap√≥s a inser√ß√£o

                lista.insert(i, x)

            extend: Funde uma lista na outra

                lista.extend(outra)

            concatena√ß√£o: Junta uma lista na outra

                lista + outra

        REPETI√á√ÉO DE ELEMENTOS:

                [0] * 5

            PS: Cuidado com listas aninhadas:

                [[0]*3]*3  # errado

        REMO√á√ÉO: pop, remove, del:

            pop: Remove um valor por √≠ndice escolhido

                lista.pop()  # Padr√£o sempre o √∫ltimo
                lista.pop(i)

            remove: Remove por valor

                lista.remove(valor)

            del: Forma alternativa de remover um item. Mas cuidado,
            se voc√™ dar um del lista sem especificar o item, apagar√° a 
            refer√™ncia inteira da lista.

                del lista[i]

        EMPACOTAMENTO E DESEMPACOTAMENTO:

                a, b = [1, 2]

            Com estrela: Pega todo o resto

                a, *resto = [1, 2, 3, 4]

        OUTRAS PROPRIEDADES E T√âCNICAS:

            . Lista √© heterog√™nea

                [1, "a", True]

            . Lista √© din√¢mica

                cresce

                diminui

            . Lista pode conter listas

                matriz = [[1,2],[3,4]]

            . Percurso seguro:

                for x in lista[:]:

        ERROS COMUNS:

            . confundir c√≥pia com refer√™ncia
            . usar is em vez de ==
            . modificar lista enquanto itera
            . usar √≠ndice quando n√£o precisa
            . esquecer que sort() n√£o retorna lista

        DICAS:

            Precisa de ordem? ‚Üí lista
            Precisa mudar valores? ‚Üí lista
            Precisa percorrer? ‚Üí for ou while dependendo da situa√ß√£o
            Precisa √≠ndice? ‚Üí enumerate
            Precisa c√≥pia? ‚Üí copy()
            Muito if? ‚Üí refatorar

        FRASES-CHAVE PARA MEMORIZAR:

            Lista √© mut√°vel
            √çndice come√ßa em zero
            Slicing copia
            sort modifica
            sorted cria nova
            in verifica valor

    =====================================================================

    Indices:

        √çndice √© a posi√ß√£o num√©rica que identifica um elemento dentro de uma 
        estrutura sequencial.

        - √çndice = deslocamento (offset) a partir de um endere√ßo base

        - Permite acesso direto a elementos

        Sem √≠ndice, estruturas sequenciais n√£o seriam eficientes.

        USO DE √çNDICES:

            - Acesso direto (O(1))

                    lista[i]

                . O computador n√£o percorre a lista

                . Ele calcula o endere√ßo diretamente

                Isso √© acesso de tempo constante.

            . Escrita / modifica√ß√£o

                Motivo hist√≥rico e t√©cnico:

                    Em mem√≥ria:

                        endere√ßo = base + √≠ndice * tamanho_do_elemento

                    Se √≠ndice come√ßa em 0:

                        primeiro elemento ‚Üí deslocamento zero

                        c√°lculo mais simples

                        hardware agradece

                        Isso vem de C, assembly e arquitetura de CPU.

            . FUNCIONAMENTO NA MEM√ìRIA

                Suponha:

                    . lista come√ßa no endere√ßo 1000

                    . cada elemento ocupa 8 bytes

                    | √çndice | Endere√ßo |
                    | ------ | -------- |
                    | 0      | 1000     |
                    | 1      | 1008     |
                    | 2      | 1016     |
                    | 3      | 1024     |

                F√≥rmula:

                    endere√ßo = base + √≠ndice √ó tamanho

                √â por isso que lista[i] √© r√°pido.

        √çNDICE ‚â† CONTE√öDO:

            O √≠ndice n√£o √© o valor.

                lista = [10, 20, 30]

            . √≠ndice 1 ‚Üí valor 20

            . √≠ndice √© posi√ß√£o, n√£o dado

            Confundir isso gera bugs cl√°ssicos.

        √çNDICES NEGATIVOS (PYTHON):

                lista[-1]

            Significa:

                lista[len(lista) - 1]

            √â um atalho sem√¢ntico, n√£o algo m√°gico.

            Na mem√≥ria:

                . o Python ajusta o √≠ndice

                . converte para positivo

                . acessa normalmente

        √çNDICES E LIMITES:

            . Erro cl√°ssico

                lista[len(lista)]

            - √∫ltimo √≠ndice v√°lido √© len(lista) - 1

            - len(lista) √© fora do intervalo

            Gera IndexError.

        APLICA√á√ïES DE √çNDICES:

            . Percurso manual

                    i = 0
                    while i < len(lista):
                        ...
                        i += 1

                - √çndice atua como estado do loop.

            . Compara√ß√£o entre elementos

                    lista[i] > lista[i+1]

                - Base de algoritmos de ordena√ß√£o.

            . Sincroniza√ß√£o entre listas

                lista1[i], lista2[i]

        T√âCNICAS DE USO COM √çNDICES:

            . T√©cnica 1 ‚Äî Dois √≠ndices (two pointers)

                    i = 0
                    j = len(lista) - 1

                Usos:

                    . invers√£o

                    . verifica√ß√£o de pal√≠ndromo

                    . parti√ß√µes

                    Muito comum em entrevistas.

            . T√©cnica 2 ‚Äî √çndice como estado

                    def f(lista, i=0):

                . i indica progresso

                . comum em recurs√£o

                i = par√¢metro de controle.

            . T√©cnica 3 ‚Äî √çndice + condi√ß√£o

                    for i in range(len(lista)):
                        if i % 2 == 0:
                            ...

                Usos:

                    posi√ß√µes pares/√≠mpares

                    padr√µes

            . T√©cnica 4 ‚Äî √çndice com deslocamento

                    lista[i+k]

                Usos:

                    janelas deslizantes

                    an√°lise local

            . T√©cnica 5 ‚Äî enumerate (√≠ndice seguro)

                    for i, v in enumerate(lista):

                .  Mais leg√≠vel
                .  Menos erro
                .  Padr√£o profissional

            . T√©cnica 6 ‚Äî Swap por √≠ndice

                    lista[i], lista[j] = lista[j], lista[i]

                Base de:

                    ordena√ß√£o

                    rearranjos

        √çNDICES E PERFORMANCE:

            | Opera√ß√£o               | Complexidade |
            | ---------------------- | ------------ |
            | acesso `lista[i]`      | O(1)         |
            | modifica√ß√£o `lista[i]` | O(1)         |
            | inser√ß√£o no meio       | O(n)         |
            | remo√ß√£o no meio        | O(n)         |

            √çndices s√£o r√°pidos, movimenta√ß√£o n√£o.

        ERROS COMUNS COM √çNDICES:

            . off-by-one (+1 ou -1 errado)

            . usar √≠ndice quando n√£o precisa

            . modificar lista enquanto itera

            . confundir √≠ndice com valor

            . acessar fora do limite

        DICAS:

            Sempre pense: intervalo v√°lido √© [0, len-1]

            √öltimo elemento ‚Üí len - 1

            Prefira enumerate

            Use dois √≠ndices quando houver simetria

            Se ficou confuso ‚Üí desenhe os √≠ndices

            √çndice √© matem√°tica, n√£o tentativa

        FRASES-CHAVE PARA MEMORIZAR:

            √çndice √© deslocamento
            Come√ßa em zero por efici√™ncia
            Acesso √© constante
            Valor ‚â† posi√ß√£o
            enumerate √© seu amigo

    =====================================================================

    In place:

        - Um algoritmo ou opera√ß√£o √© in place quando modifica os dados 
        diretamente na estrutura original, usando pouca ou nenhuma mem√≥ria
        extra.

        . Espa√ßo extra ‚Üí O(1) (ou constante)

        . A estrutura original √© alterada

        EXEMPLO SIMPLES (LISTA):

            - N√ÉO in place

                    nova = lista[::-1]

                . cria nova lista
 
                . mem√≥ria extra O(n)

                . original permanece intacta

            - IN PLACE:

                    lista.reverse()

                . mesma lista

                . sem criar outra

                . mem√≥ria extra m√≠nima

                Resultado visual pode ser igual, mas o custo √© diferente.
        
        IN PLACE E MEM√ìRIA:

            Imagine uma lista na mem√≥ria:

                Endere√ßo 1000 ‚Üí [1, 2, 3, 4]

            . Opera√ß√£o in place

                - altera valores nos mesmos endere√ßos

                - n√£o realoca a estrutura inteira

            . Opera√ß√£o n√£o in place

                - cria outra √°rea de mem√≥ria

                - copia os valores

                - mant√©m a original intacta

            Isso impacta:

                desempenho

                consumo de mem√≥ria

                cache da CPU

        IN PLACE √ó N√ÉO IN PLACE (COMPARA√á√ÉO):

            | Crit√©rio            | In place     | N√£o in place  |
            | ------------------- | ------------ | ------------- |
            | Cria nova estrutura | ‚ùå           | ‚úî             |
            | Usa mem√≥ria extra   | O(1)         | O(n)          |
            | Modifica original   | ‚úî            | ‚ùå            |
            | Mais r√°pido         | geralmente ‚úî | geralmente ‚ùå |
            | Mais seguro         | ‚ùå           | ‚úî             |

            Seguran√ßa aqui = n√£o destruir dados originais.

        EXEMPLOS CL√ÅSSICOS EM PYTHON:

            . sort() vs sorted()

                lista.sort()      # IN PLACE
                sorted(lista)     # N√ÉO in place

            . reverse()

                lista.reverse()   # IN PLACE

            . Swap

                lista[i], lista[j] = lista[j], lista[i]  # IN PLACE

            . Modifica√ß√£o direta

                lista[0] = 10     # IN PLACE

        OPERADORES S√ÉO IN PLACE?

            . N√ÉO

                    lista = lista + outra

                . cria nova lista

            . SIM (conceitualmente)

                    lista += outra

                . += pode ser in place dependendo do tipo.

        IN PLACE E √çNDICES (CONEX√ÉO DIRETA)

            Opera√ß√µes in place:

                usam √≠ndices

                alteram posi√ß√µes existentes

                n√£o mudam a identidade do objeto

            EX:

                id(lista)  # permanece o mesmo

            Isso √© fundamental para entender refer√™ncias.

        IN PLACE E REFER√äNCIAS:

                a = [1, 2, 3]
                b = a

            Agora:

                a.sort()  # IN PLACE

            + b tamb√©m muda.

            Porque √© o mesmo objeto.

        QUANDO USAR IN PLACE:

            Use quando:

                mem√≥ria √© cr√≠tica

                lista √© grande

                voc√™ quer modificar o original

                n√£o precisa preservar vers√£o anterior

        QUANDO N√ÉO USAR:

            Evite quando:

                precisa preservar dados

                c√≥digo deve ser seguro

                m√∫ltiplas refer√™ncias existem

                clareza √© mais importante que performance

        T√âCNICAS COMUNS IN PLACE:

            . Dois √≠ndices

                i, j = 0, len(lista)-1

            . Swap progressivo

                while i < j:
                    lista[i], lista[j] = lista[j], lista[i]

            . Atualiza√ß√£o acumulada

                for i in range(len(lista)):
                    lista[i] += 1

        ERROS COMUNS

            esquecer que a lista original ser√° alterada

            modificar enquanto itera sem cuidado

            confundir retorno None com erro

            usar in place quando precisava de c√≥pia

        DICAS:

            Pergunte: preciso preservar o original?

            Se sim ‚Üí n√£o use in place

            Se n√£o ‚Üí prefira in place

            Verifique se o m√©todo retorna None

            Aten√ß√£o a refer√™ncias m√∫ltiplas

        FRASES-CHAVE PARA MEMORIZAR:

            . In place altera o original
            . Usa pouca mem√≥ria
            . N√£o cria c√≥pia
            . Mais r√°pido, menos seguro
            . Refer√™ncias importam

    =====================================================================

    Janelas:

        - Janela √© uma t√©cnica que analisa subconjuntos consecutivos de uma 
        estrutura sequencial (lista, string, array), deslocando um intervalo 
        ao longo dos dados.

        Em vez de:

            recalcular tudo do zero

            usar loops aninhados

        Voc√™:

            mant√©m uma janela

            move ela passo a passo

            atualiza o estado

        Isso reduz drasticamente o custo computacional.

        MODELO MENTAL FUNDAMENTAL:

            Imagine a lista:

                [2, 4, 1, 7, 3, 6]

            Janela de tamanho 3:

                [2, 4, 1]  ‚Üí janela 1
                    [4, 1, 7]  ‚Üí janela 2
                        [1, 7, 3]  ‚Üí janela 3
                            [7, 3, 6]  ‚Üí janela 4

            A janela desliza, mas os dados n√£o mudam.

        POR QUE JANELAS EXISTEM?

            Sem janela (ing√™nuo):

                    para cada posi√ß√£o:
                        recalcula tudo

                Complexidade:

                    O(n √ó k)

                Com janela:

                    remove o que sai
                    adiciona o que entra

                Complexidade:

                    O(n)

                Isso √© otimiza√ß√£o algor√≠tmica pura.

        TIPOS DE JANELA:

            1) JANELA DE TAMANHO FIXO

                - O tamanho da janela √© constante.

                Exemplo:

                    . m√©dia m√≥vel
                    . soma de k elementos
                    . maior soma de k elementos consecutivos

                    Modelo:

                        in√≠cio = 0
                        fim = k - 1

            2) JANELA DE TAMANHO VARI√ÅVEL

                - O tamanho cresce ou diminui conforme uma condi√ß√£o.

                Exemplo:

                    . menor sublista com soma ‚â• X
                    . substring sem caracteres repetidos

                    Modelo:

                        expande ‚Üí contrai ‚Üí expande

        JANELA E √çNDICES (CONEX√ÉO DIRETA):

            Janela sempre usa:

                . dois √≠ndices

                    . left

                    . right

                Eles definem:

                    janela = dados[left:right+1]

                T√©cnica dos dois ponteiros.

        JANELA DE TAMANHO FIXO (EXPLICA√á√ÉO):

            Exemplo conceitual: soma de 3 elementos

                lista = [2, 4, 1, 7, 3, 6]
                k = 3

            Passos:

                1. soma inicial dos 3 primeiros

                2. move a janela:

                    . subtrai o elemento que saiu

                    . soma o elemento que entrou

                N√£o recalcula tudo.

        JANELA DE TAMANHO VARI√ÅVEL (EXPLICA√á√ÉO):

            Exemplo:

                menor sublista com soma ‚â• 10

            Processo:

                1. expande a janela (direita)

                2. quando atingir condi√ß√£o:

                    . tenta contrair (esquerda)

                3. mant√©m o melhor resultado

                Muito usada em problemas dif√≠ceis.
        
        JANELAS E MEM√ìRIA:

            . A janela n√£o cria c√≥pia

            . Trabalha in place sobre √≠ndices

            . Usa mem√≥ria O(1)

            Isso conecta diretamente com:

                √≠ndices

                in place

                performance

        JANELAS √ó SLICING:

            Ruim:

                lista[i:i+k]  # cria nova lista

            Bom:

                usa √≠ndices + acumulador

            Janelas n√£o copiam dados.

        USOS CL√ÅSSICOS DE JANELAS:

            m√©dia m√≥vel
            soma m√°xima
            an√°lise de s√©ries temporais
            detec√ß√£o de padr√µes
            strings (substrings)
            processamento de sinais
            logs e streams
        
        ERROS COMUNS

            usar slicing dentro do loop

            esquecer de remover o elemento que sai

            errar limites (right < len)

            confundir janela fixa com vari√°vel

            usar dois loops quando um basta

        DICAS:

            Pergunte:

                Estou analisando elementos consecutivos?

                Recalculo valores repetidamente?

                Existe um tamanho fixo ou condi√ß√£o din√¢mica?

                Posso atualizar o resultado incrementalmente?

            Se sim ‚Üí √© problema de janela.

        FRASES-CHAVE PARA MEMORIZAR

            . Janela analisa subconjuntos consecutivos
            . Dois √≠ndices definem a janela
            . Remove o que sai, adiciona o que entra
            . Evita loops aninhados
            . Janela √© otimiza√ß√£o

    =====================================================================

    Slicing:

        - Slicing √© a opera√ß√£o de extrair um subconjunto consecutivo de uma
        sequ√™ncia, usando √≠ndices.

        Funciona em:

            . listas
 
            . strings
 
            . tuplas

            . outras sequ√™ncias

            Sempre baseado em √≠ndices.

        FORMA PYTH√îNICA (OFICIAL):

            seq[inicio:fim:passo]

        Regras:

            inicio ‚Üí inclusivo

            fim ‚Üí exclusivo

            passo ‚Üí incremento

        Exemplos:

            lista[1:4]
            lista[:3]
            lista[2:]
            lista[::2]
            lista[::-1]

        POR QUE O FIM √â EXCLUSIVO?

            - Consist√™ncia matem√°tica:

                tamanho = fim - inicio

            Isso:

                . evita +1
                . simplifica c√°lculo
                . permite compor slices

                Mesma raz√£o dos loops range.

        FUNCIONAMENTO NA MEM√ìRIA:

            . Listas

                slicing cria nova lista

                c√≥pia rasa

                custo O(k)

            EX:

                nova = lista[2:5]

            N√£o √© in place.

            . Strings

                strings s√£o imut√°veis

                slicing cria nova string

        IMPLICA√á√ÉO IMPORTANTE:

            - Slicing n√£o √© barato.

            Dentro de loops:

                for i in range(n):
                    lista[i:i+k]

            Pode virar O(n¬≤).

        SLICING MANUAL (COM √çNDICES):

            Antes de slicing existir, far√≠amos:

                nova = []
                for i in range(inicio, fim):
                    nova.append(lista[i])

            Isso √© slicing manual.

            Quando usar slicing manual?

                quando precisa de controle

                quando quer evitar c√≥pias

                quando usa janelas

                quando filtra dinamicamente

        SLICING PYTH√îNICO (IDIOM√ÅTICO):

                lista[::-1]
                lista[:]
                lista[::2]

            . Leg√≠vel
            . Expressivo
            . Menos c√≥digo

            Mas pode esconder custo.

        SLICING COM PASSO:

                lista[::2]   # pares
                lista[1::2]  # √≠mpares

            Cria nova lista pulando elementos.

        SLICING NEGATIVO:

                lista[-3:]
                lista[:-1]
            
            Python ajusta √≠ndices automaticamente.

        SLICING COMO C√ìPIA:

                copia = lista[:]

            . C√≥pia rasa.

            . Para listas aninhadas, cuidado.

        SLICING IN PLACE?

            Slicing n√£o √© in place, exceto em atribui√ß√£o.

            . Atribui√ß√£o por slice

                    lista[1:3] = [9, 9]

                . In place
                . Modifica estrutura

                T√©cnica avan√ßada.

        SLICING vs JANELAS:

            | Slicing          | Janela           |
            | ---------------- | ---------------- |
            | cria c√≥pia       | n√£o cria         |
            | simples          | eficiente        |
            | custo O(k)       | custo O(1)       |
            | bom para leitura | bom para an√°lise |

            Use slicing para extrair, janelas para analisar.

        T√âCNICAS E ESTRAT√âGIAS COM SLICING:

            T√©cnica 1 ‚Äî C√≥pia segura

                nova = lista[:]

            T√©cnica 2 ‚Äî Revers√£o r√°pida

                    lista[::-1]

                Para leitura ou c√≥pia.

            T√©cnica 3 ‚Äî Substitui√ß√£o parcial

                    lista[:2] = [0, 0]

                . In place.

            T√©cnica 4 ‚Äî Quebra em partes

                    meio = len(lista)//2
                    esq = lista[:meio]
                    dir = lista[meio:]

                . Base de divide and conquer.

            T√©cnica 5 ‚Äî Fatiamento por padr√£o

                pares = lista[::2]

            T√©cnica 6 ‚Äî Sliding via slicing (cuidado)

                    for i in range(len(lista)-k+1):
                        janela = lista[i:i+k]

                Simples, mas custoso.

        ERROS COMUNS

            achar que slicing √© in place

            usar slicing pesado em loops

            confundir slice vazio com erro

            esquecer que fim √© exclusivo

            usar slicing quando √≠ndice basta

        DICAS:

            . Precisa extrair ‚Üí slicing
            . Precisa analisar repetidamente ‚Üí janela
            . Precisa copiar ‚Üí slicing
            . Precisa performance ‚Üí √≠ndices
            . Use slicing com inten√ß√£o

        FRASES-CHAVE PARA MEMORIZAR:

            Slicing copia
            Fim √© exclusivo
            Passo controla salto
            N√£o √© in place
            Janela √© melhor para an√°lise

    =====================================================================

    Divis√£o e conquista:

        - Resolver o grande resolvendo muitos pequenos

        - Divis√£o e conquista √© um paradigma algor√≠tmico que resolve um problema
        dividindo-o em subproblemas menores, resolvendo cada um de forma 
        independente e combinando os resultados.

        Ele tem 3 etapas obrigat√≥rias:

            1. Dividir o problema

            2. Conquistar (resolver os subproblemas)

            3. Combinar os resultados

            Se faltar uma delas ‚Üí n√£o √© divis√£o e conquista.

        - ‚ÄúSe eu sei resolver o problema pequeno, sei resolver o grande.‚Äù

        √â o mesmo racioc√≠nio da indu√ß√£o matem√°tica.

        ESTRUTURA PADR√ÉO (FORMA GERAL):

            Em pseudoc√≥digo:

                resolver(problema):
                    se problema √© pequeno:
                        resolve diretamente
                    divide o problema em partes
                    resolve cada parte recursivamente
                    combina os resultados

            Note: recurs√£o quase sempre aparece, mas recurs√£o sozinha n√£o √© 
            divis√£o e conquista.

        DIFEREN√áA CRUCIAL: RECURS√ÉO √ó DIVIS√ÉO E CONQUISTA:

            | Recurs√£o           | Divis√£o e Conquista |
            | ------------------ | ------------------- |
            | T√©cnica            | Paradigma           |
            | Pode ter 1 chamada | Tem 2+ subproblemas |
            | Pode ser linear    | √â estrutural        |
            | Nem sempre divide  | Sempre divide       |

            Todo divide & conquer usa recurs√£o,

            mas nem toda recurs√£o √© divide & conquer.

        EXEMPLO CONCEITUAL SIMPLES (SOMA):

            Problema:

                Somar uma lista grande

            Forma linear: ineficiente nesse caso

                soma = soma(lista inteira)

            Divis√£o e conquista: Mais eficiente nesse caso

                soma(lista):
                    divide em duas metades
                    soma esquerda
                    soma direita
                    retorna soma_esq + soma_dir

            O problema fica menor em cada n√≠vel.

        POR QUE ISSO FUNCIONA T√ÉO BEM?

            1) Reduz complexidade

                . profundidade ‚âà log n

                . n√£o cresce linearmente

            2) Explora paralelismo

                . subproblemas independentes

                . ideal para m√∫ltiplos n√∫cleos

            3) Estrutura clara

                . l√≥gica local

                . menos estados confusos

        COMPARA√á√ÉO COM FOR√áA BRUTA:

            | Abordagem        | Complexidade  |
            | ---------------- | ------------- |
            | For√ßa bruta      | O(n¬≤) ou pior |
            | Divide & conquer | O(n log n)    |

            Isso muda completamente a escala.

        FUNCIONAMENTO NA MEM√ìRIA

            . Cada divis√£o cria chamadas recursivas
            . Usa stack
            . Aloca subestruturas (√†s vezes com slicing)

            Implementa√ß√µes boas evitam c√≥pias desnecess√°rias.

        ERROS COMUNS (MUITO IMPORTANTES)

            . ‚ÄúUsar recurs√£o = dividir e conquistar‚Äù
            . N√£o definir caso base 
            . Dividir mal (subproblemas desbalanceados) 
            . N√£o combinar corretamente
            . Usar quando um loop simples basta

        QUANDO USAR DIVIS√ÉO E CONQUISTA

            Use quando:

                o problema √© grande

                pode ser quebrado naturalmente

                subproblemas s√£o independentes

                h√° ganho claro de performance

        QUANDO N√ÉO USAR

            Evite quando:

                problema √© linear simples

                custo de divis√£o √© alto

                h√° depend√™ncia sequencial forte

                solu√ß√£o iterativa √© mais clara

        Dividir s√≥ por ‚Äúestilo‚Äù √© erro.

        COMO IDENTIFICAR UM PROBLEMA DE DIVIS√ÉO E CONQUISTA:

            Pergunte:

                1. Posso quebrar o problema em partes iguais?
                2. Resolver uma parte ajuda a resolver o todo?
                3. Subproblemas s√£o independentes?
                4. Combinar resultados √© simples?

                Se sim ‚Üí √© candidato.

        FRASES-CHAVE PARA MEMORIZAR

            Divide o problema
            Resolve partes menores
            Combina resultados
            Cresce em log n
            Paradigma, n√£o t√©cnica

    =====================================================================

    Rota√ß√£o:

        - Reorganizando elementos sem perder a ordem relativa

        - Rota√ß√£o √© a opera√ß√£o que desloca os elementos de uma sequ√™ncia 
        circularmente, preservando a ordem relativa.

        Ou seja:

            nada √© perdido

            nada √© criado

            apenas muda de posi√ß√£o

        Diferente de:

            ordena√ß√£o

            revers√£o

            embaralhamento

        MODELO MENTAL CORRETO:

            - Imagine uma lista como um anel, n√£o como uma linha.

                [1, 2, 3, 4, 5]

            Se voc√™ ‚Äúgira‚Äù esse anel, os elementos continuam na mesma ordem,
            s√≥ come√ßam em outro ponto.

        TIPOS DE ROTA√á√ÉO:

            1) ROTA√á√ÉO √Ä ESQUERDA (LEFT ROTATION)

                Cada elemento anda para a esquerda
                
                O primeiro vai para o final

                Exemplo:

                    [1, 2, 3, 4, 5]  ‚Üí rotacionar 2 √† esquerda
                    [3, 4, 5, 1, 2]

            2) ROTA√á√ÉO √Ä DIREITA (RIGHT ROTATION)

                Cada elemento anda para a direita
                
                O √∫ltimo vai para o in√≠cio

                Exemplo:

                    [1, 2, 3, 4, 5] ‚Üí rotacionar 2 √† direita
                    [4, 5, 1, 2, 3]

                Rota√ß√£o √† direita = rota√ß√£o √† esquerda de n - k.

            ROTA√á√ÉO ‚â† SHIFT:

                | Opera√ß√£o | O que acontece       |
                | -------- | -------------------- |
                | Shift    | elementos caem fora  |
                | Rota√ß√£o  | elementos reaparecem |

                Rota√ß√£o √© circular.

                √â um padr√£o estrutural, n√£o cosm√©tico.

        FORMAS DE IMPLEMENTAR ROTA√á√ÉO:

            1) ROTA√á√ÉO COM SLICING (N√ÉO IN PLACE)

                    rot = lista[k:] + lista[:k]

                . simples
                . cria nova lista
                . usa mem√≥ria O(n)

                Bom para leitura, n√£o para performance.

            2) ROTA√á√ÉO IN PLACE COM C√ìPIA AUXILIAR

                    temp = lista[:k]
                    lista[:len(lista)-k] = lista[k:]
                    lista[len(lista)-k:] = temp

                Parcialmente in place (usa buffer pequeno).

            3) ROTA√á√ÉO IN PLACE (T√âCNICA DAS REVERS√ïES)

                M√©todo cl√°ssico de CS

                Rota√ß√£o √† esquerda por k:

                    1. reverta os primeiros k

                    2. reverta o restante

                    3. reverta tudo

                    Exemplo:

                        [1,2,3,4,5], k=2
                        ‚Üí [2,1,3,4,5]
                        ‚Üí [2,1,5,4,3]
                        ‚Üí [3,4,5,1,2]

                . O(n)
                . O(1) mem√≥ria
                . Algoritmo cl√°ssico

        ROTA√á√ÉO E √çNDICES (BASE MATEM√ÅTICA):

            Para √≠ndice i:

                novo_indice = (i + k) % n

            Essa f√≥rmula aparece em:

                . hashing
                . criptografia
                . buffers
                . jogos
                . matrizes

        ROTA√á√ÉO E JANELAS:

            Rota√ß√£o cria:

                janelas circulares

                padr√µes repetitivos

            Exemplo:

                [1,2,3] ‚Üí janelas circulares
                [1,2], [2,3], [3,1]

            Muito usado em processamento de sinais.

        ROTA√á√ÉO EM STRINGS

            Strings s√£o imut√°veis:

                . rota√ß√£o sempre cria nova string

                    s = s[k:] + s[:k]

        ERROS COMUNS

            . confundir rota√ß√£o com invers√£o
            . esquecer de usar k % n
            . usar slicing pesado em loops
            . achar que rota√ß√£o √© sempre in place
            . errar esquerda √ó direita

        DICAS:

            Defina dire√ß√£o (esquerda ou direita)

            Normalize k (k %= n)

            Escolha:

                clareza ‚Üí slicing

                performance ‚Üí in place

            Pense circular, n√£o linear

            Desenhe a lista como um anel

        FRASES-CHAVE PARA MEMORIZAR

            Rota√ß√£o √© circular
            Ordem relativa √© preservada
            N√£o perde elementos
            √çndice usa m√≥dulo
            Revers√µes resolvem in place

    =====================================================================

    particionamento:

        Separar dados por crit√©rio, sem necessariamente ordenar

        - Particionamento √© a t√©cnica de dividir uma estrutura sequencial em
        partes, com base em um crit√©rio, mantendo os elementos relacionados
        juntos.

        Ou seja:

            voc√™ n√£o ordena

            voc√™ n√£o perde dados

            voc√™ apenas separa por condi√ß√£o

        √â uma reorganiza√ß√£o estrutural, n√£o est√©tica.

        MODELO MENTAL FUNDAMENTAL:

            Pense assim:

                ‚ÄúQuero que todos os elementos que satisfazem uma condi√ß√£o fiquem 
                de um lado, e os que n√£o satisfazem, do outro.‚Äù

            Exemplo:

                    [3, 8, 5, 2, 7, 4]

                Crit√©rio: < 5

            Resultado poss√≠vel:

                    [3, 2, 4 | 8, 5, 7]

                A ordem interna n√£o importa (a menos que voc√™ exija).

        PARTICIONAMENTO ‚â† ORDENA√á√ÉO:

            | Particionamento     | Ordena√ß√£o          |
            | ------------------- | ------------------ |
            | separa por crit√©rio | organiza por ordem |
            | O(n)                | O(n log n)         |
            | local               | global             |
            | base de algoritmos  | objetivo final     |

            Particionar √© mais barato que ordenar.

        POR QUE PARTICIONAMENTO EXISTE?

            Usos reais:

                QuickSort

                filtros in place

                dois ponteiros

                janelas

                sele√ß√£o do k-√©simo menor elemento

                separa√ß√£o de dados (positivos/negativos, v√°lidos/inv√°lidos)

            Ele resolve classes inteiras de problemas.

        FORMAS DE PARTICIONAR:

            1) PARTICIONAMENTO SIMPLES (COM LISTAS NOVAS)

                    menores = []
                    maiores = []

                . simples
                . usa mem√≥ria extra
                . n√£o √© in place

                Bom para clareza, ruim para performance.

            2) PARTICIONAMENTO IN PLACE (DOIS √çNDICES)

                T√©cnica cl√°ssica

                Modelo:

                    i ‚Üí avan√ßa procurando erro
                    j ‚Üí recua procurando erro
                    swap quando necess√°rio

                Muito usada em QuickSort.

        PARTICIONAMENTO COM PIV√î:

            Um elemento especial define a divis√£o.

            Exemplo:

                piv√¥ = 5

            Objetivo:

                ‚â§ piv√¥ | > piv√¥

            O piv√¥ n√£o precisa ficar no lugar final (dependendo da varia√ß√£o).

        ALGORITMO MENTAL DO PARTICIONAMENTO IN PLACE:

            1. Escolha um crit√©rio (ou piv√¥)

            2. Mantenha um √≠ndice de ‚Äúfronteira‚Äù

            3. Percorra a lista

            4. Quando encontrar um elemento v√°lido:

                . troque com a fronteira

                . avance a fronteira

            Isso garante separa√ß√£o correta.

        EXEMPLO CONCEITUAL (SEM C√ìDIGO):

            Lista:

                [7, 3, 5, 2, 8]

            Crit√©rio: < 5

            Processo:

                [3 | 7, 5, 2, 8]
                [3, 2 | 5, 7, 8]

            N√£o ordena, apenas agrupa.

        PARTICIONAMENTO E √çNDICES:

            Particionamento:

                depende fortemente de √≠ndices

                geralmente usa:

                    √≠ndice de varredura

                    √≠ndice de fronteira

                Conecta diretamente com:

                    swap

                    in place

                    mem√≥ria

        PARTICIONAMENTO E JANELAS:

            . janelas ‚Üí analisam subconjuntos

            . particionamento ‚Üí reorganiza o conjunto

            T√©cnicas complementares.

        PARTICIONAMENTO E DIVIS√ÉO E CONQUISTA:

            QuickSort funciona assim:

                1. particiona a lista

                2. resolve cada lado recursivamente

                Particionamento √© o passo central.

        VARIA√á√ïES IMPORTANTES:

            est√°vel √ó inst√°vel

            com piv√¥ fixo

            com piv√¥ aleat√≥rio

            particionamento por m√∫ltiplos crit√©rios

            particionamento l√≥gico (sem mover dados)

        ERROS COMUNS

            achar que particionamento ordena

            esquecer que a ordem interna pode mudar

            errar limites dos √≠ndices

            confundir fronteira com posi√ß√£o final

            tentar usar quando filtro simples bastaria

        DICAS:

            Pergunte:

                Preciso separar por condi√ß√£o?

                A ordem interna importa?

                Preciso ser in place?

                Isso √© pr√©-processamento para outro algoritmo?

            Se sim ‚Üí particionamento.

        FRASES-CHAVE PARA MEMORIZAR:

            Particionar √© separar
            N√£o ordena
            √â O(n)
            Base do QuickSort
            Usa √≠ndices e swaps

    ======================================================================

    Shift:

        ‚ÄúEmpurrar‚Äù itens para a esquerda/direita

        - Shift = deslocar elementos k posi√ß√µes para a esquerda ou direita.

        . Shift √† esquerda (n√£o circular): itens ‚Äúsaem‚Äù pelo come√ßo, e entram 
        ‚Äúburacos‚Äù no fim (preenchidos por algo).

        . Shift √† direita (n√£o circular): itens ‚Äúsaem‚Äù pelo fim, e entram 
        ‚Äúburacos‚Äù no come√ßo.

        Isso √© diferente de rota√ß√£o:

            . Shift: perde itens (ou voc√™ descarta) e preenche buracos.

            . Rota√ß√£o: ningu√©m some; √© circular.

        Exemplo (shift √† esquerda, k=2, preenchendo com 0):

            [1,2,3,4,5]  ->  [3,4,5,0,0]

        Exemplo (rota√ß√£o √† esquerda, k=2):

            [1,2,3,4,5]  ->  [3,4,5,1,2]

        Tipos de shift (estrat√©gias):

            A) Shift ‚Äúl√≥gico‚Äù (sem mexer na lista):

                Voc√™ n√£o move nada, s√≥ muda a forma de acessar:

                    . Para ler como se estivesse deslocado, use um √≠ndice 
                    convertido:

                        . esquerda: elemento ‚Äúvirtual‚Äù i vem de i+k

                        . direita: elemento ‚Äúvirtual‚Äù i vem de i-k

                    Isso √© √≥timo quando:

                        voc√™ s√≥ precisa ler

                        quer performance

                        quer evitar c√≥pias

            B) Shift f√≠sico criando nova lista

                Simples e leg√≠vel, mas usa mem√≥ria extra O(n).

            C) Shift f√≠sico in place

                Voc√™ realmente move elementos na mesma lista. √ötil quando:

                . precisa preservar o objeto (mesmo id)

                . quer economizar mem√≥ria

                . est√° implementando estruturas (buffer, fila, etc.)

        SHIFT IN PLACE (o ‚Äúcl√°ssico‚Äù com √≠ndices):

            Shift √† direita (k posi√ß√µes) preenchendo com fill

                Ideia: copiar de tr√°s pra frente para n√£o sobrescrever dados.

                Para i de n-1 at√© 0:
                    se i-k >= 0, a[i] = a[i-k]
                    sen√£o a[i] = fill

            Shift √† esquerda (k posi√ß√µes) preenchendo com fill

                Ideia: copiar da frente pra tr√°s.

                Para i de 0 at√© n-1:
                    se i+k < n, a[i] = a[i+k]
                    sen√£o a[i] = fill

                Essa l√≥gica √© exatamente ‚Äúmemmove‚Äù mental: escolher o sentido 
                para evitar sobrescrita.

        O custo (por que isso importa):

            Shift f√≠sico in place: O(n) tempo, O(1) mem√≥ria extra

            Shift criando nova lista: O(n) tempo, O(n) mem√≥ria

            Shift l√≥gico (s√≥ √≠ndice): O(1) mem√≥ria, O(1) por acesso

        Uso com loops e condicionais (padr√µes reais)

            A) ‚ÄúRemover‚Äù elementos do come√ßo sem pop(0) (que √© caro)

                Em listas, pop(0) √© O(n) porque desloca tudo.

                Um padr√£o melhor:

                    . manter um ponteiro start (shift l√≥gico)

                    . quando precisar ‚Äúcompactar‚Äù, a√≠ sim copia/recorta

            B) Buffer deslizante (janela fixa)

                Voc√™ mant√©m uma lista de tamanho k e ‚Äúshift‚Äù para inserir o
                novo no fim:

                    . shift √† esquerda 1

                    . coloca novo elemento no final

        Shift em outros iter√°veis:

            Strings/tuplas (imut√°veis)

                Voc√™ n√£o faz in place. S√≥:

                    . cria nova (slicing/concatena√ß√£o)

                    . ou faz acesso l√≥gico via √≠ndice

        Armadilhas comuns:

            . confundir shift com rota√ß√£o

            . mover no sentido errado e sobrescrever dados

            . esquecer o k maior que n (normalizar: k = min(k, n) para shift 
            ‚Äún√£o circular‚Äù)

            . usar pop(0) repetidamente em listas

    ======================================================================

    embaralhamento:

        - Embaralhamento √© a opera√ß√£o de reorganizar os elementos de uma 
        sequ√™ncia de forma aleat√≥ria, sem perder nem repetir elementos.

        Ou seja:

            todos os elementos continuam existindo

            apenas a ordem muda

            o objetivo √© aleatoriedade justa

        Embaralhar n√£o √©:

            ordenar

            rotacionar

            inverter

            particionar

        MODELO MENTAL CORRETO:

            Imagine cartas de baralho:

                voc√™ n√£o cria cartas novas

                n√£o remove cartas

                apenas muda a ordem

            Um bom embaralhamento faz todas as ordens poss√≠veis terem a mesma 
            chance.

        EMBARALHAMENTO ‚ÄúRUIM‚Äù √ó ‚ÄúCORRETO‚Äù:

            . Embaralhamento ing√™nuo (errado)

                    import random
                    random.shuffle(lista)

                . Isso funciona, mas n√£o explica o algoritmo.

                . E pior: muita gente tenta fazer assim:

                    for i in range(len(lista)):
                        j = random.randint(0, len(lista)-1)
                        lista[i], lista[j] = lista[j], lista[i]

                - Esse m√©todo N√ÉO √© uniforme

                - Algumas permuta√ß√µes t√™m mais chance que outras

                Isso √© um erro cl√°ssico.

        EMBARALHAMENTO CORRETO (FISHER‚ÄìYATES):

            - O √∫nico algoritmo simples e correto para embaralhar listas √© o 
            Fisher‚ÄìYates (ou Knuth shuffle).

            IDEIA CENTRAL DO FISHER‚ÄìYATES:

                Para cada posi√ß√£o:

                    escolha aleatoriamente um elemento ainda n√£o fixado

                    troque com a posi√ß√£o atual

                Cada elemento √© escolhido uma √∫nica vez.

            MODELO PASSO A PASSO (CONCEITUAL)

                Lista:

                    [1, 2, 3, 4]

                Passos:

                    1. escolha √≠ndice entre [0..3], troque com posi√ß√£o 3

                    2. escolha √≠ndice entre [0..2], troque com posi√ß√£o 2

                    3. escolha √≠ndice entre [0..1], troque com posi√ß√£o 1

                    A parte ‚Äúfinal‚Äù vai ficando fixa.

            POR QUE FUNCIONA?

                No passo i, existem exatamente i+1 escolhas v√°lidas

                Cada permuta√ß√£o poss√≠vel ocorre com probabilidade igual

                Prova matem√°tica simples (mas profunda)

            Isso garante aleatoriedade uniforme.

        EMBARALHAMENTO IN PLACE:

            Fisher‚ÄìYates:

                √© in place

                usa O(1) mem√≥ria extra

                roda em O(n)

            Perfeito para listas grandes.

        EMBARALHAMENTO E √çNDICES

            Tudo √© baseado em:

                √≠ndice atual

                √≠ndice aleat√≥rio dentro de um intervalo

                swap in place

            Sem √≠ndices, n√£o existe shuffle eficiente.

        EMBARALHAMENTO E PROBABILIDADE

            Um embaralhamento correto deve:

                gerar n! permuta√ß√µes poss√≠veis

                cada uma com probabilidade 1 / n!

            Se isso n√£o acontece ‚Üí algoritmo errado.

        ERROS COMUNS

            trocar com √≠ndice aleat√≥rio completo sempre

            usar sorted(..., key=random.random)

            achar que ‚Äúparece aleat√≥rio‚Äù √© suficiente

            usar shuffle sem entender impacto

        DICAS:

            Sempre fixe uma posi√ß√£o por vez

            Reduza o intervalo de escolha
            
            Use swap in place
            
            Pense: ‚Äúessa posi√ß√£o j√° est√° decidida?‚Äù

            Se n√£o conseguir explicar a probabilidade ‚Üí revise

        FRASES-CHAVE PARA MEMORIZAR:

            . Embaralhar √© permutar
            . Aleatoriedade precisa ser justa
            . Fisher‚ÄìYates √© o padr√£o
            . Swap + √≠ndice aleat√≥rio
            . In place e O(n)

    ======================================================================

    Listas, Arrays e Vetores circulares:

        LISTA / ARRAY / VETOR ‚Äî ALINHANDO OS TERMOS:

            | Termo     | O que significa                        |
            | --------- | -------------------------------------- |
            | **Vetor** | Estrutura sequencial indexada          |
            | **Array** | Vetor alocado contiguamente na mem√≥ria |
            | **Lista** | Estrutura sequencial de alto n√≠vel     |

        Em Python:

            list ‚âà array din√¢mico (cont√≠guo, redimension√°vel)

            mas com sem√¢ntica de lista de alto n√≠vel

        MODELO LINEAR (O PADR√ÉO):

            Modelo tradicional:

                √≠ndices:  0   1   2   3   4
                valores: [A | B | C | D | E]

            . tem come√ßo

            . tem fim

            . acessar fora ‚Üí erro

            Esse modelo n√£o √© circular.

        PROBLEMA DO MODELO LINEAR:

            Em muitas situa√ß√µes reais:

                dados chegam continuamente

                dados antigos saem

                voc√™ n√£o quer mover tudo

            Surge o modelo circular.

        VETOR / ARRAY CIRCULAR (ESS√äNCIA):

            - Um vetor circular √© uma estrutura que reaproveita o espa√ßo, 
            tratando o final como ligado ao in√≠cio.

            Visualmente:

                [A] ‚Üí [B] ‚Üí [C] ‚Üí [D]
                ‚Üë                 ‚Üì
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

            N√£o existe ‚Äúfim‚Äù l√≥gico ‚Äî s√≥ posi√ß√£o atual.

        A CHAVE DO CIRCULAR: M√ìDULO (%)

            Tudo se baseia em:

                √≠ndice_real = √≠ndice_l√≥gico % tamanho

            Exemplo:

                i = 6
                n = 5
                i % n = 1

            Esse % √© o que transforma linear em circular.

        ACESSO EM VETOR CIRCULAR

            Lista:

                lista = ['A','B','C','D','E']

            Acesso circular:

                lista[i % len(lista)]

            Exemplo:

                i = 5 ‚Üí A
                i = 6 ‚Üí B
                i = 7 ‚Üí C

            Nenhum erro, tudo reaproveitado.

        CIRCULAR ‚â† ROTA√á√ÉO:

            | Circular       | Rota√ß√£o           |
            | -------------- | ----------------- |
            | muda o acesso  | muda a estrutura  |
            | l√≥gico         | f√≠sico            |
            | n√£o move dados | move dados        |
            | usa `%`        | usa swap/revers√£o |

            Vetor circular n√£o rotaciona a lista, s√≥ muda o ponto de vista.

        FILA CIRCULAR (USO CL√ÅSSICO):

            Voc√™ mant√©m:

                head (in√≠cio)

                tail (fim)

            Inser√ß√£o:

                tail = (tail + 1) % n

            Remo√ß√£o:

                head = (head + 1) % n

            Nenhum elemento √© deslocado.

        VANTAGENS DO MODELO CIRCULAR:

            . O(1) para inserir/remover
            . Nenhum shift f√≠sico
            . Reuso de mem√≥ria
            . Ideal para streams

            Muito usado em sistemas operacionais e redes.

        CIRCULAR E JANELAS DESLIZANTES:

            Janela fixa:

                . voc√™ avan√ßa o √≠ndice

                . reaproveita posi√ß√µes antigas

                . mant√©m tamanho constante

                Buffer circular + janela = efici√™ncia m√°xima.

        CIRCULAR E SHIFT (CONEX√ÉO)

            Shift f√≠sico ‚Üí caro

            Circular ‚Üí s√≥ muda √≠ndice

            Exemplo:

                shift l√≥gico = start += 1

            Essa √© a ideia de shift l√≥gico circular.

        CIRCULAR E STRINGS

            Strings s√£o imut√°veis:

                circular s√≥ pode ser l√≥gico

                acesso via %

                    s[(i + k) % len(s)]

        ERROS COMUNS

            confundir circular com rota√ß√£o

            esquecer %

            misturar √≠ndice l√≥gico com real

            tentar usar circular sem ponteiros (head, tail)

            fazer shift f√≠sico desnecess√°rio

        QUANDO USAR CIRCULAR

            Use quando:

                dados s√£o cont√≠nuos

                tamanho √© fixo

                voc√™ descarta os mais antigos

                desempenho importa

            N√£o use quando:

                precisa de ordem linear fixa

                precisa de slicing frequente

                dados s√£o pequenos e simples

        FRASES-CHAVE PARA MEMORIZAR

            . Circular reaproveita mem√≥ria
            . Final liga ao come√ßo
            . M√≥dulo √© a chave
            . N√£o move dados
            . Troca estrutura por l√≥gica

    =====================================================================

    Matrizes:

        - Estrutura bidimensional, matem√°tica + computa√ß√£o

        O QUE √â UMA MATRIZ (CONCEITO FORMAL):

            - Uma matriz √© uma tabela bidimensional de elementos organizada em 
            linhas e colunas.
    
            Exemplo:

                A=[
                    1 2 3
                    4 5 6
                ]

            . Dimens√£o: 2 √ó 3

            . Elemento: ai,j
	
        - Em computa√ß√£o, uma matriz √© uma estrutura de dados indexada em duas 
        dimens√µes, usada para representar rela√ß√µes, grades, grafos, imagens, 
        estados e transforma√ß√µes.

        Em computa√ß√£o, matriz n√£o √© s√≥ matem√°tica, √© modelo de dados.

            Representa√ß√£o ex:

                matriz = [
                    [1, 2, 3],
                    [4, 5, 6]
                ]
        
        MATRIZ EM PYTHON (REPRESENTA√á√ÉO):

            Em Python:

                matriz = [
                    [1, 2, 3],
                    [4, 5, 6]
                ]

            . matriz = lista de listas

            . cada linha √© um objeto independente

            Nunca confundir com:

                mat = [[0]*3]*2  # ERRO CL√ÅSSICO

            (gera refer√™ncias duplicadas)

        √çNDICES EM MATRIZES:

            . mat[i][j]
            . i ‚Üí linha
            . j ‚Üí coluna

            Exemplo:

                mat[0][2]  # linha 0, coluna 2

            √çndices come√ßam em 0.

        MATRIZ ‚â† ARRAY MULTIDIMENSIONAL REAL:

            Conceito importante:

                Python: lista de listas (ponteiros)

                C / NumPy: mem√≥ria cont√≠gua

            Em Python:

                mat
                 ‚îú‚îÄ‚îÄ linha0 ‚Üí [1,2,3]
                 ‚îî‚îÄ‚îÄ linha1 ‚Üí [4,5,6]

            Cada linha pode ter tamanho diferente (matriz ‚Äúirregular‚Äù).

        MATRIZES NA MEM√ìRIA:

            Duas formas cl√°ssicas:

                - Row-major

                    . linhas consecutivas na mem√≥ria

                    . usado em C, Python, NumPy

                - Column-major

                    . colunas consecutivas

                    . usado em Fortran, MATLAB

            Impacta cache, desempenho e loops.

        PERCORRENDO MATRIZES (FORMA CORRETA):

            . Dois loops

                    for i in range(linhas):
                        for j in range(colunas):
                            processa(matriz[i][j])

                - Ordem importa para desempenho.

        OPERA√á√ïES FUNDAMENTAIS:

            - Leitura

                acesso O(1)

            - Escrita

                acesso O(1)

            - Inser√ß√£o/remo√ß√£o

                cara (O(n))

            Matrizes s√£o √≥timas para acesso direto, ruins para reestrutura√ß√£o.

        MATRIZ E PROGRAMA√á√ÉO DIN√ÇMICA:

            Exemplo mental:

                dp[i][j] = melhor resultado at√© (i,j)

            Quase todo DP 2D √© matriz.

        MATRIZ E GRAFOS:

            . Matriz de adjac√™ncia

                mat[i][j] = 1 se existe aresta

            acesso r√°pido

            mem√≥ria O(n¬≤)

        MATRIZ E IMAGENS:

            Imagem = matriz:

                . linhas ‚Üí altura

                . colunas ‚Üí largura

                . valor ‚Üí intensidade/cor

            Processamento de imagem = algoritmo em matriz.

        MATRIZES ESPARSAS:

            Muitas posi√ß√µes s√£o zero.

            Problema:

                desperdi√ßa mem√≥ria

            Solu√ß√µes:

                listas de coordenadas

                dicion√°rios

                formatos CSR/CSC

            Muito usadas em ML e grafos grandes.

        MATRIZES E IN PLACE:

            Opera√ß√µes poss√≠veis:

                altera√ß√£o de valores

                swap

                rota√ß√£o 90¬∞

                espelhamento

            Cuidado:

                opera√ß√µes in place exigem controle de √≠ndices

                erros s√£o comuns

        ROTA√á√ïES E TRANSFORMA√á√ïES:

            Exemplo:

                rota√ß√£o 90¬∞

                espelhamento horizontal/vertical

            Muito usado em jogos e imagens.

        MATRIZES IRREGULARES:

                [
                    [1, 2],
                    [3, 4, 5],
                    [6]
                ]

            . Permitidas em Python

            . N√£o existem em matem√°tica tradicional

        ERROS CL√ÅSSICOS (PROVA E VIDA REAL):

            . [[0]*n]*m
            . inverter i e j
            . estourar √≠ndice
            . esquecer limites
            . confundir linha/coluna
            . usar matriz quando vetor basta

        QUANDO USAR MATRIZ:

            Use quando:

                . dados s√£o bidimensionais
                . acesso r√°pido importa
                . rela√ß√µes cruzadas existem

            N√£o use quando:

                . dados s√£o lineares
                . estrutura √© esparsa
                . crescimento din√¢mico √© frequente

        FRASES-CHAVE PARA MEMORIZAR:

            . Matriz √© estrutura + matem√°tica
            . √çndice √© (linha, coluna)
            . Acesso √© O(1)
            . Mem√≥ria importa
            . Base de jogos, grafos e DP

    =====================================================================

    Swaps com Matrizes, formas poss√≠veis:

        Trocas estruturais em dados bidimensionais

        - Swap em matriz √© a troca controlada de posi√ß√µes, linhas, colunas ou 
        regi√µes inteiras, preservando a estrutura bidimensional.

        . Tudo √© feito com √≠ndices.

        . Pode ser local (elementos) ou estrutural (linhas/colunas).

        . Pode ser in place ou n√£o.

    SWAP DE ELEMENTOS:

        . Troca simples

                mat[i1][j1], mat[i2][j2] = mat[i2][j2], mat[i1][j1]

            Base de:

                . rota√ß√µes
                . espelhamentos
                . algoritmos em imagem
                . transforma√ß√µes geom√©tricas

        SWAP DE LINHAS:

            - Trocar duas linhas inteiras da matriz.

            Exemplo:

                Linha 0 ‚Üî Linha 2

            Forma direta (Python)

                mat[i], mat[j] = mat[j], mat[i]

            . O(1)
            . Muito r√°pido
            . Troca refer√™ncias das linhas

        SWAP DE COLUNAS:

            Colunas n√£o s√£o objetos separados em Python.

            Forma correta:

                for i in range(linhas):
                    mat[i][c1], mat[i][c2] = mat[i][c2], mat[i][c1]

            . O(n)
            . Exige loop
            . Muito comum em processamento de dados

        SWAP DE DIAGONAIS:

            . Diagonal principal ‚Üî secund√°ria (matriz quadrada)

            √çndices:

                principal: (i, i)

                secund√°ria: (i, n-1-i)

                for i in range(n):
                    mat[i][i], mat[i][n-1-i] = mat[i][n-1-i], mat[i][i]

            Usado em:

                . simetria
                . jogos
                . transforma√ß√µes visuais

        SWAP DE LINHA COM COLUNA:

            Trocar:

                linha i

                com coluna j

            PS: S√≥ faz sentido em matriz quadrada.

            . L√≥gica

                for k in range(n):
                    mat[i][k], mat[k][j] = mat[k][j], mat[i][k]

            Opera√ß√£o estrutural

            Exige cuidado extremo com sobrescrita

        SWAP DE COLUNA COM LINHA:

            (varia√ß√£o sem√¢ntica)

            √â o mesmo conceito acima, mas invertendo a inten√ß√£o:

                coluna vira linha

                linha vira coluna

            Muito pr√≥ximo de transposi√ß√£o parcial.

        SWAP DE √çNDICES (PERMUTA√á√ÉO DE LINHAS/COLUNAS):

            . Usando vetor de permuta√ß√£o

                ordem = [2, 0, 1]

            Aplica√ß√£o:

                nova_mat = [mat[i] for i in ordem]

            Muito usado em:

                . reorganiza√ß√£o de dados

                . machine learning

                . matrizes esparsas

        SWAP DE SUBMATRIZES:

            . Trocar blocos

            Exemplo:

                . quadrante superior esquerdo ‚Üî inferior direito

                    mat[i][j], mat[i+n][j+n] = mat[i+n][j+n], mat[i][j]

                Base de:

                    rota√ß√£o 90¬∞

                    espelhamentos

                    convolu√ß√µes

        SWAP PARA ROTA√á√ÉO DE MATRIZ

            . Rota√ß√£o 90¬∞ in place

            Etapas:

                1. Transpor

                2. Swap de colunas

            Todo algoritmo de rota√ß√£o usa swaps.

        SWAP EM MATRIZES IRREGULARES:

            S√≥ √© poss√≠vel:

                . swap de linhas

                . swap de elementos existentes

            Colunas podem n√£o existir em todas as linhas.

        SWAP L√ìGICO (SEM MOVER DADOS):

            Troca de acesso:

                def get(i, j):
                    return mat[j][i]

            Muito usado para:

                . simular transposi√ß√£o

                . evitar custo O(n¬≤)

        ERROS CL√ÅSSICOS:

            . confundir linha com coluna
            . tentar trocar colunas sem loop
            . sobrescrever dados
            . esquecer que Python troca refer√™ncias
            . usar swap onde bastava acesso l√≥gico

        DICAS:

            Pergunte sempre:

                Estou trocando valores ou estrutura?
                Isso √© quadrado ou retangular?
                Preciso ser in place?
                Trocar refer√™ncia resolve?
                Existe risco de sobrescrita?

        FRASES-CHAVE PARA MEMORIZAR:

            Linha √© objeto
            Coluna √© √≠ndice
            Swap pode ser estrutural
            Quadrada permite mais opera√ß√µes
            Swap √© base de rota√ß√£o

    =====================================================================

    Diagonais:

        - Diagonal √© uma sequ√™ncia de elementos que atravessa a matriz ligando 
        posi√ß√µes de mesmo ‚Äúdeslocamento‚Äù.

        - Diagonal √© um conjunto de posi√ß√µes definido por uma rela√ß√£o entre 
        √≠ndices (i, j).

        diagonal n√£o √© desenho, √© condi√ß√£o sobre √≠ndices.

        MATRIZ QUADRADA √ó N√ÉO QUADRADA:

            Importante:

                . Diagonal principal e secund√°ria s√≥ existem formalmente em 
                matrizes quadradas

                . Em matrizes retangulares, falamos em diagonais parciais

        DIAGONAL PRINCIPAL:

            Elementos onde:

                i == j

            Exemplo (3√ó3):

                [ X . . ]
                [ . X . ]
                [ . . X ]

            C√≥digo:

                mat[i][i]

            . Tamanho = N

        DIAGONAL SECUND√ÅRIA:

            Elementos onde:

                i + j == N - 1

            Exemplo:

                [ . . X ]
                [ . X . ]
                [ X . . ]

            C√≥digo:

                mat[i][N-1-i]

            S√≥ existe em matriz quadrada.

        OUTRAS DIAGONAIS:

            - Aqui entra o que muita gente nunca aprende direito.

            . Diagonais paralelas √† principal:

                Condi√ß√£o:

                    j - i = constante

                Exemplos:

                    . j - i = 0 ‚Üí diagonal principal
                    . j - i = 1 ‚Üí acima
                    . j - i = -1 ‚Üí abaixo

            . Diagonais paralelas √† secund√°ria

                Condi√ß√£o:

                    i + j = constante

                Exemplo:

                    . i + j = N - 1 ‚Üí diagonal secund√°ria
                    . i + j = N - 2, N, etc.

                    Base de v√°rios algoritmos de grade.
            
        PERCORRENDO DIAGONAIS (PADR√ïES):

            Diagonal principal:

                for i in range(n):
                    mat[i][i]

            Diagonal secund√°ria:

                for i in range(n):
                    mat[i][n-1-i]

            Diagonal geral (j - i = k):

                for i in range(n):
                    j = i + k
                    if 0 <= j < m:
                        mat[i][j]

        DIAGONAIS E MEM√ìRIA:

            . Diagonais n√£o s√£o cont√≠guas na mem√≥ria
            . Acesso salta linhas
            . Pode causar cache misses

            Em sistemas de alto desempenho, isso importa.

        OPERA√á√ïES COM DIAGONAIS:

            . Soma

                soma += mat[i][i]

            . Swap

                mat[i][i], mat[i][n-1-i] = mat[i][n-1-i], mat[i][i]

            . Zeragem

                mat[i][i] = 0

        DIAGONAIS E TRANSFORMA√á√ïES:

            . Transposi√ß√£o

                - diagonal principal vira eixo

                - A[i][j] = A[j][i]

                A diagonal principal √© fixa na transposi√ß√£o.

            . Simetria

                - matriz sim√©trica ‚Üí A[i][j] == A[j][i]

                Conceito central em √°lgebra linear.

        DIAGONAIS L√ìGICAS:

            Voc√™ pode:

                . n√£o percorrer a diagonal fisicamente

                . apenas testar condi√ß√£o

                    if i == j:
                        ...

                Isso evita custo extra.

        ERROS CL√ÅSSICOS:

            . confundir diagonal com linha
            . errar N-1-i
            . esquecer que s√≥ existe em quadradas
            . usar diagonal quando n√£o faz sentido
            . inverter i e j

        DICAS:

            Sempre pergunte:

                Essa matriz √© quadrada?
                Estou falando de qual diagonal?
                A condi√ß√£o √© i==j, i+j, ou j-i?
                Preciso percorrer ou s√≥ testar?
                Ordem de acesso importa?

        FRASES-CHAVE PARA MEMORIZAR:

            Diagonal √© rela√ß√£o de √≠ndices
            Principal: i == j
            Secund√°ria: i + j = N - 1
            Outras diagonais existem
            Muito usadas em DP

    =====================================================================

    Transposi√ß√£o de matriz:

        - Trocar linhas por colunas

        - A transposta de uma matriz A √© a matriz A**T obtida trocando linhas 
        por colunas.

        Se:

            A
             i,j
            
        Ent√£o:
             T
            A‚Äã      ‚Äã=      A
             i,j           i,j

        Exemplo:

            A =
            1 2 3
            4 5 6

            A·µÄ =
            1 4
            2 5
            3 6

        E em computa√ß√£o?

            - Transpor √©:

                trocar eixos

                mudar o significado do acesso

                reorganizar dados 2D

            Em termos de √≠ndices:

                (i, j) ‚Üí (j, i)

        TRANSPOSI√á√ÉO ‚â† ROTA√á√ÉO:

            | Opera√ß√£o        | O que faz                     |
            | --------------- | ----------------------------- |
            | Transposi√ß√£o    | espelha na diagonal principal |
            | Rota√ß√£o         | muda orienta√ß√£o               |
            | Swap de linhas  | troca linhas                  |
            | Swap de colunas | troca colunas                 |

            Muitas pessoas confundem isso.

        FORMAS DE IMPLEMENTAR TRANSPOSI√á√ÉO:

            1) TRANSPOSI√á√ÉO CRIANDO NOVA MATRIZ (CL√ÅSSICA)

                - Funciona para qualquer matriz (retangular ou quadrada).

                Ideia:

                    T[j][i] = A[i][j]

                Em Python puro:

                    T = []
                    for j in range(colunas):
                        linha = []
                        for i in range(linhas):
                            linha.append(A[i][j])
                        T.append(linha)

                . O(n √ó m)

                . Usa mem√≥ria extra

            2) TRANSPOSI√á√ÉO IN PLACE (S√ì MATRIZ QUADRADA)

                - Muito importante para CS/SE.

                S√≥ funciona se:

                    N x N

                Porque:

                    n√∫mero de linhas = n√∫mero de colunas

                Ideia central:

                    mat[i][j] ‚Üî mat[j][i]

                Mas:

                    s√≥ para metade da matriz

                    sen√£o voc√™ desfaz a troca

                Forma correta:

                    for i in range(n):
                        for j in range(i + 1, n):
                            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]

                . Diagonal principal √© eixo

                . N√£o mexe nela

        TRANSPOSI√á√ÉO E DIAGONAIS:

            . diagonal principal fica fixa

            . tudo √© espelhado em rela√ß√£o a ela

            Por isso:

                for j in range(i+1, n)

        TRANSPOSI√á√ÉO E MEM√ìRIA (PONTO DE SE):

            . Python (lista de listas)

                - cada linha √© um objeto
                - acesso mat[j][i] pula refer√™ncias

            . C / NumPy:

                - mem√≥ria cont√≠gua
                - ordem de acesso impacta cache

            . Em sistemas grandes, transposi√ß√£o √© cara.

        TRANSPOSI√á√ÉO COMO OPERA√á√ÉO L√ìGICA:

            - √Äs vezes voc√™ n√£o precisa transpor fisicamente.

            Exemplo:

                def get(i, j):
                    return mat[j][i]

            Isso simula transposi√ß√£o sem custo O(n¬≤).
        
        TRANSPOSI√á√ÉO + SWAP:

            Seu exerc√≠cio de swap:

                mat[i][i] ‚Üî mat[i][c]

            Na transposi√ß√£o:

                mat[i][j] ‚Üî mat[j][i]

            √â o mesmo padr√£o mental:

                trocar posi√ß√µes sim√©tricas

                controlar √≠ndices

                evitar sobrescrita

        ERROS CL√ÅSSICOS:

            tentar in place em matriz n√£o quadrada

            esquecer j > i

            trocar diagonal duas vezes

            confundir transposi√ß√£o com rota√ß√£o

            usar libs sem entender
        
        DICAS:

            Pergunte sempre:

                A matriz √© quadrada?
                Quero in place ou c√≥pia?
                Posso simular transposi√ß√£o?
                A diagonal √© eixo ou alvo?
                O custo importa?

            FRASES-CHAVE PARA MEMORIZAR:

                . Transpor √© trocar eixos
                . (i,j) vira (j,i)
                . In place s√≥ em quadradas
                . Diagonal √© o eixo
                . Swap √© a base

    =====================================================================

    Matriz sim√©trica e assim√©trica:

        Espelhamento estrutural em dados bidimensionais

        Uma matriz A √© sim√©trica se:

                 t
            A = A
        
        Ou seja:

            A       =       A
             i,j             j,i

        A matriz precisa ser quadrada.

        Exemplo:

            2  3  5
            3  7  9
            5  9  1

        Observe:

            (0,1) = (1,0)

            (0,2) = (2,0)

        O QUE √â UMA MATRIZ ASSIM√âTRICA?

            - Aqui existem dois sentidos (muito importante).

            2.1 Assim√©trica (sentido geral / informal)

                . A matriz n√£o √© sim√©trica.

                Basta:

                    A[i][j] ‚â† A[j][i] para algum par

                √â o uso mais comum em programa√ß√£o.

            2.2 Anti-sim√©trica (sentido matem√°tico rigoroso):

                - Uma matriz A √© anti-sim√©trica se:

                     T
                    A = ‚àíA

                Ou seja:

                    A ‚Äã     =   ‚àíA
                     i,j         j,i

                E:

                    . todos os elementos da diagonal principal s√£o zero

                    Tamb√©m exige matriz quadrada.

                Exemplo anti-sim√©trico

                    0   2  -1
                    -2   0   4
                    1  -4   0

        DIAGONAL PRINCIPAL (PONTO-CHAVE):

            | Tipo           | Diagonal       |
            | -------------- | -------------- |
            | Sim√©trica      | qualquer valor |
            | Anti-sim√©trica | sempre zero    |

            Isso √© um teste r√°pido.

        COMO VERIFICAR SE UMA MATRIZ √â SIM√âTRICA:

            L√≥gica:

                Voc√™ n√£o precisa comparar tudo.

                Basta verificar:

                    i < j

                Porque:

                    . o outro lado √© espelho
            
                Pseudoc√≥digo:

                    para i de 0 at√© n-1:
                        para j de i+1 at√© n-1:
                            se A[i][j] != A[j][i]:
                                n√£o √© sim√©trica

                Complexidade: O(n¬≤ / 2).
        
        COMO VERIFICAR MATRIZ ANTI-SIM√âTRICA:

            Condi√ß√µes:

                A[i][i] == 0

                A[i][j] == -A[j][i]

        SIMETRIA E MEM√ìRIA:

            Em matriz sim√©trica:

                - metade dos dados √© redundante

            Voc√™ pode armazenar:

                . apenas tri√¢ngulo superior

                . ou inferior

            Isso reduz mem√≥ria quase pela metade.

        SIMETRIA EM PROGRAMA√á√ÉO DIN√ÇMICA:

            Exemplo:

                dp[i][j] = dp[j][i]

            Permite otimiza√ß√µes e poda de estados.

        SIMETRIA E SWAPS:

            Se voc√™ fizer:

                mat[i][j], mat[j][i] = mat[j][i], mat[i][j]

            Voc√™ est√° for√ßando simetria (ou quebrando).

        ERROS CL√ÅSSICOS

            testar simetria em matriz n√£o quadrada

            comparar tudo (ineficiente)

            confundir anti-sim√©trica com ‚Äún√£o sim√©trica‚Äù

            esquecer diagonal no caso anti-sim√©trico

            usar igualdade exata com floats

        DICAS:

            Pergunte sempre:

                A matriz √© quadrada?

                O crit√©rio √© igualdade ou nega√ß√£o?

                Preciso testar tudo ou metade?

                A diagonal importa?

                Isso √© propriedade ou opera√ß√£o?

        FRASES-CHAVE PARA MEMORIZAR

            . Sim√©trica espelha
            . Anti-sim√©trica inverte sinal
            . Diagonal √© eixo
            . Metade da matriz basta
            . Grafo explica tudo

    =====================================================================

    Matriz quadada e n√£o quadrada:

        - Uma matriz √© quadrada quando o n√∫mero de linhas √© igual ao n√∫mero de 
        colunas.

            A ‚àà R**n√ón

        Exemplos:

            2√ó2
            3√ó3
            100√ó100

                [ a b c ]
                [ d e f ]
                [ g h i ]

        DIFEREN√áA CONCEITUAL (O MAIS IMPORTANTE):

            | Aspecto               | Quadrada | N√£o quadrada  |
            | --------------------- | -------- | ------------- |
            | Linhas = Colunas      | ‚úî        | ‚ùå            |
            | Diagonal principal    | ‚úî        | ‚ùå (formal)   |
            | Transposi√ß√£o in place | ‚úî        | ‚ùå            |
            | Simetria              | ‚úî        | ‚ùå            |
            | Anti-simetria         | ‚úî        | ‚ùå            |
            | Determinante          | ‚úî        | ‚ùå            |
            | Inversa               | ‚úî        | ‚ùå            |
            | Autovalores           | ‚úî        | ‚ùå            |

            90% das propriedades ‚Äúavan√ßadas‚Äù s√≥ existem em matrizes quadradas.

        DIAGONAIS: QUEM TEM E QUEM N√ÉO TEM

            Matriz quadrada:

                diagonal principal ‚Üí mat[i][i]
                diagonal secund√°ria ‚Üí mat[i][n-1-i]
                diagonais paralelas ‚Üí bem definidas

            Matriz n√£o quadrada:

                n√£o h√° diagonal ‚Äúcompleta‚Äù
                existem diagonais parciais
                condi√ß√µes como i == j s√≥ valem enquanto √≠ndices existirem

            Em computa√ß√£o, voc√™ pode percorrer, mas n√£o pode aplicar 
            propriedades matem√°ticas cl√°ssicas.

        TRANSPOSI√á√ÉO: LIMITES CLAROS

            . Quadrada

                transposi√ß√£o in place poss√≠vel
                swap mat[i][j] ‚Üî mat[j][i]

            . N√£o quadrada

                transposi√ß√£o cria nova matriz
                dimens√µes mudam: m√ón ‚Üí n√óm

            Tentar in place aqui √© erro conceitual, n√£o s√≥ t√©cnico.

        SIMETRIA E ANTI-SIMETRIA:

            . S√≥ fazem sentido em matrizes quadradas

            Porque:

                A[i][j] precisa ser comparado com A[j][i]

            Se j n√£o existe como linha ‚Üí imposs√≠vel.

            Em computa√ß√£o, qualquer ‚Äúverifica√ß√£o de simetria‚Äù exige matriz 
            quadrada.
        
        SWAPS: O QUE MUDA

            . Swap de linhas

                - funciona em qualquer matriz

                    mat[i], mat[j] = mat[j], mat[i]

            . Swap de colunas

                - funciona em qualquer matriz (com cuidado)

                    for r in range(linhas):
                        mat[r][c1], mat[r][c2] = mat[r][c2], mat[r][c1]

            . Swap linha ‚Üî coluna

                - s√≥ em matriz quadrada

                Porque:

                    . Linha tem n elementos
                    . coluna precisa ter n posi√ß√µes

        MATRIZ QUADRADA COMO TRANSFORMA√á√ÉO:

            Em matem√°tica e computa√ß√£o:

                . matriz quadrada representa transforma√ß√µes
                . entrada e sa√≠da t√™m mesma dimens√£o

            Estruturalmente, quadrada = transforma√ß√£o do espa√ßo em si mesmo.

        MATRIZ N√ÉO QUADRADA COMO RELA√á√ÉO:

            Matrizes n√£o quadradas modelam:

                . rela√ß√µes entre conjuntos diferentes
                . dados tabulares
                . datasets
                . proje√ß√µes

            Estruturalmente, n√£o quadrada = mapeamento entre espa√ßos distintos.

        MATRIZES E GRAFOS:

            | Tipo de grafo   | Matriz                 |
            | --------------- | ---------------------- |
            | N√£o direcionado | Quadrada e sim√©trica   |
            | Direcionado     | Quadrada e assim√©trica |
            | Bipartido       | N√£o quadrada           |

            Excelente modelo mental.

        MATRIZES E MEM√ìRIA:

            Quadradas:

                . padr√µes de acesso mais previs√≠veis
                . opera√ß√µes sim√©tricas
                . cache-friendly em muitos algoritmos

            N√£o quadradas:

                . acesso mais irregular
                . transposi√ß√£o muda dimens√£o
                . cuidado com ordem dos loops

        ERROS CL√ÅSSICOS:

            tentar acessar mat[i][i] em matriz n√£o quadrada

            assumir simetria sem checar dimens√£o

            tentar transposi√ß√£o in place errada

            aplicar f√≥rmula de diagonal inv√°lida

            misturar linha/coluna por h√°bito

        DICAS:

            Antes de qualquer algoritmo, pergunte:

                Essa matriz √© quadrada?

                Estou usando alguma propriedade que exige isso?

                Transposi√ß√£o muda dimens√£o?

                Linha e coluna t√™m o mesmo tamanho?

                Estou pensando em transforma√ß√£o ou rela√ß√£o?

            Essas perguntas evitam bugs conceituais.

        FRASES-CHAVE PARA MEMORIZAR:

            . Quadrada transforma
            . N√£o quadrada relaciona
            . Diagonal exige quadrada
            . Simetria exige quadrada
            . In place exige quadrada

    =====================================================================

    Matriz circular:

        - Uma matriz circular √© uma matriz em que o acesso aos √≠ndices √© 
        tratado de forma circular, ou seja, sair por um lado faz voc√™ entrar 
        pelo lado oposto.

        Importante:

            . A matriz n√£o muda fisicamente
            . O que muda √© a forma de acessar os √≠ndices

        MODELO MENTAL CORRETO:

            Pense na matriz como um tabuleiro em forma de toro (donut):

                . saiu por cima ‚Üí entra por baixo
                . saiu pela esquerda ‚Üí entra pela direita

            Visualmente (2D circular):

                ‚Üë conecta ‚Üì
                ‚Üê conecta ‚Üí

        MATRIZ LINEAR √ó MATRIZ CIRCULAR:

            | Aspecto                | Linear | Circular       |
            | ---------------------- | ------ | -------------- |
            | √çndices fora do limite | Erro   | Reaproveitados |
            | Uso de `%`             | ‚ùå     | ‚úî              |
            | Estrutura muda         | ‚ùå     | ‚ùå             |
            | Acesso l√≥gico muda     | ‚ùå     | ‚úî              |

            Circularidade √© l√≥gica, n√£o estrutural.

        A CHAVE: M√ìDULO (%):

            - Tudo em matriz circular se baseia em:

                i_circular = i % linhas
                j_circular = j % colunas

            Isso garante:

                . -1 % n ‚Üí √∫ltimo √≠ndice
                . n % n ‚Üí 0

        ACESSO CIRCULAR B√ÅSICO:

                def get(mat, i, j):
                    linhas = len(mat)
                    colunas = len(mat[0])
                    return mat[i % linhas][j % colunas]

            . Esse get transforma qualquer matriz comum em circular.

        MATRIZ CIRCULAR ‚â† ROTA√á√ÉO DE MATRIZ

            | Matriz Circular | Rota√ß√£o        |
            | --------------- | -------------- |
            | muda acesso     | muda estrutura |
            | usa `%`         | usa swaps      |
            | l√≥gica          | f√≠sica         |
            | O(1)            | O(n¬≤)          |

            Matriz circular n√£o move dados.

        VIZINHAN√áA CIRCULAR:

            Em grids, voc√™ costuma acessar vizinhos:

                cima, baixo, esquerda, direita

            Em matriz circular:

                cima     = mat[(i-1) % L][j]
                baixo    = mat[(i+1) % L][j]
                esquerda = mat[i][(j-1) % C]
                direita  = mat[i][(j+1) % C]

            Sem if, sem borda especial.

        MATRIZ CIRCULAR E JANELAS 2D:

            Janela 3√ó3 ao redor de (i,j):

                for di in (-1, 0, 1):
                    for dj in (-1, 0, 1):
                        viz = mat[(i+di) % L][(j+dj) % C]

            . Padr√£o extremamente importante.

        MATRIZ CIRCULAR E SHIFT / ROTA√á√ÉO:

            . shift f√≠sico ‚Üí caro
            . rota√ß√£o f√≠sica ‚Üí cara
            . matriz circular ‚Üí s√≥ √≠ndice

        Exemplo:

            novo_i = (i + deslocamento) % L

        √â a generaliza√ß√£o 2D do vetor circular.

        IMPLEMENTA√á√ÉO F√çSICA √ó L√ìGICA:

            . Circular l√≥gica (preferida)

                usa %

                O(1)

                simples

            . Circular f√≠sica

                usa swaps/rota√ß√µes

                raramente necess√°ria

                mais complexa

        ERROS COMUNS:

            tentar ‚Äúcriar‚Äù matriz circular

            esquecer % em um dos eixos

            confundir rota√ß√£o com circularidade

            usar if desnecess√°rio

            n√£o tratar colunas diferentes de linhas

        DICAS:

            Antes de codar, pergunte:

                Quero mover dados ou s√≥ mudar acesso?

                    As bordas devem se conectar?

                    Posso usar %?

                    Isso √© 1D ou 2D?

                    Circular resolve sem if?

                Se sim ‚Üí matriz circular.

        FRASES-CHAVE PARA MEMORIZAR:

            . Circular √© l√≥gica
            . M√≥dulo conecta bordas
            . N√£o move dados
            . Excelente para grids
            . Evita condi√ß√µes

    =====================================================================

    Tuplas:

        - Tupla √© uma sequ√™ncia ordenada e imut√°vel de elementos.

        . Ordenada: tem posi√ß√£o (√≠ndice).

        . Imut√°vel: depois de criada, voc√™ n√£o altera t[i] = ... (d√° erro).

        . Pode conter tipos misturados: int, str, lista, outra tupla‚Ä¶

        Uso mental:

            ‚Äúquero agrupar valores que pertencem juntos e n√£o devem mudar‚Äù.

        Exemplos:

            . coordenada (x, y)
            . RGB (r, g, b)
            . registro simples (nome, idade, cidade)
            . retorno m√∫ltiplo de fun√ß√£o

        Criando tuplas (detalhe importante):

            EX:

                t1 = (1, 2, 3)
                t2 = 1, 2, 3          # par√™nteses s√£o opcionais
                t3 = (5,)             # tupla de 1 elemento TEM v√≠rgula
                t4 = ()               # tupla vazia

            Erro comum:

                (5)    # isso √© int, n√£o tupla

        √çndices de tuplas:

            Tuplas suportam:

                . √≠ndice positivo e negativo

                    t = ("a", "b", "c")
                    t[0]   # "a"
                    t[-1]  # "c"

        Tamanho de tupla:

            len(t)

        Slicing:

            - Tupla suporta slicing igual lista/string:

                t[1:4]
                t[:3]
                t[::2]
                t[::-1]

            Slicing cria nova tupla (n√£o √© in place).

        M√©todos ‚Äúespeciais‚Äù de tupla:

            - A tupla tem poucos m√©todos ‚Äúnormais‚Äù:

                t.count(x)
                t.index(x)

            Mas ela tem v√°rias propriedades comportamentais importantes:

                . √© hashable se todos os elementos forem hashable (isso permite 
                usar como chave de dict)

                . √© iter√°vel

                . suporta compara√ß√£o lexicogr√°fica

        Compara√ß√£o lexicogr√°fica (muito √∫til):

            (1, 2) < (1, 3)   # True
            (1, 2) < (0, 9)   # False

        Empacotamento e desempacotamento:

            Empacotamento:

                ponto = 10, 20

            Desempacotamento:

                x, y = ponto

            Desempacotamento com ‚Äúresto‚Äù:

                a, *meio, b = (1, 2, 3, 4, 5)
                # a=1, meio=[2,3,4], b=5

            - *meio vira lista por padr√£o.

        Tuplas com outros iter√°veis e com listas:

            Tupla pode conter lista:

                t = (1, [2, 3], 4)

            PS: Imut√°vel n√£o significa ‚Äútudo dentro √© imut√°vel‚Äù.

            Voc√™ n√£o troca t[1], mas pode modificar a lista dentro:

                t[1].append(99)

            Convers√µes (casting):

                tuple([1, 2, 3])       # (1,2,3)
                list((1, 2, 3))        # [1,2,3]
                tuple("abc")           # ('a','b','c')

        Tupla com loops e condi√ß√µes:

            Tupla √© iter√°vel:

                for x in t:
                    ...

            Com condi√ß√£o:

                for x in t:
                    if x > 0:
                        ...

            Com enumerate:

                for i, x in enumerate(t):
                    ...

        Return de dois ou mais dados:

            - Em Python, ‚Äúretornar v√°rios valores‚Äù √© retornar uma tupla:

                    def stats(a, b):
                        return a + b, a * b   # tupla

                    soma, prod = stats(2, 3)

                . Isso √© empacotamento + desempacotamento.

        Concatena√ß√£o de tupla:

                (1, 2) + (3, 4)   # (1,2,3,4)

            PS: Cria nova tupla.

        Repeti√ß√£o de tuplas:

                (1, 2) * 3  # (1,2,1,2,1,2)

            PS: Cuidado com repeti√ß√£o quando a tupla cont√©m listas:

                t = ([0],) * 3
                # repete a MESMA lista 3 vezes (mesma refer√™ncia)

        Tuplas aninhadas:

                t = ((1, 2), (3, 4))
                t[0]      # (1, 2)
                t[0][1]   # 2

            Muito usada para:

                . pontos 2D
                . tabelas fixas
                . ‚Äúregistros‚Äù simples

        Casting para tuplas e de tuplas para outros tipos:

            - J√° vimos tuple() e list(). Tamb√©m:

                set((1, 2, 2))  # {1,2}
                str((1, 2))     # "(1, 2)"

        Ordena√ß√£o de tuplas com sorted:

            - Ordenar lista de tuplas

            Muito comum:

                dados = [("Ana", 20), ("Jo√£o", 18), ("Bia", 25)]
                sorted(dados)  # ordena por nome (primeiro item)

            Por outro campo:

                sorted(dados, key=lambda x: x[1])  # ordena por idade

            . sorted retorna lista, mesmo que a entrada seja tupla.

            Se quiser tupla:

                tuple(sorted(dados))

        ‚ÄúCoisas legais‚Äù com tuplas:

            A) Tupla como ‚Äúregistro leve‚Äù

                usuario = ("Renato", 17, "SP")
                nome, idade, cidade = usuario

            B) Tupla como chave de dicion√°rio (muito poderoso)

                - Se todos os itens forem hashable:

                    visitas = {}
                    pos = (2, 5)          # coordenada
                    visitas[pos] = 1

                Isso √© base de:

                    . grids
                    . grafos
                    . memoization (cache)
                    . mapas 2D usando dict

            C) ‚ÄúIdeia de dicion√°rio com tuplas‚Äù (pares)

                Uma estrutura estilo dicion√°rio pode ser:

                    pares = (("a", 1), ("b", 2), ("c", 3))

                E voc√™ pode converter:

                    d = dict(pares)

                Ou buscar manualmente (menos eficiente):

                    for k, v in pares:
                        if k == "b":
                            ...

            D) Swap e m√∫ltiplas atribui√ß√µes (tuplas por tr√°s)

                a, b = b, a

        Erros comuns:

            . esquecer a v√≠rgula da tupla de 1 elemento: (5,)
            . achar que tupla ‚Äúcongela‚Äù objetos mut√°veis dentro
            . repetir tupla com listas e criar refer√™ncias duplicadas
            . tentar modificar t[i]

    =====================================================================

    Dicion√°rios:

        - Um dicion√°rio √© uma estrutura que associa uma chave a um valor.

        Formalmente:

            chave ‚Üí valor

        Exemplo:

            usuario = {
                "nome": "Renato",
                "idade": 17,
                "cidade": "SP"
            }

        Diferente de listas/tuplas:

            . acesso n√£o √© posicional

            . acesso √© por identidade (chave)

        ESTRUTURA INTERNA:

            Dicion√°rios s√£o implementados com tabelas hash.

                . A chave passa por uma fun√ß√£o hash()

                . O hash define onde o valor √© armazenado

                . Busca m√©dia: O(1)

            Isso √© MUITO mais r√°pido que listas para busca por chave.

        DEFINI√á√ïES IMPORTANTES:

            Chave:

                - deve ser imut√°vel
                - deve ser hashable
                - exemplos: str, int, float, tuple (imut√°vel)

            Valor:

                - pode ser qualquer tipo
                - mut√°vel ou n√£o

            EX:

                { (1, 2): "posi√ß√£o" }   # v√°lido
                { [1, 2]: "posi√ß√£o" }  # ERRO

        CHAVE √ó √çNDICE (EFICI√äNCIA):

            | Estrutura               | Acesso |
            | ----------------------- | ------ |
            | Lista (√≠ndice)          | O(1)   |
            | Lista (busca por valor) | O(n)   |
            | Dicion√°rio (chave)      | O(1)   |

            Pergunta mental:

                ‚ÄúTenho um identificador l√≥gico?‚Äù ‚Üí dicion√°rio

        PROPRIEDADES DOS DICION√ÅRIOS:

            . N√£o permitem chaves duplicadas
            . Inser√ß√£o sobrescreve valor
            . Mant√™m ordem de inser√ß√£o (Python 3.7+)
            . Mut√°veis
            . Iter√°veis

        M√©todos principais de dicion√°rios:

            1) Acesso e leitura:

                . d[key]

                    Acessa o valor. Se a chave n√£o existir ‚Üí KeyError.

                . d.get(key, default=None)

                    Acessa sem erro; se n√£o existir, retorna default.
                    Muito usado para evitar if key in d.

                . d.keys()

                    ‚Äúview‚Äù das chaves (n√£o √© lista). Iter√°vel.
                
                . d.values()

                    ‚Äúview‚Äù dos valores.

                . d.items()

                    ‚Äúview‚Äù de pares (chave, valor) ‚Äî perfeito para loops e sorted.

                As views (keys/values/items) refletem mudan√ßas no dicion√°rio 
                em tempo real.

            2) Inser√ß√£o / atualiza√ß√£o:

                . d[key] = value

                    Insere ou sobrescreve.

                . d.update(outro_dict | iterable_de_pares, **kwargs)

                    Faz ‚Äúmerge‚Äù/atualiza√ß√£o. Chaves repetidas s√£o sobrescritas 
                    pelo q

                    Ex:

                        d.update({"a": 1, "b": 2})
                        d.update([("c", 3), ("d", 4)])
                        d.update(e=5, f=6)

                . Operador de merge (Python 3.9+)

                    d1 | d2 ‚Üí cria novo dict mesclado

                    d1 |= d2 ‚Üí atualiza in place

            3) Remo√ß√£o:

                . del d[key]

                    Remove a chave (se n√£o existir ‚Üí KeyError).

                . d.pop(key, default=_sem)

                    Remove e retorna o valor. Se n√£o existir:

                        sem default ‚Üí KeyError

                        com default ‚Üí retorna default
                
                . d.popitem()

                    Remove e retorna um par (key, value).
                    
                    Hoje remove o √∫ltimo inserido (LIFO).

                    √ötil para consumir/‚Äúdesempilhar‚Äù itens.

                . d.clear()

                    Remove tudo.

            4) Cria√ß√£o e padr√µes √∫teis:

                . dict.fromkeys(iterable, value=None)

                    Cria um dict com chaves vindas do iter√°vel e o mesmo valor 
                    para todas.

                    EX:

                        d = dict.fromkeys(["a", "b", "c"], 0)  # {"a":0, "b":0, "c":0}

                    Cuidado com valor mut√°vel:

                        d = dict.fromkeys(["a","b"], [])  # MESMA lista para as duas chaves

                . d.setdefault(key, default=None)

                    Se a chave existir, retorna o valor.

                    Se n√£o existir, cria com default e retorna default.

                    Muito usado para ‚Äúacumular‚Äù:

                        d.setdefault(chave, []).append(valor)

        Opera√ß√µes/‚Äúfun√ß√µes especiais‚Äù (comportamento do dict):

            1) Pertin√™ncia

                key in d (testa chave, n√£o valor)
                key not in d

            2) Tamanho e itera√ß√£o

                len(d)

                for k in d: itera chaves

                for k, v in d.items(): pares

            3) C√≥pia

                d.copy() ‚Üí c√≥pia rasa (shallow)
                {**d} e d | {} tamb√©m criam c√≥pia rasa

            4) Compara√ß√£o

                d1 == d2 compara por conte√∫do (chaves/valores), n√£o por ordem

                d1 is d2 compara identidade (mesmo objeto)

            5) Ordena√ß√£o

                Dicion√°rio n√£o ‚Äúse ordena‚Äù por m√©todo pr√≥prio; voc√™ ordena os 
                itens:

                    sorted(d.items())  # por chave
                    sorted(d.items(), key=lambda kv: kv[1])  # por valor

                E se quiser de volta dict:

                    d_ordenado = dict(sorted(d.items()))

        Padr√µes de uso:

            1) Contagem (histograma)

                Padr√£o com get:

                    d[x] = d.get(x, 0) + 1

                ou com setdefault.

            2) Agrupamento

                grupos.setdefault(chave, []).append(item)

            3) Tabela de decis√£o (dispatch)

                acoes = {"soma": soma, "sub": sub}
                acoes.get(op, erro)()

            4) ‚ÄúMerge‚Äù de configura√ß√µes

                config = padrao | usuario

        DICION√ÅRIOS COM LOOPS E CONDI√á√ïES:

            . Iterar chaves:

                for k in d:
                    ...

            . Iterar valores:

                for v in d.values():
                    ...

            . Iterar pares:

                for k, v in d.items():
                    ...

            . Condi√ß√µes:

                if "idade" in usuario:
                    ...

        kwargs (IMPORTANT√çSSIMO):

            Em fun√ß√µes:

                def f(**kwargs):
                    print(kwargs)

            Chamada:

                f(nome="Ana", idade=20)

            kwargs √© um dicion√°rio.

        EMPACOTAMENTO E DESEMPACOTAMENTO:

            . Desempacotar em fun√ß√£o

                dados = {"a":1, "b":2}
                f(**dados)

            . Unir dicion√°rios

                novo = {**d1, **d2}

            Ordem importa ‚Üí sobrescrita.

        DICION√ÅRIOS ANINHADOS:

            EX:

                usuarios = {
                    "u1": {"nome":"Ana", "idade":20},
                    "u2": {"nome":"Jo√£o", "idade":30}
                }

            Acesso:

                usuarios["u1"]["idade"]

            Base de JSON, APIs e configs.

        DICION√ÅRIOS COM OUTROS ITER√ÅVEIS:

            . Lista de tuplas

                dict([("a",1), ("b",2)])

            . Zip

                dict(zip(chaves, valores))

        SOBRESCRITA (CUIDADO!):

                d = {"a":1}
                d["a"] = 99

            . N√£o cria nova chave, substitui.

        SWAP COM DICION√ÅRIOS:

            swap de valores:

                d["a"], d["b"] = d["b"], d["a"]

            Trocar chaves (menos comum):

                exige reconstru√ß√£o

            swap em dict √© l√≥gico, n√£o estrutural.

        M√âTODO dict() (VERS√ÅTIL):

            EX:

                dict(a=1, b=2)
                dict([("a",1), ("b",2)])

            Muito usado em APIs e convers√µes.

        DICION√ÅRIO INVERTIDO:

                inv = {v: k for k, v in d.items()}

            . S√≥ funciona se os valores forem:

                . √∫nicos

                . hashable

        DICION√ÅRIO ORDENADO:

            Desde Python 3.7+:

                dict mant√©m ordem de inser√ß√£o

            Para ordenar:

                dict(sorted(d.items()))

            Ou por valor:

                dict(sorted(d.items(), key=lambda x: x[1]))

        DICION√ÅRIO COM FUN√á√ïES (ESTRAT√âGIA):

            EX:

                ops = {
                    "soma": lambda a,b: a+b,
                    "sub": lambda a,b: a-b
                }

            Uso:

                ops["soma"](2,3)

            Isso substitui if/elif.

        FUN√á√ïES COM DICION√ÅRIOS:

            . entrada como config
            . retorno estruturado
            . m√∫ltiplos resultados
            . estado acumulado

            EX:

                def stats(nums):
                    return {
                        "min": min(nums),
                        "max": max(nums)
                    }

        DICION√ÅRIOS COMO TABELAS DE DECIS√ÉO (MUITO IMPORTANTE)

            Em vez de:

                if x == 1: ...
                elif x == 2: ...

            Use:

                acoes = {
                    1: func1,
                    2: func2
                }
                acoes[x]()

            Isso √©:

                . mais limpo
                . extens√≠vel
                . escal√°vel

        FRASES-CHAVE PARA MEMORIZAR:

            Dicion√°rio mapeia
            Chave √© identidade
            Hash √© O(1)
            Base de APIs
            Substitui ifs

        Erros comuns:

            for x in d: achar que x √© valor (na verdade √© chave)
            in em dict testa chave, n√£o valor
            fromkeys(..., []) cria listas compartilhadas
            usar d[key] sem garantir que a chave existe (prefira get quando fizer sentido)
            usar lista como chave
            esquecer .items()
            sobrescrever sem perceber
            iterar achando que vem ordenado por valor
            usar dict quando lista bastava (ou vice-versa)

    =====================================================================

    Conjuntos:

        - Set √© uma cole√ß√£o n√£o ordenada, mut√°vel e sem elementos duplicados.

        Modelo mental:

            ‚ÄúQuero saber se algo existe‚Äù

            ‚ÄúQuero remover duplicatas‚Äù

            ‚ÄúQuero comparar grupos‚Äù

        Exemplo:

            s = {1, 2, 3}

        Defini√ß√µes importantes:

            . Sem ordem (n√£o use √≠ndices)

            . Sem duplicatas

            . Mut√°vel (voc√™ adiciona/remove)

            . Elementos devem ser hashable (imut√°veis)

            V√°lido:

                {1, "a", (2, 3)}

            Inv√°lido:

                {[1, 2], {"a": 1}}  # erro

        Criando sets:

            set()              # conjunto vazio
            {1, 2, 3}          # literal
            set([1, 2, 2, 3])  # {1,2,3}
            set("banana")      # {'b','a','n'}

        PS: {} cria dicion√°rio, n√£o set.

        Set √ó Lista √ó Tupla √ó Dict (quando usar):

            | Estrutura | Uso ideal              |
            | --------- | ---------------------- |
            | list      | ordem, √≠ndices         |
            | tuple     | dados imut√°veis        |
            | dict      | chave ‚Üí valor          |
            | set       | pertin√™ncia, unicidade |

            Busca em set √© O(1) (hash).

        Opera√ß√µes fundamentais (o cora√ß√£o dos sets):

            . Pertin√™ncia

                    x in s
                    x not in s

                - Muito mais r√°pido que lista.

            . Uni√£o

                    A | B
                    A.union(B)

            . Interse√ß√£o

                    A & B
                    A.intersection(B)

            . Diferen√ßa

                    A - B
                    A.difference(B)

            . Diferen√ßa sim√©trica

                    A ^ B
                    A.symmetric_difference(B)

            Isso √© matem√°tica pura aplicada a c√≥digo.

        M√©todos principais de set:

            . Adi√ß√£o

                    s.add(x)
                    s.update(iteravel)

            . Remo√ß√£o

                    s.remove(x)     # erro se n√£o existir
                    s.discard(x)    # n√£o gera erro
                    s.pop()         # remove elemento arbitr√°rio
                    s.clear()

            . C√≥pia

                    s.copy()

        Compara√ß√µes e rela√ß√µes:

                A == B
                A <= B   # subconjunto
                A < B    # subconjunto pr√≥prio
                A >= B
                A.isdisjoint(B)  # n√£o t√™m elementos em comum

        Sets com loops e condi√ß√µes:

                for x in s:
                    if x > 0:
                        ...

            - Ordem n√£o garantida.

        Set comprehension:

                quadrados = {x*x for x in range(10) if x % 2 == 0}

            - Muito usado para filtros r√°pidos.

        Convers√µes (casting):

                set(lista)
                list(set(lista))     # remove duplicatas
                tuple(set(lista))

            Ordem pode mudar.

        Sets e fun√ß√µes:

                def comuns(a, b):
                    return set(a) & set(b)

            - Retorno ideal quando a ordem n√£o importa.

        Sets e dicion√°rios:

            . dict.keys() se comporta como um set

                d.keys() & outro_set

            Muito poderoso em valida√ß√µes.

        Frozenset (set imut√°vel):

                fs = frozenset([1, 2, 3])

            . imut√°vel
            . hashable
            . pode ser chave de dicion√°rio

            Usado em cache, grafos, estados.

        Erros comuns:

            . tentar indexar set (s[0])
            . assumir ordem
            . usar remove quando deveria discard
            . colocar mut√°veis dentro 
            . usar set quando precisa de ordem

        Dicas:

            Pergunte sempre:

                Preciso de ordem?

                Preciso de duplicatas?

                Vou testar pertin√™ncia muitas vezes?

                Opera√ß√µes de conjunto resolvem?

            Se sim ‚Üí set.

        Frases-chave para memorizar:

            . Set n√£o ordena
            . Set elimina duplicata
            . Set testa r√°pido
            . Set √© matem√°tica viva

    =====================================================================

    tecnica de ponteiros (1 ou mais ponteiros):

        - Ponteiro √© uma vari√°vel que aponta para uma posi√ß√£o de uma estrutura 
        de dados.

        Em Python:

            . o ‚Äúponteiro‚Äù normalmente √© um √≠ndice

            . ou uma refer√™ncia que se move

        Voc√™ n√£o move dados, voc√™ move o acesso.

        UM PONTEIRO (Single Pointer):

            - Um √≠ndice que percorre a estrutura de forma controlada.

            EX:

                i = 0
                while i < len(lista):
                    # usa lista[i]
                    i += 1

            Isso √© a base de:

                . varreduras
                . contagem
                . busca linear
                . parsing

            Quando usar:

                . voc√™ precisa visitar todos os elementos
                . a decis√£o depende apenas do elemento atual

        DOIS PONTEIROS (Two Pointers):

            - Usar dois √≠ndices independentes que se movem com regras pr√≥prias.

            Existem tr√™s padr√µes cl√°ssicos.

            . PADR√ÉO 1 ‚Äî Ponteiros convergentes (esquerda ‚Üî direita):

                i ‚Üí        ‚Üê j

                Exemplo:

                    i = 0
                    j = len(lista) - 1

                    while i < j:
                        # usa lista[i] e lista[j]
                        i += 1
                        j -= 1

                Usos cl√°ssicos

                    . inverter lista/string
                    . verificar pal√≠ndromo
                    . comparar extremos
                    . swaps sim√©tricos

                Voc√™ j√° usou isso sem perceber.

            . PADR√ÉO 2 ‚Äî Ponteiros na mesma dire√ß√£o (r√°pido / lento):

                slow ‚Üí ‚Üí ‚Üí
                fast ‚Üí ‚Üí ‚Üí ‚Üí

                EX:

                    slow = 0
                    for fast in range(len(lista)):
                        if condicao(lista[fast]):
                            lista[slow] = lista[fast]
                            slow += 1

                Usos cl√°ssicos

                    . remover elementos in place
                    . filtrar lista sem criar outra
                    . remover duplicatas
                    . compacta√ß√£o

                Muito usado em entrevistas e c√≥digo profissional.

            . PADR√ÉO 3 ‚Äî Ponteiros em duas estruturas:

                EX:

                    i = j = 0
                    while i < len(a) and j < len(b):
                        if a[i] < b[j]:
                            i += 1
                        else:
                            j += 1

                Usos cl√°ssicos:

                    . merge de listas ordenadas
                    . interse√ß√£o eficiente
                    . compara√ß√£o de streams

                Base do merge sort.

        MAIS DE DOIS PONTEIROS:

            Quando aparece

                janelas
                
                matrizes
                
                parsing avan√ßado
                
                estados m√∫ltiplos

            Exemplo:

                i, j, k = 0, 1, len(lista)-1

            O importante √©:

                cada ponteiro tem uma responsabilidade clara

        PONTEIROS + CONDICIONAIS (CHAVE):

            - Ponteiros s√≥ funcionam bem quando o movimento depende de condi√ß√µes.

            Exemplo:

                if soma < alvo:
                    i += 1
                else:
                    j -= 1

            Isso evita loops aninhados.

        PONTEIROS √ó LOOPS ANINHADOS

            | Abordagem    | Complexidade |
            | ------------ | ------------ |
            | Dois `for`   | O(n¬≤)        |
            | Two pointers | O(n)         |

            Isso √© otimiza√ß√£o algor√≠tmica real.

        PONTEIROS + JANELAS (SLIDING WINDOW)

            - Janela √© um caso especial de dois ponteiros:

                left = 0
                for right in range(n):
                    # expande
                    while condicao:
                        left += 1

            Voc√™ controla:

                expans√£o

                contra√ß√£o

        PONTEIROS EM STRINGS:

            - Strings s√£o imut√°veis, mas os ponteiros funcionam igual:

            EX:

                i = 0
                j = len(s) - 1

                while i < j:
                    if s[i] != s[j]:
                        return False
                    i += 1
                    j -= 1

            Base de valida√ß√µes de texto.

        PONTEIROS EM MATRIZES:

            Exemplo:

                percorrer diagonal

                swap sim√©trico

                vizinhan√ßa

            
            C√≥d ex:

                i = j = 0
                while i < n:
                    mat[i][j]
                    i += 1
                    j += 1

            Ponteiros aqui s√£o pares (i, j).

        PONTEIROS √ó ITERADORES

            . for x in lista ‚Üí iterador impl√≠cito
            . ponteiros ‚Üí controle expl√≠cito

            Use ponteiros quando:

                . o passo n√£o √© sempre +1
                . voc√™ precisa voltar, pular, sincronizar

        ERROS COMUNS:

            mover ponteiro errado

            esquecer condi√ß√£o de parada

            confundir i < j com i <= j

            sobrescrever dados in place

            usar ponteiros quando lista simples bastava

        COMO PENSAR (MENTALIDADE):

            Antes de codar, pergunte:

                1. Quantos acessos simult√¢neos preciso?
                2. Eles se movem juntos ou independentes?
                3. Quando cada ponteiro avan√ßa?
                4. Posso eliminar um loop aninhado?
                5. D√° para fazer in place?

            Se sim ‚Üí ponteiros.

        FRASES-CHAVE PARA MEMORIZAR:

            . Ponteiro move acesso
            . Dois ponteiros economizam tempo
            . Janela √© ponteiro disfar√ßado
            . O(n) vence O(n¬≤)
            . Controle √© tudo

    =====================================================================

    Divis√£o e conquista:

    =====================================================================

    n√∫meros aleat√≥rios:

    =====================================================================

    regex:

    =====================================================================

    M√≥dulos, Bibliotecas e importa√ß√µes:

    =====================================================================

    Alias:

    =====================================================================

    Garbage:

    =====================================================================

    shuffle:

    =====================================================================

    Arquivos:

    =====================================================================

    Geradores:

    =====================================================================

    Programa√ß√£o funcional (map, any, sum, all, lambda k):

    =====================================================================

    Fallback:

    =====================================================================

    Exce√ß√µes, assertations e testes de software:

    =====================================================================

    Assincronismo, fun√ß√µes e geradores ass√≠ncronos, threads e processos:

    =====================================================================

    Worse com Python:

    =====================================================================


Um pouco sobre POO:

    Objetos e classes

    Vari√°veis de classe e Construtor

    M√©todos

    atributos e propriedades de classe

    atributos privados, protegidos e p√∫blicos

    m√©todos privados, protegidos e p√∫blicos

    Encapsulamento

    Composi√ß√£o, heran√ßa e delega√ß√£o

    Polimorfismo

    Sub-tipagem

    M√©todos de classe

    M√©todos abstratos

    M√©todos est√°ticos

    self e cls

    M√©todos m√°gicos

    DataClass

    Setups, interfaces e Managers

    SOLID

Um pouco sobre Estruturas de dados:

    caracteres e strings

    listas / vetores e arrays n√£o ordenadas

    listas / vetores e arrays ordenadas

    circularidade e rotacionamento:

    matrizes

    Torre de Hanoi

    algoritmos de busca

    algoritmo de Ordena√ß√µes

    BFS √ó DFS

    pilhas

    filas

    fila de prioridade

    fila circular

    fila de extremidade dupla

    deques

    Lista encadeada

    √°vores

    hash tables

    grafos

    Busca em profundidade

    Busca em largura

    Busca gulosa

    Busca A*

    Algoritmo de Dijkstra
