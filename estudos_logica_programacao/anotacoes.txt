- Um programa ou software, é o que podemos chamar de inteligência do computador

- O hardware é a máquina, a parte física

- Em computação, dados são a representação simbólica de um fato ou acontecimento.
Os fatos podem ser, nomes, datas, valores numéricos, imagens, etc. Ou seja,
qualquer coisa que possa ser medido, comparado ou representados no computador.

- Os símbolos mais comuns são as letras e os números. (As imagens e os sons são representados
no computador por uma sequencia de número).

- Uma informação é um dado, ou conjunto de dados, ou o o resultado da transformação de um
conjunto de dados que, dentro de determinado contexto, faça sentido para alguém. Poe exemplo,
uma ficha médica, ou um formulário de cadastro.

- Qualquer fato, pode ser representado simbolicamente? Não. Por que certos, fatos,
não podem ser representados como são na realidade, por conta de não poderem ser interpretados
lógico-matematicamente. Outros, por conta de não serem duais, assim não interpretados, como zeros
e uns. Emoções, sabores e sentimentos são exemplos de fatos que não podem ser representados,
por serem complexas e por terem reprodução além do lógico.

SOBRE SISTEMA BINÁRIO

- São representados por 0s e 1s, embora, haja outros sistemas, como ternários,
decimais, hexadecimais e octais.

- O computador atualmente, entende apenas 0s e 1s que representam ligado e desligado,
tal que seguem o princípio de ebtrada e saída de energia no hardware.

- Possui um sistema de numeração onde cada dígito, aqui chamado de bit, tem apenas dois valores
possíveis, ou seja, 0 e 1

- No sistema decimal, podemos representar até 10 elementos com um único dígito:

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9

- No sistema binário, podemos representar apenas 2 com um único bit.

    0, 1

- Para se poder rtepresentar mais elementos, é necessário acrescentar outros dígitos e bits.

- O 11° elemento no sistema decimal e'representado por 10.

    IMPORTANTE: Na computação, o valor 0 é super significativo quanto a identificar elementos

- No sistema binário, o 3° elemento, já que só podemos representar o 2 como um único bit, será
o 10.

- Tabela de 0, 20

    Decimal | Binário
    0       | 0
    1       | 1
    2       | 10
    3       | 11
    4       | 100
    5       | 101
    6       | 110
    7       | 111
    8       | 1000
    9       | 1001
    10      | 1010
    11      | 1011
    12      | 1100
    13      | 1101
    14      | 1110
    15      | 1111
    16      | 10000
    17      | 10001
    18      | 10010
    19      | 10011
    20      | 10100

- No sistema decimal, cada dígito adicional aumenta em 10 vezes a capacidade de contagem, ao passo
que no binário, cada bit adicional aumenta em 2 vezes.

- Qual a capacidade de contagem de um número com 3 dígitos?

    10**3 = 1000

    - Vai de 0 a 999

- Qual a capacidade de contagem de um número com 3 bits?

    2**3 = 8

    - Vai de 0 a 7

- Como saber quanto um binário vale em decimal?

    EX:

        1       0       0       1       1       0       1       0       1       0       1       1       1       0
        2**13   2**12   2**11   2**10   2**9    2**8    2**7    2**6    2**5    2**4    2**3    2**2    2**1    2**0
        8192    4096    2048    1024    512     256     128     64      32      16      8       4       2       1
        8192    0       0       1024    512     0       128     0       32      0       8       4       2       0

        8192 + 0 + 0 + 1024 + 512 + 0 + 128 + 0 + 32 + 0 + 8 + 4 + 2 + 0 =  9902


        1° linha: Símbolo binário
        2° linha: Resutado do valor 2**n
        3° linha: Resultado do valor de 2**n * símbolo binário

        10011011

        2**7 = 128 * 1 = 128
        2**6 = 64 * 0 = 0
        2**5 = 32 * 0 = 0
        2**4 = 16 * 1 = 16
        2**3 = 8 * 1 = 8
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 1 = 1

        128 + 16 + 8 + 2 + 1 = 155

- Como saber quanto um decimal vale em binário?

    EX: 100

    100 / 2 = 50, resto 0
    50 / 2 = 25, resto 0
    25 / 2 = 12, resto 1
    12 / 2 = 6, resto 0,
    6 / 2 = 3, resto 0
    3 / 2 = 1, resto 1,
    1 / 2 = resto 1, pois 1 não divide 2

    resultado dos restos: 0010011

    inverte ficará: 1100100

- Prático:

    Exercício 1 - Foi vista na videoaula a conversão do número
    binário 10011010111001 para o seu equivalente decimal que
    resultou em 9913.

    Acrescente um bit 0 à direita (o menos significativo) deste
    número binário e veja que número decimal obterá.
    
    Divida este novo número decimal obtido pelo decimal anterior e
    analise o resultado.

        100110101110010

        2**14 = 16384 * 1 = 16384
        2**13 = 8192 * 0 = 0
        2**12 = 4096 * 0 = 0
        2**11 = 2048 * 1 = 2048
        2**10 = 1024 * 1 = 1024
        2**9 = 512 * 0 = 0
        2**8 = 256 * 1 = 256
        2**7 = 128 * 0 = 0
        2**6 = 64 * 1 = 64
        2**5 = 32 * 1 = 32
        2**4 = 16 * 1 = 16
        2**3 = 8 * 0 = 0
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 0 = 0

        16384 + 2048 + 1024 + 256 + 64 + 32 + 16 + 2 = 19826

        Divisão: 19826 // 9913 = 2


    Exercício 2 - Com o resultado decimal obtido no exercício 1, aplique a técnica da divisão 
    sucessiva por 2 para obter seu equivalente binário. O resultado deverá ser o número original

        19826

        19826 // 2 = 9913, resto 0
        9913 // 2 = 4956, resto 1
        4956 // 2 = 2478, resto 0
        2478 // 2 = 1239, resto 0
        1239 // 2 = 619, resto 1
        619 // 2 = 309, resto 1
        309 // 2 = 154, resto 1
        154 // 2 = 77, resto 0
        77 // 2 = 38, resto 1
        38 // 2 = 19, resto 0
        19 // 2 = 9, resto 1
        9 // 2 = 4, resto 1
        4 // 2 = 2, resto 0
        2 // 2 = 1, resto 0
        1 // 2 = 1

        Resultado dos restos: 010011101011001

        Resultado final, invertido: 100110101110010

SOBRE O COMPUTADOR:

- A Memória, é onde se armazena e endereça informações e dados. É nela onde se permite
guardar informações e registrá-las e mantê-las enquanto o programa ou a máquina estiver ligada.
É nela onde o processador se comunica retornando informações. Ela se divide em dois pontos:

    . Endereço fixo: O local referente onde os dados estão armazenados

    . Conteúdo vartiável: O conteúdo que está armazenado no endereço e pode ser mutável

- 1 byte contém 8 bits

- Os computadores tradicionais se compõem de uma grande sequencia de bytes de 8 bits

- A ideia original de que o byte deva ter 8 bits surgiu da necessidade de se ter um código
para representar cada um dos caracteres visíveis (letras, números, sinais de pontuação e
alguns símbolos mais utilizados como o $, %, @ e outros), além de caracteres de controle
(invisíveis) tais como o comando de saltar linha na tela ou soar o beep do PC. Chegou na
conclusão que 8 bits era mais que o suficiente

- A tabela ASCII, é um formato interpretador que serve de base para interpretação unicode
dos dados. Ela possui seus caracteres em 8 bits e foi uma das bases mais usadas e até hoje
é bastante utilizada. Nela, a letra 'a' têm o valor de 01100001 (97 em decimal) e o caracter
numérico '1' tem o valor de 00110001 (49 em decimal).

- No caso dos números, este valor é meramente um identificador do símbolo do número, porque
o seu valor matemático está nos bits conforme vimos anteriormente. E como disse acima,
49 não representa o valor matemático 1 e sim representa o tipo de texto 1, ou seja,
o valor simbólico, não literal.

- O byte é um agrupamento voltado aos conteúdos da memória, sendo que a quantidade de bits
para fazer o endereçamento da memória segue outra contagem. Os primiros Pcs pessoais tinham memória
com endereçamento de 8 bits, o que permitia apenas 256 endereços.

- A CPU (Central Processing Unit), é o mecanismo principal do computador. É nele onde as instruções
são processadas e ela é responsável por trabalhar com o conteúdo das memória, recebendo dados
e retornando-as / escrevendo para tal. Ela realiza um procedimento de coleta de cada item
endereçado na memória, e faz um trabalho X nela dependendo do dado, procedimento pedido e 
comportamento do sistema com o hardware.

- Os conteúdos da CPU são:

    . Instruções:

        - Dizem a CPU o que fazer

        - Cada instrução, possui um SET, que é responsável por dizer a CPU que coisas devem acontecer

            EX de um computador elementar de 4 bits a nível binário:

                x----------x--------------------------------------------------------------------x
                | Conteúdo |                            Ação                                    |
                x----------x--------------------------------------------------------------------x
                |   0000   | Interrompe a execução do programa                                  |
                x----------x--------------------------------------------------------------------x
                |   0100   | Lê o conteúdo da memória que está no endereço logo a seguir a esta |
                |          | instrução e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |   0110   | Lê o conteúdo da memória que está no endereço logo a seguir a esta |
                |          | instrução e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |          | Soma o conteúdo do registrador 1 com o conteúdo do registrador 2   |
                |   0111   | e armazena o resultado no endereço de memória cujo número equivale |
                |          | ao conteúdo do endereço a seguir a esta instrução                  |
                x----------x--------------------------------------------------------------------x

            PS: Cada código binário representa uma ação específica, previamente definida pela 
            arquitetura da CPU.

    . Dados:

        - Manipulados pelas instruções para que determinado pedido ou resultado seja obtido


- Linguagem binária ou de máquina: É a linguagem do computador, responsável por seguir
sequencias complexas de instruções, tudo isso seguindo no princípio binário.

- Linguagem Assembly: relação direta entre as instruções em linguagem binária e expressões
mnemônicas.

    Instrução Binária       Correspondente eletrônico
          0000                         stop
          0100                         read 1
          0110                         read 2
          0111                         add 1 2

- Esta "altitude" do nível de uma linguagem diz respeito, em linhas gerais, a facilidade e rapidez
com que se produz um programa. Ou seja, são necessárias menos instruções escritas pelo programador
para se obter um mesmo resultado. Em outras palavras uma instrução escrita produz mais instruções
binárias. Porém, linguagens de alto nível, costumam produzir programas de desempenho inferior

- Os compiladores leem o programa fonte e produzem um programa executável independente de qualquer
outro software que não seja o sistema operacional do computador.

            PROGRAMA -> COMPILADOR -> PROGRAMA.exe 
            
        ps: Em sistemas UNIX PROGRAMA.exe, retorna apenas PROGRAMA, mas no fundo é um executável 
        também

- Os interpretadores leem o programa fonte, criam este programa na memória (binário) e o executam.
Não existe programa executavel gerado.Tudo é realizado pelo interpretador.

    . Os interpretadores facilitam o trabalho de manutenção principalmente em grandes sistemas
    compostos de muitos programas

    . Em ambientes de muitos programas rodando simultaneamente, os interpretadores consomem menos
    memória

    . Considerando uma mesma linguagem, o seu computador produz programas mais rápidos do que
    o seu interpretador.

SOBRE PROGRAMAS

- Um programa é um conjunto de passos e instruções, organizadas de maneira lógica, que realiza um ou mais serviços
de processamento de dados.

- Processamento de dados é o ato de tratar dados brutos e obter dados tranformados, seguindo especificações previamente
estabelecidas, ou obter infortmações com esses dados contextualizados.


                    DADOS BRUTOS -> PROGRAMA -> DADOS TRABALHADOS

- Um programa pode ser simples ou composto por diversos outros programas

- Um algoritmo é uma sequencia finita de passos, etapas ou instruções que resolvem determinados
problemas. Um algoritmo é dito determinístico quando se obtém sempre o mesmo resultado a partir dos
mesmos dados. Um programa pode ter 1 ou N algorítmos.

- Um exemplo de um algoritmo funcional:

    . Cada linguagem têm uma estrutura ou sintaxe

    . Cada programa possui uma linha de execução. Dependendo da linguagem, ela precisa ser fechada
    ou concluída, para referenciar outra linha ou se fecha automaticamente.

    . variáveis são definições e referencias a objetos ou valores no programa. Eles são escopos
    de memória onde se realizará procedimentos e armazenazem tempórária de dados e informações.
    Elas não podem começar com números e símbolos que não sejam _ e também com espaços.

    EX: ISSO FOI CRIADO POR MIM, UMA FORMA INTERPRETATIVA MINHA DE MOLDAR ALGORITMO FORA DA MÁQUINA
    É MERA INTERPRETAÇÃO, PODEMOS USAR FERRAMENTAS JÁ PRONTAS QUE LEIAM EM PORTUGUÊS OU PODE MONTAR DO
    SEU JEITO, CONTANTO, QUE SIGA NORMAS E PADRÕES DA COMPUTAÇÃO E QUE FIQUE FÁCIL DE VOCÊ APLICAR,
    LER E IMPLEMENTAR EM OUTRAS LINGUAGENS.

        TÍTULO: "Soma"
        OBSERVACAO: "Vai realizar a soma de dois número"

        INICIO

        num1: int = int(ler("N1: "))
        num2: int = int(ler("N2: "))

        soma: int = num1 + num2   # Realiza a soma

        exibir f"Resultado = {soma}"

        FIM

- Um outro exemplo no qual usamos funções. Fuções são blocos de códigos, especializados
para executar funções específicas de código, ou seja, realizam procedimentos dentro de um escopo,
para que seja implementado no escopo principal. Ela facilita a leitura e entendimento do código e 
traz mais eficiência, legibilidade e pode ser usada e reaproveitada em outros programas.

    TÍTULO: "Função"
    OBSERVACAO: "Vai realizar uma demonstração do que é uma função"

    INICIO

    REALIZAR MÉDIA DE DOIS NÚMEROS
    [funçao] media
        params:
            n1: int
            n2: int
        ações:
            retornar (n1 + n2) / 2
    [fimfuncao]


    num1: float = float(ler("N1: "))
    num2: float = float(ler("N2: "))

    media: float = media(num1, num2)

    exibir f"A média é {media:.2f}"

    FIM

- Ide vs Editor de código fonte:

    . Ide (Integrated Development Environment): Uma IDE é um ambiente completo 
    de desenvolvimento. Ela integra várias ferramentas em um só lugar.

        O que uma IDE já traz integrada:

            + Editor de código

            + Compilador / interpretador

            + Debugger (passo a passo)

            + Gerenciador de projetos

            + Gerenciador de dependências
            
            + Build / Run com um clique
            
            + Testes integrados

        A IDE entende:

            o projeto

            a linguagem

            a estrutura

            as dependências

        Exemplos típicos

            . PyCharm

            . IntelliJ IDEA

            . Eclipse

            . Visual Studio

            . NetBeans

        → “Eu desenvolvo software aqui”

    . Editor de código fonte: Um editor de código é uma ferramenta focada em 
    escrever e editar texto/código. Ele não se preocupa com o projeto inteiro,
    só com o arquivo que você está editando. 
    
        Um editor oferece:

            + Destaque de sintaxe (cores)

            + Numeração de linhas

            + Busca e substituição

            + Autocompletar básico

            + Leve e rápido
        
        Exemplos típicos

            . VS Code (editor avançado)

            . Sublime Text

            . Notepad++

            . Vim / Nano

        → “Eu escrevo código aqui”


UM POUCO SOBRE LÓGICA DE PROGRAMAÇÃO:

    Variáveis:

        - Variável é um nome que guarda um valor na memória para ser usado depois.

        . Variável = caixa com nome

        . Valor = conteúdo da caixa

        . O valor pode mudar ao longo do programa

        . Serve para guardar dados temporários

        Por que variáveis existem?

            . Evitam repetir valores

            . Facilitam cálculos

            . Permitem decisões (if)

            . Permitem repetições (while, for)

        Antes de criar qualquer variável, pergunte:

            1. Que informação eu preciso guardar?

            2. Essa informação muda ou é fixa?

            3. Vou usar esse valor depois?

            4. Esse nome está claro para um humano?

        - Nome bom de variável explica o que ela guarda.

        TIPOS MAIS COMUNS DE VARIÁVEIS (conceito):

            | Tipo    | Guarda o quê?       | Exemplo         |
            | ------- | ------------------- | --------------- |
            | inteiro | números sem vírgula | idade = 20      |
            | real    | números com vírgula | altura = 1.75   |
            | texto   | palavras/frases     | nome = "Renato" |
            | lógico  | verdadeiro ou falso | aprovado = True |

        EXEMPLOS SIMPLES:

            Exemplo 1 — Guardar valor

                idade = 20

            Mental: “Criei uma caixa chamada idade e coloquei o valor 20 dentro.”

            Exemplo 2 — Usar variável

                preco = 10
                total = preco + 5
            
            Mental: “Usei o valor guardado para calcular outro.”

            Exemplo 3 — Valor muda

                contador = 0
                contador = contador + 1

            Mental: “A variável continua existindo, mas o valor mudou.”
        
        ERROS COMUNS:

            Usar nomes confusos:

                x = 10   # ruim

            Melhor:

                quantidade = 10

            Usar variável sem valor:

                print(total)  # erro se total não existir

            Pensar que variável é o valor:

                - Não é

                Variável é o nome, não o conteúdo.

        FRASE-CHAVE (decora essa)

            . Variável não é número, nem texto.

            . Variável é um nome que aponta para um valor.

        DICAS:

            . Pense no nome antes do valor
            . Variável deve ter sentido humano
            . Uma variável = uma informação
            . Se travar, pergunte: “O que eu preciso guardar?”
    
    =====================================================================

    Constantes:

        - Constante é um valor que NÃO deve mudar durante o programa.

        . Constante = valor fixo

        . Serve para representar regras, limites ou padrões

        . Evita “números mágicos” espalhados no código

        . Deixa o programa mais claro e seguro

        Ideia-chave:

            - Se não pode mudar, não deve ser variável.

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO):

            Perguntas obrigatórias antes de decidir:

                1. Esse valor pode mudar durante a execução?

                2. Ele representa uma regra do problema?

                3. Se mudar no futuro, deveria mudar em um só lugar?

                4. Esse valor tem significado fixo no mundo real?

            Se a resposta for “não muda” → constante

        DIFERENÇA CLARA: VARIÁVEL × CONSTANTE:

            | Conceito  | Pode mudar?  | Exemplo        |
            | --------- | ------------ | -------------- |
            | Variável  | ✅ Sim       | idade, saldo   |
            | Constante | ❌ Não       | PI, taxa fixa  |

        - Constante não depende do usuário, nem do tempo.

        COMO REPRESENTAR CONSTANTES (boa prática):

            Em Python, usa-se:

                . Nome em MAIÚSCULO

                . Separação com _

                EX:

                    PI = 3.14
                    TAXA_JUROS = 0.05
                    IDADE_MINIMA = 18
        
            Mesmo que Python permita mudar, a regra é lógica, não da linguagem.

        Exemplo 1 — Regra matemática

            PI = 3.14
            area = PI * 10 * 10

        Mental: “PI não muda. O raio pode mudar.”

        Exemplo 2 — Regra de negócio
            
            IDADE_MINIMA = 18
            idade = 20

        Mental: “A idade muda, a regra não.”

        Exemplo 3 — Evitando número mágico

            Ruim:

                total = preco * 0.1

            Bom:

                DESCONTO = 0.1
                total = preco * DESCONTO
            
        ERROS COMUNS:

            . Usar valor fixo direto no código

            . Espalhar o mesmo número em vários lugares

            . Tratar regra como variável

            . Nomear constante como variável comum

        Regra prática:

            - Se você precisar procurar o número no código para entender, ele 
            deveria ser uma constante.

        FRASE-CHAVE PARA MEMORIZAR:

            . Variável guarda estado.

            . Constante guarda regra.

        DICAS:

            . Regra → constante
            . Dado do usuário → variável
            . Constante no topo do código
            . Nome claro e em maiúsculo
            . Menos números “soltos” = menos erro

    =====================================================================

    Tipos de dados:

        - Tipo de dado define o que uma informação é e o que pode ser feito 
        com ela.

        Existem duas grandes visões:

            . Primitivos × Compostos

            . Objeto × Não-objeto

            Essas visões se complementam, não competem.
        
        TIPOS PRIMITIVOS (ou simples):

            - Guardam um único valor simples.

            Características:

                Valor único

                Não possuem partes internas

                Representam dados básicos

            Exemplos comuns:

                Número inteiro → 10

                Número real → 2.5

                Texto → "Olá"

                Lógico → True / False

            Ideia-chave:

                - Primitivo = uma informação só.

        TIPOS COMPOSTOS:

            - Guardam vários valores ou estruturas internas.

            Características:

                Podem conter vários dados

                Organizam informações relacionadas

                Facilitam trabalhar com conjuntos

            Exemplos comuns:

                Lista

                Tupla

                Conjunto

                Dicionário

            Ideia-chave:

                - Composto = várias informações agrupadas.

        COMPARAÇÃO RÁPIDA:

            | Tipo      | Quantidade de dados |
            | --------- | ------------------- |
            | Primitivo | 1 valor             |
            | Composto  | Vários valores      |

        NÃO-OBJETO (visão lógica):

            - Dado sem comportamento próprio.

            . Só representa um valor

            . Não “faz coisas”
            
            . Usado diretamente em cálculos e decisões

            Exemplos:

                Número

                Texto

                Booleano

            Pense assim:

                . É só dado, não é coisa.

        OBJETO (visão mais avançada):

            - Objeto = dado + comportamento.

            Características:

                . Tem valor

                . Tem ações

                . Possui estrutura interna

                . Pode ser manipulado por métodos

            Exemplo conceitual:

                . Uma lista guarda valores e sabe adicionar, remover, ordenar.

            Objeto é algo que:

                - Guarda dados

                - Sabe operar sobre si mesmo

                - Referencia moldes específicos para se realizar ações

        OBJETO × NÃO-OBJETO (resumo mental):

            | Conceito   | O que é      |
            | ---------- | ------------ |
            | Não-objeto | Dado puro    |
            | Objeto     | Dado + ações |

        Em Python:
        
            Tudo é objeto, mas conceitualmente essa separação ajuda muito a 
            entender POO.

        Exemplo 1 — Primitivo

            idade = 20

        Mental: Um único valor.

        Exemplo 2 — Composto

            notas = [7, 8, 9]

        Mental: Vários valores agrupados.

        Exemplo 3 — Objeto em ação

            notas.append(10)

        Mental: A lista faz algo.

        Exemplo 4 — Não-objeto

            soma = 10 + 5

        Mental: Apenas valores sendo usados.

        ERROS COMUNS:

            - Achar que tudo é só número
            - Confundir tipo com valor
            - Não perceber quando precisa de estrutura
            - Tentar resolver tudo com primitivos

            Regra prática:

                . Muitos dados relacionados → tipo composto.

        FRASES-CHAVE PARA MEMORIZAR:

            Primitivo = um valor
            Composto = vários valores
            Objeto = dado que sabe agir
            Não-objeto = dado puro

    =====================================================================

    Verificação de tipo (type, issinstance, issubclass):

        - Verificar tipo é perguntar: “que tipo de coisa é isso?”

        Em Python, usamos isso para:

            Evitar erros

            Tomar decisões

            Garantir que um dado é do tipo esperado

            Trabalhar com objetos e herança

        VISÃO LÓGICA (ANTES DO CÓDIGO):

            Sempre pense assim:

                1. Isso é um valor ou um objeto?

                2. Preciso saber exatamente o tipo ou apenas se pertence a um 
                grupo?

                3. Estou lidando com classe ou instância?

            Essas perguntas definem qual ferramenta usar.

        type() — qual é o tipo exato:

            - Retorna o tipo exato do valor ou objeto.

            Ideia-chave:

                . type compara identidade de tipo, não parentesco.

            Exemplo:
                
                x = 10
                type(x)

            Leitura humana:

                “O tipo exato de x é inteiro.”

            Comparação direta:

                type(x) == int

            Só será True se for exatamente int.

            Quando usar type?

                . Testes simples
                . Depuração
                . Verificação rígida

                . Não é ideal para POO e herança

        isinstance() — pertence a esse tipo?

            - Verifica se um valor é instância de um tipo ou de seus subtipos.

            Ideia-chave:

                . isinstance respeita herança.

            Exemplo:

                x = 10
                isinstance(x, int)

            Leitura humana:

                “x é um inteiro ou algo derivado de inteiro?”

            Múltiplos tipos:

                isinstance(x, (int, float))

            Mental: “É número?”

            Quando usar isinstance?

                . Código real
                . Funções genéricas
                . Validação de entrada
                . POO

            É o mais usado na prática.

        issubclass() — classe filha de outra?

            - Verifica se uma classe herda de outra classe.

            PS: Não funciona com valores, só com classes.

            Exemplo:

                issubclass(bool, int)

            Leitura humana:

                “bool é uma subclasse de int?”

            Sim (True)

            Outro exemplo:

                issubclass(list, object)

            Sim — tudo herda de object.

        COMPARAÇÃO FINAL (anote isso):

            | Função       | Pergunta que responde       |
            | ------------ | --------------------------- |
            | `type`       | Qual é o tipo exato?        |
            | `isinstance` | É desse tipo ou derivado?   |
            | `issubclass` | Essa classe herda de outra? |

        ERROS COMUNS:

            . Usar type quando deveria usar isinstance
            . Usar issubclass com objetos
            . Comparar tipos sem entender herança
            . Verificar tipo quando não precisa

            Regra prática:

                - Prefira isinstance em código de verdade.

        FRASES-CHAVE PARA MEMORIZAR

            type é rígido
            isinstance é flexível
            issubclass é estrutural

    ===================================================================== 

    Entrada e saída de dados (Input / Output — I/O):

        - Entrada de dados é quando o programa recebe informação de fora.
        
        - Saída de dados é quando o programa mostra informação para fora.

        . Entrada → usuário, arquivo, sistema

        . Saída → tela, arquivo, sistema

        . Todo programa útil recebe algo e entrega algo

        ENTRADA DE DADOS (conceito):

            Em Python, a entrada padrão vem do teclado:

                input()

            Importante:

                input() sempre retorna TEXTO (string).

            Exemplo simples:

                nome = input("Digite seu nome: ")
                print(nome)

        SAÍDA DE DADOS (conceito):

            Saída padrão é feita com:

                print()

            Serve para:

                Mostrar resultados

                Informar erros

                Exibir mensagens

            Exemplo com texto:

                print("Olá, mundo!")
        
        CONVERSÃO DE TIPO (obrigatório entender):

            Como input() retorna texto, precisamos converter:

                idade = int(input("Digite sua idade: "))

            Se não converter → erro em cálculo.

            Exemplo 1 — Número:

                numero = int(input("Digite um número: "))
                print(numero)

            Exemplo 2 — Soma:

                a = int(input("Digite o primeiro número: "))
                b = int(input("Digite o segundo número: "))
                soma = a + b
                print(soma)

            Exemplo 3 — Texto formatado:

                nome = input("Nome: ")
                idade = int(input("Idade: "))
                print(f"{nome} tem {idade} anos")

        ERROS COMUNS:

            . Esquecer conversão de tipo
            . Fazer cálculo com string
            . Entrada confusa para o usuário
            . Não guardar o valor em variável

            Regra de ouro:

                . Entrada → variável → processamento → saída

        FRASE-CHAVE PARA MEMORIZAR:

            - Programa sem entrada e saída não conversa com o mundo.

        DICAS:

            . Leia a entrada com calma
            . Converta logo após o input
            . Guarde tudo em variáveis
            . Só depois faça contas
            . Mostre saída clara para o usuário

    =====================================================================

    Interpolação e concatenação e formatação:

        - Concatenação junta textos manualmente.
        
        - Interpolação insere valores dentro do texto automaticamente.
        
        - Formatação controla como o texto e os números aparecem.

        Objetivo principal:

            - mostrar informações de forma clara para humanos.

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO):

            Pergunte sempre:

                Vou juntar textos?

                Vou mostrar valores dentro do texto?

                Preciso controlar casas decimais, alinhamento ou formato?

                O usuário entenderia essa saída facilmente?

        CONCATENAÇÃO (forma antiga):

            . Juntar textos usando +

            EX:

                nome = "Renato"
                idade = "20"
                print("Nome: " + nome + " | Idade: " + idade)

            Observação importante:

                . Só funciona bem com texto

                . Fica confuso com números

                . Pouco usado hoje

            Problema comum:

                print("Idade: " + 20)  # erro

        INTERPOLAÇÃO (forma moderna — RECOMENDADA):

            - Inserir valores dentro do texto automaticamente

            Em Python, usamos f-strings:

                print(f"Nome: {nome} | Idade: {idade}")

            Vantagens:

                Mais legível

                Aceita qualquer tipo

                Mais profissional

                Menos erro

            Use isso sempre que possível.

        FORMATAÇÃO DE VALORES:

            - Controlar como o valor aparece

            + Casas decimais:

                preco = 10.56789
                print(f"Preço: {preco:.2f}")

            Mostra apenas 2 casas decimais.

            + Texto alinhado:

                print(f"{nome:<10} {idade:>3}")

            . < esquerda

            . > direita

            . número = largura

            + Formatação monetária (simples):

                total = 1234.5
                print(f"Total: R$ {total:.2f}")

        Ruim (concatenação excessiva):

            print("Total: R$ " + str(total))

        Bom (interpolação):

            print(f"Total: R$ {total:.2f}")

        ERROS COMUNS:

            . Usar concatenação com números
            . Converter tudo para string sem necessidade
            . Saída confusa para o usuário
            . Não formatar valores financeiros

        Regra prática:

            - Se tem variável no texto → use f-string.

        FRASES-CHAVE PARA MEMORIZAR:

            Concatenação é manual
            
            Interpolação é automática
            
            Formatação é controle visual

        DICAS:

            . Use f"" sempre
            . Formate números financeiros
            . Saída clara vale mais que código curto
            . Pense no usuário lendo

        Outras saídas:

            Saída com vírgula no print:

                Você pode passar vários valores no print separados por vírgula:

                    nome = "Renato"
                    idade = 20
                    print("Nome:", nome, "| Idade:", idade)

            Por padrão o print coloca um espaço entre os itens.
            Você pode controlar com sep e end:

                print("A", "B", "C", sep="-")   # A-B-C
                print("Oi", end="!")           # Oi!

            Formatação com % (antiga, mas cai em exercícios):

                Sintaxe:

                    %s texto

                    %d inteiro

                    %.2f float com 2 casas

                EX:

                    nome = "Renato"
                    idade = 20
                    print("Nome: %s | Idade: %d" % (nome, idade))

                    preco = 10.567
                    print("Preço: R$ %.2f" % preco)

            Formatação com .format():

                Por posição:

                    nome = "Renato"
                    idade = 20
                    print("Nome: {} | Idade: {}".format(nome, idade))

                Por nome:

                    print("Nome: {n} | Idade: {i}".format(n=nome, i=idade))

                Casas decimais:

                    total = 1234.5
                    print("Total: R$ {:.2f}".format(total))

    =====================================================================

    Operadores aritméticos:

        - Operadores aritméticos servem para fazer cálculos matemáticos no 
        programa.

        Eles permitem:

            Somar

            Subtrair

            Multiplicar

            Dividir

            Divisão inteira

            Resto da divisão

            Potência

        Sem operadores, o programa não calcula nada.

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO)

            Pergunte sempre:

                Que cálculo o problema pede?
                
                É conta de escola (soma, divisão, média, etc.)?
                
                O resultado precisa ser inteiro ou decimal?
                
                Preciso do resto ou só do resultado?

            A lógica vem antes do símbolo.

        OPERADORES ARITMÉTICOS EM PYTHON:

            | Operador | Nome            | Exemplo  |
            | -------- | --------------- | -------- |
            | `+`      | Soma            | `a + b`  |
            | `-`      | Subtração       | `a - b`  |
            | `*`      | Multiplicação   | `a * b`  |
            | `/`      | Divisão         | `a / b`  |
            | `//`     | Divisão inteira | `a // b` |
            | `%`      | Resto (módulo)  | `a % b`  |
            | `**`     | Potência        | `a ** b` |
        
        Soma:

            a = 10
            b = 3
            print(a + b)   # 13

        Divisão (sempre gera decimal):

            print(10 / 3)  # 3.3333...

        Divisão inteira:

            print(10 // 3) # 3

        . Quantas vezes cabe, sem quebrar.

        Resto da divisão:

            print(10 % 3)  # 1
        
        . Muito usado para:

            Par ou ímpar

            Ciclos

            Quebras de grupo

        Potência:

            print(2 ** 3)  # 8

            print(pow(2, 3))  # 8

        Subtração:

            a = 10
            b = 3
            print(a - b)   # 7

        Multiplicação:

            a = 10
            b = 3
            print(a * b)   # 30

        Adicional: Raizes

            indice = 2
            radicando = 4

            raiz = radicando**(1/indice)

            print(raiz)  # 2.0

        abs() — valor absoluto:

            - Retorna o valor sem sinal (distância até o zero).

            Ex:

                print(abs(10))    # 10
                print(abs(-10))   # 10

                # tpécnica em caso de negativos, fazer conversão explícita
                print(-(-10)) # 10

        round() — arredondamento:

            - Arredonda um número.

            Ex:

                print(round(3.6))      # 4
                print(round(3.14159, 2))  # 3.14

            Pode receber:

                - 1 argumento → arredonda inteiro

                - 2 argumentos → casas decimais

        min() e max() — menor e maior:

            print(min(3, 7, 2))  # 2
            print(max(3, 7, 2))  # 7
            
            # Com iteraveis de tipo numérico:
            valores = [10, 3, 8]
            print(min(valores))
            print(max(valores))

        divmod() — divisão + resto:

            - Retorna quociente e resto juntos.

            q, r = divmod(10, 3)
            print(q, r)  # 3 1

        int(), float() — conversão numérica:

            - PS: int() corta, não arredonda.

                print(int(3.9))    # 3
                print(float(10))   # 10.0

        PRECEDÊNCIA (ordem das contas):

            - Python segue a matemática.

            Ordem:

                1. ()

                2. **

                3. * / // %

                4. + -

            Exemplo:

                resultado = 10 + 2 * 3

            Resultado: 16, não 36.

            Use parênteses para deixar claro:

                resultado = (10 + 2) * 3

             Resultado: 36.

        ERROS COMUNS

            . Esquecer conversão do input()
            . Usar / achando que retorna inteiro
            . Confundir % com porcentagem
            . Não usar parênteses quando precisa
            . Achar que abs arredonda
            . Confundir int() com round()
            . Não usar funções prontas
            . Repetir cálculo manual desnecessário

            % não é porcentagem, é resto da divisão.

            Se parece “básico demais”, provavelmente já existe função pronta.

        DICAS:

            . Converta o input imediatamente
            . Pense na matemática antes do operador
            . Use parênteses sem medo
            . Teste com números simples (2, 3, 10)

    =====================================================================

    Operadores de atribuição:

        - Operadores de atribuição servem para colocar ou atualizar valores em 
        variáveis.

        Eles fazem duas coisas ao mesmo tempo:

            1. Executam uma operação

            2. Guardam o resultado na variável

        Não é matemática pura, é estado do programa mudando.

        COMO PENSAR COMO LÓGICO:

            Sempre leia assim:

                “Pegue o valor atual da variável, faça algo, e guarde de volta.”

            Se você não entende isso, vai errar laço, contador e soma acumulada.

        ATRIBUIÇÃO SIMPLES:

            . =
                
                x = 10

            Mental: “Coloque 10 dentro de x.” / “x recebe 10” /
            “x atribui 10” / “x referencia 10”

        ATRIBUIÇÃO COM OPERAÇÃO:

            | Operador | Significado             |
            | -------- | ----------------------- |
            | `+=`     | soma e guarda           |
            | `-=`     | subtrai e guarda        |
            | `*=`     | multiplica e guarda     |
            | `/=`     | divide e guarda         |
            | `//=`    | divide inteiro e guarda |
            | `%=`     | resto e guarda          |
            | `**=`    | potência e guarda       |

        . +=

            total = 0
            total += 5

        Mesmo que:

            total = total + 5

        . -=

            saldo = 100
            saldo -= 30

        Mesmo que:

            saldo = saldo - 30

        . *=

            preco = 10
            preco *= 2

        Mesmo que:

            preco = preco * 2

        . /=

            media = 10
            media /= 2

        Mesmo que:

            media = media / 2

        . %= (muito usado em ciclos)

            x = 10
            x %= 3   # sobra 1

        Mesmo que:

            x = x % 3

        . **=

            n = 2
            n **= 3

        Mesmo que:

            n = n ** 3

        LEITURA HUMANA:

            Leia como:

                “x recebe x mais 1”

            Nunca como:

                “x mais igual 1”

        ERROS COMUNS

            . Usar sem entender o valor anterior
            . Confundir = com ==
            . Achar que cria variável nova
            . Usar antes de inicializar

            Regra de ouro:

                Nunca use += sem inicializar a variável antes.

        FRASE-CHAVE PARA MEMORIZAR

            - Operador de atribuição muda o estado da variável.

        DICAS:

            . Inicialize sempre
            . Leia o operador como frase
            . Use muito em contadores
            . Use em laços (em breve!)

    =====================================================================

    Operadores lógicos:

        - Operadores lógicos combinam condições e produzem verdadeiro ou falso.

        Eles trabalham com valores lógicos:

            True (verdadeiro)

            False (falso)

        São usados para:

            Decidir caminhos (if)

            Validar dados

            Criar regras compostas

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO):

            Sempre pergunte:

                1. Quantas condições existem?

                2. Todas precisam ser verdadeiras ou só uma?

                3. Existe negação de alguma condição?

            Traduza a frase humana para lógica.

        and — E:

            - Só é True se todas forem verdadeiras.

            EX:

                idade = 20
                tem_documento = True

                print(idade >= 18 and tem_documento)

            Tabela verdade (and):

                |    A    |   B    | A and B |
                | ------- | ------ | ------- |
                | True    | True   | True    |
                | True    | False  | False   |
                | False   | True   | False   |
                | False   | False  | False   |

        or — OU

            É True se pelo menos uma condição for verdadeira.

            EX:

                dia = "sábado"
                print(dia == "sábado" or dia == "domingo")

            Leitura humana:

                “É sábado ou domingo?”

            Tabela verdade (or):

                |    A    |   B    | A or B |
                | ------- | ------ | ------ |
                | True    | True   | True   |
                | True    | False  | True   |
                | False   | True   | True   |
                | False   | False  | False  |

        not — NÃO

            - Inverte o valor lógico.

            Exemplo:

                chovendo = False
                print(not chovendo)

            Leitura humana:

                “Não está chovendo.”

            Tabela Verdade:

                |   A   |   not A   |
                | ----- | --------- |
                | True  |   False   |
                | False |   True    |

        COMBINAÇÕES (muito comum):

            Ex1:

                idade = 17
                estudante = True

                print(idade < 18 and estudante)

            Ex2:

                senha_correta = False
                print(not senha_correta)

        PRECEDÊNCIA LÓGICA (importante):

            Ordem:

                1. not

                2. and

                3. or
            
            Use parênteses para clareza:

                (idade >= 18 and tem_documento) or autorizado

        ERROS COMUNS

            . Esquecer parênteses
            . Confundir and com or
            . Escrever frases mal traduzidas
            . Usar lógica sem pensar na frase humana

            Regra de ouro:

                Se não dá pra ler em português, a lógica está errada.

        FRASES-CHAVE PARA MEMORIZAR

            and exige tudo
            or aceita um
            not inverte

        DICAS:

            . Traduza para frase humana
            . Use parênteses sem medo
            . Teste com valores verdadeiros e falsos
            . Não complique a lógica cedo demais

        CONCEITO AVANÇADO (MUITO IMPORTANTE):

            - and e or retornam operandos, não booleanos

            - Eles usam short-circuit evaluation (avaliação curta)

            Isso permite padrões como:

                valor = entrada or valor_padrao

            ou

                condicao and funcao()

        Operação de Curto Circuito:

            - Curto-circuito é quando o Python para de avaliar uma expressão
            lógica assim que o resultado já está decidido.

            Ele acontece com:

                and
                or

            REGRAS SIMPLES:

                and

                    Para no primeiro falsy

                        0 and 5

                    . 0 já é falsy

                    . Python nem olha o 5

                or

                    Para no primeiro truthy

                        0 or 5

                    . 0 é falsy

                    . Vai para 5

                    . 5 é truthy → para aqui

                not

                    Não tem curto-circuito, só inverte o valor.

                        not 0   # True

            POR QUE ISSO É IMPORTANTE?

                Evita erros

                        lista = []
                        lista and lista[0]

                    não dá erro, porque lista é falsy

                Mais performance:

                    . Menos operações

                    . Menos avaliações

            FRASE PARA MEMORIZAR:

                and para no falso
                or para no verdadeiro

    =====================================================================

    Operadores relacionais:

        - Operadores relacionais comparam valores e geram um resultado lógico:
            
            True ou False.

        Eles respondem perguntas como:

            É maior?

            É menor?

            É igual?

            É diferente?

            Sem operadores relacionais, não existe decisão no programa.

        COMO PENSAR COMO LÓGICO (ANTES DO CÓDIGO):

            Sempre leia como pergunta humana:

                . “Esse valor é maior que aquele?”

                . “São iguais?”

                . “É diferente?”

            O resultado nunca é número, é verdadeiro ou falso.

        OPERADORES RELACIONAIS EM PYTHON:

            | Operador | Significado    |
            | -------- | -------------- |
            |  >       | maior que      |
            |  <       | menor que      |
            |  >=      | maior ou igual |
            |  <=      | menor ou igual |
            |  ==      | igual          |
            |  !=      | diferente      |

        EXEMPLOS EXPLICADOS:

            . Maior / Menor

                print(10 > 5)    # True
                print(3 < 1)     # False

            . Maior ou igual / Menor ou igual

                print(18 >= 18)  # True
                print(5 <= 3)    # False

            . Igualdade (==)

                print(10 == 10)  # True
                print(10 == 5)   # False

            . Diferente (!=)

                print(10 != 5)   # True
                print(10 != 10)  # False

        Atenção:

            x = 10   # atribuição
            x == 10  # comparação


        Relações com texto:

            - Strings também podem ser comparadas com operadores relacionais.


            COMPARANDO TEXTO:

                nome = "Renato"
                print(nome == "Renato")   # True
                print(nome != "Ana")      # True

            Comparação de texto é exata (maiúscula ≠ minúscula).

            Python compara strings:

                . caractere por caractere

                . seguindo a ordem alfabética (tabela Unicode / ASCII)

                PS: Não é “tamanho”, é ordem lexical.

            COMO O PYTHON COMPARA STRINGS:

                A comparação acontece:

                    1 - Do primeiro caractere

                    2 - Depois o segundo

                    3 - Até encontrar diferença

                Exemplo mental:

                    "casa" vs "carro"
                    c  == c
                    a  == a
                    s  >  r   → decisão aqui

            EXEMPLOS IMPORTANTES:

                . Ordem alfabética

                    print("ana" < "bia")   # True
                    print("casa" > "carro")  # True

                . Maiúscula x minúscula (pegadinha!)

                    print("ana" < "Ana")  # False

                PS: Letras maiúsculas vêm antes das minúsculas.

                . Comparando palavras:

                    palavra = "banana"
                    print(palavra >= "abacate")

            COMPARAÇÃO COM len():

                Às vezes o que você quer não é ordem, é tamanho:

                    print(len("casa") > len("sol"))

                Comparar tamanho ≠ comparar string diretamente.

        COMPARAÇÕES COMBINADAS:

            idade = 20
            print(idade >= 18 and idade <= 65)

        Mental: “Está entre 18 e 65?”

        ERROS COMUNS

            . Usar = no lugar de ==
            . Comparar tipos diferentes sem querer
            . Esquecer que o resultado é True/False
            . Fazer comparação sem sentido lógico

            . Achar que "z" > "ab" por tamanho
            . Ignorar maiúsculas e minúsculas
            . Comparar string quando queria comparar tamanho
            . Não normalizar entrada do usuário

            Regra de ouro:

                Operador relacional sempre responde uma pergunta.

                Python compara texto como dicionário, não como humano.

        FRASES-CHAVE PARA MEMORIZAR

            . Relacional compara
            . Lógico combina
            . Aritmético calcula
            . Atribuição guarda

            . String é comparada por ordem, não por tamanho.
            . Maiúscula vem antes de minúscula.
            . Normalize antes de comparar.

        DICAS:

            . Leia cada comparação em voz alta
            . Teste com valores simples
            . Use parênteses para clareza
            . Combine com operadores lógicos

            . Normalize strings
            . Leia comparação como dicionário
            . Use len() quando quiser tamanho
            . Teste com maiúsculas e minúsculas

    =====================================================================

    in e is:

        - in pergunta se algo está dentro de outra coisa.
        
        - is pergunta se duas variáveis apontam para o MESMO objeto.

        Eles não fazem a mesma coisa e não são intercambiáveis.

        COMO PENSAR COMO LÓGICO:

            Antes de escolher:

                Quero saber se pertence? → in

                Quero saber se é o mesmo objeto na memória? → is

            Valor igual ≠ objeto igual.

        in — pertinência:

            - Verifica se um elemento está contido em uma sequência ou coleção.

            Funciona com:

                str

                list

                tuple

                set

                dict (verifica chaves)
            
            . Exemplos com string:

                print("a" in "casa")     # True
                print("z" in "casa")     # False

            . Exemplos com lista

                numeros = [1, 2, 3]
                print(2 in numeros)      # True
                print(5 in numeros)      # False

            . Exemplo com dicionário

                dados = {"nome": "Renato", "idade": 20}
                print("nome" in dados)   # True
                print("Renato" in dados) # False

            Em dicionários, in verifica chaves, não valores.

        is — identidade

            - Verifica se duas variáveis apontam para o mesmo objeto na memória.

            Exemplo simples:

                a = None
                print(a is None)   # True

            Uso correto clássico de is.

            Exemplo com números (pegadinha)

                a = 256
                b = 256
                print(a is b)   # True (por otimização interna)

                a = 1000
                b = 1000
                print(a is b)   # Pode ser False

            Não confie em is para comparar valores.

            Exemplo com listas:

                a = [1, 2, 3]
                b = [1, 2, 3]

                print(a == b)   # True (valores iguais)
                print(a is b)   # False (objetos diferentes)

        COMPARAÇÃO FINAL

            | Operador | Pergunta           |
            | -------- | ------------------ |
            | `in`     | Está dentro?       |
            | `is`     | É o mesmo objeto?  |
            | `==`     | Tem o mesmo valor? |

        ERROS COMUNS

            . Usar is no lugar de ==
            . Comparar string com is
            . Usar in achando que compara igualdade
            . Não entender dicionário com in

            Regra de ouro:

                Para valores → ==
                Para identidade → is

        FRASES-CHAVE PARA MEMORIZAR:

            in é pertinência
            
            is é identidade

            Igual não é o mesmo

        DICAS:

            . Leia o operador como pergunta
            . Nunca use is para comparar valor
            . Use is None sempre
            . Teste com listas para entender memória

    =====================================================================

    Incremento / Decremento:

        - Incrementar é aumentar um valor passo a passo.

        - Decrementar é diminuir um valor passo a passo.

        Em Python não existe ++ ou --.

            Tudo é feito com operadores de atribuição.

        COMO PENSAR COMO LÓGICO:

            Leia sempre assim:

                “Pegue o valor atual, altere um pouco, e guarde de volta.”

            Isso é mudança de estado.

        FORMAS DE INCREMENTAR:

            . Forma clássica

                x = x + 1

            . Forma recomendada

                x += 1
            
            Ambas fazem a mesma coisa.

            . Incrementar por outro valor

                x += 5

        FORMAS DE DECREMENTAR:

            . Forma clássica

                x = x - 1

            . Forma recomendada

                x -= 1

            . Decrementar por outro valor

                x -= 3
        
        EXEMPLOS PRÁTICOS:

            . Contador

                contador = 0
                contador += 1
                contador += 1
                print(contador)  # 2

            . Contagem regressiva

                x = 5
                x -= 1
                x -= 1
                print(x)  # 3

            . Acumulador

                soma = 0
                soma += 10
                soma += 5
                print(soma)  # 15

        ERROS COMUNS

            . Tentar usar x++ ou x-- (isso não existe em Python)
            . Usar incremento sem inicializar
            . Confundir incremento com atribuição simples

            Regra de ouro:

                Sempre inicialize antes de incrementar.

        FRASES-CHAVE PARA MEMORIZAR

            
            Incrementar soma
            
            Decrementar subtrai
            
            Python não tem ++

        DICAS:

            . Inicialize sempre
            . Leia o código em voz alta
            . Use para contar, somar, iterar
            . Pense em estado, não em fórmula

    =====================================================================

    Precedência dos operadores e uso de um ou mais operadores:

        - Precedência define a ordem em que os operadores são avaliados.

        Se você não controlar a ordem, o Python controla por você — e isso
        nem sempre é o que você quer.

        Parênteses sempre vencem.

        COMO PENSAR COMO LÓGICO:

            Pergunte sempre:

                Qual parte deve ser calculada primeiro?

                Essa conta é clara para um humano?

                Preciso forçar a ordem com parênteses?
            
            Código claro > código curto.

        ORDEM DE PRECEDÊNCIA:

            Aritméticos:

                1. ()
                2. **
                3. * / // %
                4. + -

            Relacionais:

                5. > < >= <=
                6. == !=

            Lógicos

                7. not
                8. and
                9. or

            Atribuição

                10. = += -= *= /= ...

            Atribuição sempre por último.
        
        Exemplo 1 — Aritmética simples:

            resultado = 10 + 2 * 3
            print(resultado)   # 16

        PS: Multiplicação vem antes da soma.

        Exemplo 2 — Forçando ordem

            resultado = (10 + 2) * 3
            print(resultado)   # 36

        Exemplo 3 — Relacional + aritmético

            print(10 + 2 > 11)   # True

        PS: Soma primeiro, depois comparação.

        Exemplo 4 — Lógico + relacional

            idade = 17
            print(idade >= 18 or idade >= 16 and idade < 18)

        Avaliação real:

            >= e <
            and
            or

        Exemplo 5 — Com parênteses (melhor)

            print(idade >= 18 or (idade >= 16 and idade < 18))

        PS: Mesmo resultado, mais legível.

        USO DE MÚLTIPLOS OPERADORES:

            Ruim

                if a > b and c < d or e == f:

            Bom:

                if (a > b and c < d) or e == f:

        ERROS COMUNS

            . Confiar só na precedência
            . Esquecer parênteses
            . Código impossível de ler
            . Misturar tudo na mesma linha

            Regra de ouro:

                Se precisa pensar demais para entender, use parênteses.

        FRASES-CHAVE PARA MEMORIZAR:

            Parênteses mandam
            Potência vem cedo
            and vence or
            Atribuição é a última

        DICAS:

            . Sempre pense na ordem
            . Use parênteses por clareza
            . Misture operadores conscientemente
            . Leia a expressão em voz alta

        Tabela completa de precedência (maior → menor):

            | Prioridade | Operadores / forma                                                                | Observações rápidas                                |                                                                       |
            | ---------: | --------------------------------------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------- |
            |          1 | **Agrupamento / acesso**: `(...)`, `x[...]`, `x(...)`, `x.attr`                   | Parênteses, indexação, chamada de função, atributo |                                                                       |
            |          2 | **Await**: `await x`                                                              | Em async                                           |                                                                       |
            |          3 | **Potência**: `**`                                                                | **Associativa à direita**: `2**3**2 = 2**(3**2)`   |                                                                       |
            |          4 | **Unários**: `+x`, `-x`, `~x`                                                     | Ex.: `-n`, `+n`, bitwise NOT `~`                   |                                                                       |
            |          5 | **Multiplicativos**: `*`, `@`, `/`, `//`, `%`                                     | `@` é multiplicação matricial                      |                                                                       |
            |          6 | **Aditivos**: `+`, `-`                                                            | Soma/subtração                                     |                                                                       |
            |          7 | **Shifts**: `<<`, `>>`                                                            | Deslocamento de bits                               |                                                                       |
            |          8 | **Bitwise AND**: `&`                                                              |                                                    |                                                                       |
            |          9 | **Bitwise XOR**: `^`                                                              |                                                    |                                                                       |
            |         10 | **Bitwise OR**: `                                                                 | `                                                  |                                                                       |
            |         11 | **Comparações**: `<`, `<=`, `>`, `>=`, `!=`, `==`, `in`, `not in`, `is`, `is not` | Comparações podem “encadear”: `a < b < c`          |                                                                       |
            |         12 | **NOT lógico**: `not x`                                                           | `not` vem antes de `and/or`                        |                                                                       |
            |         13 | **AND lógico**: `and`                                                             |                                                    |                                                                       |
            |         14 | **OR lógico**: `or`                                                               |                                                    |                                                                       |
            |         15 | **Condicional (ternário)**: `x if cond else y`                                    | Avalia `cond` e escolhe `x` ou `y`                 |                                                                       |
            |         16 | **Lambda**: `lambda`                                                              | É o mais fraco entre “expressões normais”          |                                                                       |
            |         17 | **Walrus**: `:=`                                                                  | Atribuição como expressão (bem baixa)              |                                                                       |
            |         18 | **Atribuições**: `=`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`, `&=`, `^=`, `   | =`, `<<=`, `>>=`, `@=`                             | **Não é expressão** comum (é statement); fica “por último” na prática |

        Detalhes importantíssimos:

            ** (potência) é mais forte que unário, e é à direita:

                -2**2 vira -(2**2) = -4

                (-2)**2 = 4

            Comparações têm uma faixa única: tudo de < até is e in tem a mesma
            prioridade, e pode encadear:

                1 < x < 10 (equivale a 1 < x and x < 10, mas sem avaliar x duas 
                            vezes)
            
            Lógicos: not > and > or.

    =====================================================================

    Swap:

        - Swap é a troca de valores entre duas variáveis.

        Após um swap:

            . o valor de a vai para b

            . o valor de b vai para a

        As variáveis continuam as mesmas — só os valores mudam.

        COMO PENSAR COMO LÓGICO (ESSENCIAL):

            Antes do código, pense assim:

                Tenho dois valores

                Quero trocar os valores

                Não posso perder nenhum no processo

            O problema central do swap é não sobrescrever um valor antes de 
            salvá-lo.

        O ERRO CLÁSSICO (NÃO FUNCIONA):

                a = 5
                b = 10

                a = b
                b = a

            O que acontece de verdade:

                . a vira 10

                . b recebe a (que já é 10)

                . o 5 se perde

            Esse erro mostra por que o swap existe.

        SWAP COM VARIÁVEL AUXILIAR (FORMA UNIVERSAL):

            - Funciona em qualquer linguagem.

                a = 5
                b = 10
                
                temp = a
                a = b
                b = temp
            
            Leitura humana:

                1. Guarde a em temp

                2. Coloque b em a

                3. Coloque temp em b

            . Seguro
            . Didático
            . Ótimo para aprender lógica

        SWAP EM PYTHON (FORMA IDIOMÁTICA):

            - Python permite swap sem variável auxiliar, usando desempacotamento.

                a = 5
                b = 10

                a, b = b, a

            O que acontece internamente:

                . Python cria uma tupla temporária

                . Depois distribui os valores

            Não é mágica, é recurso da linguagem.

        SWAP COM EXPRESSÕES (IMPORTANTE):

                x = 3
                y = x + 2

                x, y = y, x

            Primeiro o Python avalia tudo do lado direito, depois faz as 
            atribuições.

            Isso evita conflito de valores.

        SWAP ≠ COMPARAÇÃO:

            Errado:

                a == b

            Correto:

                a, b = b, a

            == compara, não troca.

        SWAP E MEMÓRIA (IDEIA IMPORTANTE):

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            . As referências são trocadas
            . As listas não são copiadas

        ERROS COMUNS

            . Fazer a = b; b = a
            . Confundir swap com comparação
            . Achar que Python copia valores
            . Não entender avaliação do lado direito

            Regra de ouro:

                Nunca sobrescreva um valor antes de salvá-lo.

        FRASES-CHAVE PARA MEMORIZAR

            Swap troca valores, não variáveis
            Swap exige preservar informação
            Python avalia antes de atribuir

        DICAS:

            . Pense em preservar valores
            . Lado direito é avaliado primeiro
            . Use swap Python quando possível
            . Use variável auxiliar para entender lógica

        SWAP COM ITERÁVEIS:

            - Swap em iteráveis é a troca de elementos dentro de uma estrutura.

            . Iterável = algo que tem vários valores (lista, string, tupla, etc.)

            . Swap = trocar posições ou referências

            . Base de ordenação, inversão, reorganização

            Quase todo algoritmo clássico usa swap em iteráveis.

            COMO PENSAR COMO LÓGICO:

                Antes de fazer swap em iterável, pergunte:

                    Vou trocar valores ou posições?

                    O iterável é mutável ou imutável?

                    A troca é local (índices) ou global (estrutura inteira)?

                Isso define a técnica.

            1) SWAP DE ELEMENTOS EM LISTAS (FORMA BÁSICA)

                - Listas são mutáveis, então podemos trocar posições.

                    lista = [10, 20, 30]
                    lista[0], lista[2] = lista[2], lista[0]

                Resultado:

                    [30, 20, 10]

                Troca de elementos, não da lista inteira.

            2) SWAP COM VARIÁVEL AUXILIAR (DIDÁTICO)

                    lista = [1, 2, 3]

                    temp = lista[0]
                    lista[0] = lista[1]
                    lista[1] = temp

            3) SWAP EM ITERÁVEIS IMUTÁVEIS (STRING / TUPLA)

                - Strings e tuplas não podem ser alteradas diretamente.

                Errado:

                    s = "abc"
                    s[0], s[2] = s[2], s[0]

                Correto (converter):

                    s = "abc"
                    lista = list(s)
                    lista[0], lista[2] = lista[2], lista[0]
                    s = "".join(lista)

                Imutável → cria novo objeto.

            4) SWAP DE FATIAS (SLICES)

                Inverter partes

                    lista = [1, 2, 3, 4, 5]
                    lista[:2], lista[2:] = lista[2:], lista[:2]

                Resultado:

                    [3, 4, 5, 1, 2]

                Muito usado em rotações.

            5) SWAP PARA INVERSÃO DE LISTA (ALGORÍTMICO)

                . Manual (com dois índices)

                    lista = [1, 2, 3, 4]
                    i = 0
                    j = len(lista) - 1

                    while i < j:
                        lista[i], lista[j] = lista[j], lista[i]
                        i += 1
                        j -= 1

            Aqui o swap é o motor da inversão.

            6) SWAP EM ALGORITMOS DE ORDENAÇÃO

                . Bubble sort (exemplo clássico)

                    for i in range(len(lista)):
                        for j in range(len(lista) - 1):
                            if lista[j] > lista[j + 1]:
                                lista[j], lista[j + 1] = lista[j + 1], lista[j]

                Sem swap, não existe ordenação.

            7) SWAP DE REFERÊNCIAS (LISTAS INTEIRAS)

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            Aqui não troca elementos — troca quem aponta para quem.

            ERROS COMUNS

                . Tentar trocar string direto
                . Confundir troca de elemento com troca de referência
                . Errar índice
                . Sobrescrever valor antes do swap

                Regra de ouro:

                    Swap em iteráveis sempre depende de índice ou referência.

            FRASES-CHAVE PARA MEMORIZAR:

                Lista troca elemento
                String cria outra
                Swap move posição
                Algoritmo vive de swap

            DICAS:

                . Identifique mutabilidade
                . Use índices conscientemente
                . Swap é ferramenta, não fim
                . Algoritmo = repetição + comparação + swap

    =====================================================================

    Casting:

        - Casting é a conversão explícita de um tipo de dado para outro.

        Em Python, usamos funções para isso:

            . int()

            . float()

            . str()

            . bool()

            . list(), tuple(), set()

        Casting não muda o valor em si, muda como o Python interpreta esse valor.

        COMO PENSAR COMO LÓGICO:

            Sempre se pergunte:

                Que tipo esse dado tem agora?

                Que tipo eu preciso para operar?

                A conversão é segura ou pode gerar erro?

            Erros de casting são erros de lógica, não de sintaxe.

        CASTING NUMÉRICO:

            . int()

                - Converte para inteiro (corta decimais).

                    print(int(3.9))     # 3
                    print(int("10"))    # 10

                Erro:

                    int("abc")

            . float()

                Converte para decimal.

                    print(float(10))       # 10.0
                    print(float("3.14"))   # 3.14

            . str()

                Converte para texto.

                    idade = 20
                    print("Idade: " + str(idade))

                Muito usado em saída de dados.

        CASTING LÓGICO (bool()):

            - Converte valores para True ou False.

            . Regras importantes

                bool(0)        # False
                bool(1)        # True
                bool(-5)       # True
                bool("")       # False
                bool("abc")    # True
                bool([])       # False
                bool([1, 2])   # True

            Falsy:

                0
                0.0
                ""
                []
                {}
                None

            Todo o resto é Truthy.

        CASTING COM ITERÁVEIS:

            . String → lista

                list("abc")   # ['a', 'b', 'c']

            . Lista → tupla

                tuple([1, 2, 3])

            . Lista → conjunto

                set([1, 1, 2, 3])   # {1, 2, 3}

            Conjunto remove duplicados.

        CASTING AUTOMÁTICO (IMPLÍCITO):

            Python faz isso em alguns casos:

                print(10 + 2.5)   # 12.5

            O inteiro vira float automaticamente.

            Mas não confie demais nisso.

        ERROS COMUNS:

            . Esquecer que input() retorna str
            . Converter string inválida para número
            . Achar que int() arredonda
            . Usar casting sem entender o dado

            Regra de ouro:

                Sempre valide antes de converter.

        FRASES-CHAVE PARA MEMORIZAR:

            Casting muda o tipo, não o dado
            int() corta
            bool() segue truthy/falsy
            input() sempre retorna string

        DICAS:

            . Converta logo após a entrada
            . Teste casos inválidos
            . Use try/except quando avançar
            . Entenda truthy/falsy profundamente

    =====================================================================

    Coerção:

        - Coerção é quando o Python converte automaticamente um tipo em outro 
        durante uma operação.

        . Não é você que manda converter

        . É o Python tentando não quebrar o programa

        . Acontece principalmente em operações mistas

        Coerção ≠ Casting

            Casting → você manda

            Coerção → Python decide

        COMO PENSAR COMO LÓGICO:

            Pergunte sempre:

                Estou misturando tipos diferentes?

                Existe um tipo “mais abrangente”?

                O Python precisa escolher um tipo comum?

            O Python nunca perde informação na coerção (sempre sobe o tipo).

        REGRA FUNDAMENTAL DA COERÇÃO:

            - O Python promove o tipo mais simples para o mais geral.

            Exemplo clássico:

                int  →  float  →  complex

            Nunca o contrário.

        COERÇÃO NUMÉRICA:

            . int + float → float

                    print(10 + 2.5)      # 12.5
                    print(type(10 + 2.5))  # float

                O 10 vira 10.0 automaticamente.

            . float + complex → complex

                print(2.5 + 1j)

        COERÇÃO EM OPERAÇÕES LÓGICAS:

            . Booleano como número

                    print(True + 1)    # 2
                    print(False * 10)  # 0
            
                Porque:

                    True → 1
                    False → 0

                Isso é coerção implícita.

        COERÇÃO EM EXPRESSÕES CONDICIONAIS:

                if 10:
                    print("Executa")

            O 10 vira True automaticamente.

                if "":
                    print("Não executa")

            String vazia → False.

            Aqui entra truthy e falsy (coerção para bool).

        COERÇÃO QUE NÃO EXISTE (IMPORTANTE):

            Python não faz coerção perigosa.

            Não existe:

                "10" + 5

            Não existe:

                "3" * 2.5

            Aqui o Python exige casting explícito.

        COERÇÃO EM OPERADORES LÓGICOS (and, or):

            Pegadinha importante:

                    print(0 or 10)    # 10
                    print(10 and 5)   # 5

                and e or:

                    . não retornam True/False

                    . retornam um dos operandos

                Eles usam coerção para decidir, mas retornam valores reais.

        COERÇÃO EM COMPARAÇÕES:

                print(1 == True)   # True
                print(0 == False)  # True

            Booleano é subclasse de int.

            Comparação funciona, mas não é boa prática.

        COERÇÃO × CASTING (tabela mental)

            | Conceito | Quem decide | Exemplo     |
            | -------- | ----------- | ----------- |
            | Casting  | Você        | `int("10")` |
            | Coerção  | Python      | `10 + 2.5`  |

        ERROS COMUNS

            . Confiar demais na coerção
            . Misturar tipos sem perceber
            . Achar que Python converte string para número
            . Usar coerção como “atalho lógico”

            Regra de ouro:

                Coerção ajuda, mas não substitui casting consciente.

        FRASES-CHAVE PARA MEMORIZAR:

            Coerção é automática
            Python sobe o tipo
            Nunca perde informação
            String não vira número sozinha

        DICAS:

            . Não confie em coerção silenciosa
            . Prefira casting explícito
            . Teste tipos com type()
            . Código claro > código esperto

    =====================================================================

    Caracteres de controle:

        - Caracteres de controle são sequências especiais que começam com \ e 
        alteram a forma como o texto é interpretado ou exibido.

        Eles servem para:

            . Quebra de linha

            . Tabulação

            . Aspas dentro de texto

            . Sons, cursores e efeitos

            . Unicode e caracteres especiais

        Não aparecem “visualmente”, mas controlam o comportamento do texto.

        COMO PENSAR COMO LÓGICO:

            Sempre pense assim:

                Texto normal → aparece

                Caractere de controle → controla o texto

            Eles não são letras, são comandos embutidos.

        TABELA COMPLETA — CARACTERES DE CONTROLE EM PYTHON:

            | Sequência | Nome            | O que faz                    |
            | --------- | --------------- | ---------------------------- |
            | `\n`      | New line        | Quebra de linha              |
            | `\t`      | Tab             | Tabulação horizontal         |
            | `\\`      | Backslash       | Mostra `\`                   |
            | `\'`      | Aspa simples    | Mostra `'`                   |
            | `\"`      | Aspa dupla      | Mostra `"`                   |
            | `\r`      | Carriage return | Retorna ao início da linha   |
            | `\b`      | Backspace       | Apaga um caractere anterior  |
            | `\f`      | Form feed       | Avança página (legado)       |
            | `\v`      | Vertical tab    | Tabulação vertical           |
            | `\a`      | Bell            | Alerta sonoro (se suportado) |
            | `\0`      | Null            | Caractere nulo               |

        CARACTERES NUMÉRICOS (ASCII / OCTAL / HEX):

            . Octal

                "\101"   # 'A'

            . Hexadecimal

                "\x41"   # 'A'
            
            Pouco usados hoje, mas existem.

        UNICODE (ESSENCIAL EM PYTHON):

            . Unicode de 16 bits

                "\u2764"   # ❤

            . Unicode completo (32 bits)

                "\U0001F600"   # 😀

            Python é totalmente Unicode.

        STRING RAW (IMPORTANTE):

            - String raw ignora caracteres de controle.

                print(r"C:\Users\Renato\Docs")

            Sem r, isso quebraria (\U, \D, etc.).

        EXEMPLOS PRÁTICOS:

            Quebra de linha:

                print("Linha 1\nLinha 2")

            Tabulação:

                print("Nome\tIdade\tCidade")

            Aspas dentro de texto:

                print("Ele disse: \"Olá\"")

            \r sobrescrevendo linha

                print("Carregando...\rFeito!")

            Unicode

                print("Coração: \u2764")

        ERROS COMUNS

            . Esquecer que \n quebra linha
            . Caminhos do Windows sem string raw
            . Usar \ achando que é caractere normal
            . Confundir \t com espaços

            Regra de ouro:

                Se começa com \, não é letra — é comando.

        FRASES-CHAVE PARA MEMORIZAR:

            \n quebra
            \t organiza
            \r retorna
            r"" protege
            Unicode manda

        DICAS:

            . Use \n para clareza
            . Use \t para alinhamento simples
            . Sempre use r"" em caminhos
            . Unicode funciona em tudo

    =====================================================================

    Números (inteiros e reais):

        - Números representam valores matemáticos usados em cálculos, 
        comparações e decisões.

        Em Python, os principais tipos numéricos básicos são:

            Inteiros (int) → números sem parte decimal

            Reais (float) → números com parte decimal

        Python não limita o tamanho de inteiros (diferente de C, Java).

        COMO PENSAR COMO LÓGICO:

            Antes de usar números, pergunte:

                Esse valor pode ter vírgula?

                Preciso de exatidão absoluta ou aproximação?

                Esse número vai crescer muito?

                Vou usar em comparações, cálculos ou controle de fluxo?

            A escolha entre int e float é lógica, não sintática.

        1) NÚMEROS INTEIROS (int)

            O que são?

                . Valores sem parte decimal

                . Positivos, negativos ou zero

                . Precisos (exatos)

                EX:

                    a = 10
                    b = -3
                    c = 0

            Características importantes:

                . Precisão exata

                . Sem limite de tamanho:

                    x = 10**100

            Ideais para:

                . contadores

                . índices

                . quantidades

                . idade, unidades, peças

            Operações comuns com int:

                10 + 3     # soma
                10 - 3     # subtração
                10 * 3     # multiplicação
                10 // 3    # divisão inteira
                10 % 3     # resto
                10 ** 3    # potência

            Divisão com inteiros:

                10 / 2     # 5.0 (float!)

            Toda divisão / gera float, mesmo entre inteiros.

        2) NÚMEROS REAIS (float)

            O que são?

                . Valores com parte decimal

                . Representados internamente em ponto flutuante

                . Aproximados (não exatos)

                EX:

                    x = 3.14
                    y = -0.5
                    z = 10.0

            Características importantes:

                . Possuem erro de precisão

                . Não são ideais para dinheiro

                . Bons para:

                    médias

                    medidas

                    cálculos científicos

                    porcentagens

            PROBLEMA CLÁSSICO DE PRECISÃO:

                print(0.1 + 0.2)  # 0.30000000000000004

            Isso não é bug, é limitação matemática do float.

        3) CONVERSÃO ENTRE INT E FLOAT

            . int()

                    int(3.9)    # 3

                PS: Corta, não arredonda.

            . float()

                    float(10)   # 10.0

            . round()

                round(3.6)      # 4
                round(3.14159, 2)  # 3.14

        4) OPERAÇÕES MISTAS (COERÇÃO)

            EX:

                10 + 2.5   # 12.5

            O int é convertido automaticamente para float.

            Python sempre sobe o tipo, nunca desce.

        5) COMPARAÇÕES COM NÚMEROS

                10 > 5
                3.5 <= 4
                10 == 10.0   # True

            Cuidado com float:

                0.1 + 0.2 == 0.3   # False

            Melhor:

                abs((0.1 + 0.2) - 0.3) < 1e-9

        6) FUNÇÕES NUMÉRICAS IMPORTANTES

            | Função     | Uso             |
            | ---------- | --------------- |
            | `abs()`    | valor absoluto  |
            | `round()`  | arredondar      |
            | `pow()`    | potência        |
            | `min()`    | menor           |
            | `max()`    | maior           |
            | `sum()`    | soma            |
            | `divmod()` | divisão + resto |

        ERROS COMUNS

            . Usar float para dinheiro
            . Comparar floats diretamente
            . Achar que int() arredonda
            . Esquecer que / gera float

            Regra de ouro:

                Contagem → int
                Medida → float

        FRASES-CHAVE PARA MEMORIZAR:

            Inteiro é exato
            Float é aproximado
            Divisão sempre flutua
            Precisão importa

        int, long e limites de 32/64 bits:

            Em Python moderno (3.x), não existe mais long separado.
            
            Todo inteiro é do tipo int e cresce automaticamente.

            Limites de 32 e 64 bits não se aplicam da mesma forma em Python.

            1) int × long (histórico importante)

                . Python 2 (ANTIGO)

                    int → limitado (32 ou 64 bits)

                    long → inteiros grandes (ex: 1234567890123456789L)

                . Python 3 (ATUAL)

                    long não existe

                    Tudo é int

                    Inteiros têm precisão arbitrária

                    O Python cuida do tamanho automaticamente.

            2) O MITO DOS 32 E 64 BITS EM PYTHON

                Python não limita inteiros a 32 ou 64 bits como C/Java.

                Em linguagens como C:

                    int → 32 bits

                    long → 64 bits (depende da arquitetura)

                Em Python:

                    int cresce conforme necessário

                    O limite é memória disponível

                Não ocorre overflow aritmético em int.

            3) ENTÃO O QUE SIGNIFICA 32 OU 64 BITS?

                Isso se refere à arquitetura da máquina e ao ponteiro de memória, 
                não ao número em si.

                . Python 32-bit:

                    - Ponteiros de 32 bits

                    - Menos memória endereçável

                . Python 64-bit:

                    - Ponteiros de 64 bits

                    - Mais memória endereçável

                O valor inteiro continua ilimitado, só o consumo de memória muda.

            4) CUSTO DE MEMÓRIA DE INTEIROS GRANDES

                Inteiros grandes:

                    Usam mais memória

                    São mais lentos que inteiros pequenos

                Python usa múltiplas “palavras” internas para representar
                o número.

                Python é mais seguro, porém menos previsível em performance 
                extrema.

            5) FLOAT AINDA TEM LIMITE (IMPORTANTE)

                Apesar do int ser ilimitado:

                    - float continua limitado (IEEE 754)

                    - Aproximadamente:

                        . ~1.8 × 10³⁰⁸ (máximo)

                        . ~15–17 dígitos de precisão
                
                EX:

                    x = 1e308
                    x * 10   # inf

                Overflow ainda existe em float.

        CAMPO DE ESTUDO — FUNÇÕES ESPECIAIS DE int E float:

            - int e float não são apenas números: são objetos com métodos 
            próprios.

            Esses métodos servem para:

                Inspecionar o número

                Converter formatos

                Trabalhar com bits

                Lidar com precisão

                Representação interna
            
            Isso diferencia Python de linguagens “mais simples”.

            FUNÇÕES ESPECIAIS DE int:

                1. bit_length():

                    Retorna quantos bits são necessários para representar o 
                    inteiro.

                    EX:

                        n = 10
                        print(n.bit_length())  # 4

                    10 em binário → 1010 (4 bits)

                2. to_bytes() e from_bytes()

                    . to_bytes()

                        Converte inteiro para bytes.

                            n = 1024
                            b = n.to_bytes(2, byteorder="big")
                            print(b)
                    
                    . from_bytes()

                        Faz o caminho inverso.

                            n2 = int.from_bytes(b, byteorder="big")
                            print(n2)

                3. __int__() (conceitual)

                    Conversão interna para inteiro.

                        int(3.7)  # usa __int__

                    Raramente usado diretamente, mas fundamental para coerção.

                4. Representações: bin(), oct(), hex()

                    n = 42
                    print(bin(n))  # 0b101010
                    print(oct(n))  # 0o52
                    print(hex(n))  # 0x2a

                5. int() com base (MUITO IMPORTANTE)

                    int("1010", 2)   # 10
                    int("FF", 16)    # 255
                    int("77", 8)     # 63

                Converte string em número usando base numérica.
            
            FUNÇÕES ESPECIAIS DE float:

                1. is_integer()

                    Verifica se o float representa um inteiro exato.

                        x = 10.0
                        y = 10.5

                        print(x.is_integer())  # True
                        print(y.is_integer())  # False

                    Muito útil para validações.
                
                2. as_integer_ratio()

                    Retorna o float como fração exata.

                        x = 0.75
                        print(x.as_integer_ratio())  # (3, 4)

                    Mostra como o float é representado matematicamente.

                3. hex() (do float!)

                        x = 3.14
                        print(x.hex())

                    E o inverso:

                        float.fromhex(x.hex())

                    Representação exata do float em hexadecimal.

                4. __float__() (conceitual)

                    Usado quando Python força conversão para float:

                        float(10)

                    Importante para coerção automática.

            QUANDO USAR ISSO NA VIDA REAL

                bit_length() → segurança, criptografia

                to_bytes() → arquivos, rede

                is_integer() → validação de cálculo

                as_integer_ratio() → precisão matemática

                int(base) → parsing de dados

                hex/bin → debug de baixo nível

    =====================================================================

    strings e caracteres:

    =====================================================================

    parsings:

    =====================================================================

    Blocos e escopos:

    =====================================================================

    Estruturas condicionais / ternários:

    =====================================================================

    Estruturas de repetição:

    =====================================================================

    break, continue e pass:

    =====================================================================

    Variável acumuladora e Variável atribuidora

    =====================================================================

    Iterações e Iteráveis:

    =====================================================================

    Funções e lambdas:

    =====================================================================

    Recursões:

    =====================================================================

    Variáveis globais e locais:

    =====================================================================

    Operadores bit-wise:

    =====================================================================

    Listas, Arrays e Vetores:

    =====================================================================

    Índices:

    =====================================================================

    In place:

    =====================================================================

    Janelas:

    =====================================================================

    Slicing:

    =====================================================================

    Divisão e conquista:

    =====================================================================

    Rotação:

    =====================================================================

    Listas, Arrays e Vetores circulares:

    =====================================================================

    Matrizes:

    =====================================================================

    Diagonais:

    =====================================================================

    Matriz circular:

    =====================================================================

    Tuplas:

    =====================================================================

    Dicionários:

    =====================================================================

    Conjuntos:

    =====================================================================

    tecnica de ponteiros:

    =====================================================================

    Divisão e conquista:

    =====================================================================

    números aleatórios:

    =====================================================================

    Módulos, Bibliotecas e importações:

    =====================================================================

    Alias:

    =====================================================================

    Garbage:

    =====================================================================

    shuffle:

    =====================================================================

    Arquivos:

    =====================================================================

Um pouco sobre POO:

    Objetos e classes

    Variáveis de classe e Construtor

    Métodos

    atributos e propriedades de classe

    atributos privados, protegidos e públicos

    métodos privados, protegidos e públicos

    Encapsulamento

    Composição, herança e delegação

    Polimorfismo

    Sub-tipagem

    Métodos de classe

    Métodos abstratos

    Métodos estáticos

    self e cls

    Métodos mágicos

    DataClass

    Setups, interfaces e Managers

    SOLID

Um pouco sobre Estruturas de dados:

    listas / vetores e matrizes não ordenadas

    listas / vetores e matrizes ordenadas

    matrizes

    Torre de Hanoi

    algoritmos de busca

    algoritmo de Ordenações

    pilhas

    filas

    fila de prioridade

    fila circular

    fila de extremidade dupla

    deques

    Lista encadeada

    ávores

    hash tables

    grafos

    Busca em profundidade

    Busca em largura

    Busca gulosa

    Busca A*

    Algoritmo de Dijkstra
