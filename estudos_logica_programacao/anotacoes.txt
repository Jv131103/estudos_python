- Um programa ou software, √© o que podemos chamar de intelig√™ncia do computador

- O hardware √© a m√°quina, a parte f√≠sica

- Em computa√ß√£o, dados s√£o a representa√ß√£o simb√≥lica de um fato ou acontecimento.
Os fatos podem ser, nomes, datas, valores num√©ricos, imagens, etc. Ou seja,
qualquer coisa que possa ser medido, comparado ou representados no computador.

- Os s√≠mbolos mais comuns s√£o as letras e os n√∫meros. (As imagens e os sons s√£o representados
no computador por uma sequencia de n√∫mero).

- Uma informa√ß√£o √© um dado, ou conjunto de dados, ou o o resultado da transforma√ß√£o de um
conjunto de dados que, dentro de determinado contexto, fa√ßa sentido para algu√©m. Poe exemplo,
uma ficha m√©dica, ou um formul√°rio de cadastro.

- Qualquer fato, pode ser representado simbolicamente? N√£o. Por que certos, fatos,
n√£o podem ser representados como s√£o na realidade, por conta de n√£o poderem ser interpretados
l√≥gico-matematicamente. Outros, por conta de n√£o serem duais, assim n√£o interpretados, como zeros
e uns. Emo√ß√µes, sabores e sentimentos s√£o exemplos de fatos que n√£o podem ser representados,
por serem complexas e por terem reprodu√ß√£o al√©m do l√≥gico.

SOBRE SISTEMA BIN√ÅRIO

- S√£o representados por 0s e 1s, embora, haja outros sistemas, como tern√°rios,
decimais, hexadecimais e octais.

- O computador atualmente, entende apenas 0s e 1s que representam ligado e desligado,
tal que seguem o princ√≠pio de ebtrada e sa√≠da de energia no hardware.

- Possui um sistema de numera√ß√£o onde cada d√≠gito, aqui chamado de bit, tem apenas dois valores
poss√≠veis, ou seja, 0 e 1

- No sistema decimal, podemos representar at√© 10 elementos com um √∫nico d√≠gito:

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9

- No sistema bin√°rio, podemos representar apenas 2 com um √∫nico bit.

    0, 1

- Para se poder rtepresentar mais elementos, √© necess√°rio acrescentar outros d√≠gitos e bits.

- O 11¬∞ elemento no sistema decimal e'representado por 10.

    IMPORTANTE: Na computa√ß√£o, o valor 0 √© super significativo quanto a identificar elementos

- No sistema bin√°rio, o 3¬∞ elemento, j√° que s√≥ podemos representar o 2 como um √∫nico bit, ser√°
o 10.

- Tabela de 0, 20

    Decimal | Bin√°rio
    0       | 0
    1       | 1
    2       | 10
    3       | 11
    4       | 100
    5       | 101
    6       | 110
    7       | 111
    8       | 1000
    9       | 1001
    10      | 1010
    11      | 1011
    12      | 1100
    13      | 1101
    14      | 1110
    15      | 1111
    16      | 10000
    17      | 10001
    18      | 10010
    19      | 10011
    20      | 10100

- No sistema decimal, cada d√≠gito adicional aumenta em 10 vezes a capacidade de contagem, ao passo
que no bin√°rio, cada bit adicional aumenta em 2 vezes.

- Qual a capacidade de contagem de um n√∫mero com 3 d√≠gitos?

    10**3 = 1000

    - Vai de 0 a 999

- Qual a capacidade de contagem de um n√∫mero com 3 bits?

    2**3 = 8

    - Vai de 0 a 7

- Como saber quanto um bin√°rio vale em decimal?

    EX:

        1       0       0       1       1       0       1       0       1       0       1       1       1       0
        2**13   2**12   2**11   2**10   2**9    2**8    2**7    2**6    2**5    2**4    2**3    2**2    2**1    2**0
        8192    4096    2048    1024    512     256     128     64      32      16      8       4       2       1
        8192    0       0       1024    512     0       128     0       32      0       8       4       2       0

        8192 + 0 + 0 + 1024 + 512 + 0 + 128 + 0 + 32 + 0 + 8 + 4 + 2 + 0 =  9902


        1¬∞ linha: S√≠mbolo bin√°rio
        2¬∞ linha: Resutado do valor 2**n
        3¬∞ linha: Resultado do valor de 2**n * s√≠mbolo bin√°rio

        10011011

        2**7 = 128 * 1 = 128
        2**6 = 64 * 0 = 0
        2**5 = 32 * 0 = 0
        2**4 = 16 * 1 = 16
        2**3 = 8 * 1 = 8
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 1 = 1

        128 + 16 + 8 + 2 + 1 = 155

- Como saber quanto um decimal vale em bin√°rio?

    EX: 100

    100 / 2 = 50, resto 0
    50 / 2 = 25, resto 0
    25 / 2 = 12, resto 1
    12 / 2 = 6, resto 0,
    6 / 2 = 3, resto 0
    3 / 2 = 1, resto 1,
    1 / 2 = resto 1, pois 1 n√£o divide 2

    resultado dos restos: 0010011

    inverte ficar√°: 1100100

- Pr√°tico:

    Exerc√≠cio 1 - Foi vista na videoaula a convers√£o do n√∫mero
    bin√°rio 10011010111001 para o seu equivalente decimal que
    resultou em 9913.

    Acrescente um bit 0 √† direita (o menos significativo) deste
    n√∫mero bin√°rio e veja que n√∫mero decimal obter√°.
    
    Divida este novo n√∫mero decimal obtido pelo decimal anterior e
    analise o resultado.

        100110101110010

        2**14 = 16384 * 1 = 16384
        2**13 = 8192 * 0 = 0
        2**12 = 4096 * 0 = 0
        2**11 = 2048 * 1 = 2048
        2**10 = 1024 * 1 = 1024
        2**9 = 512 * 0 = 0
        2**8 = 256 * 1 = 256
        2**7 = 128 * 0 = 0
        2**6 = 64 * 1 = 64
        2**5 = 32 * 1 = 32
        2**4 = 16 * 1 = 16
        2**3 = 8 * 0 = 0
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 0 = 0

        16384 + 2048 + 1024 + 256 + 64 + 32 + 16 + 2 = 19826

        Divis√£o: 19826 // 9913 = 2


    Exerc√≠cio 2 - Com o resultado decimal obtido no exerc√≠cio 1, aplique a t√©cnica da divis√£o 
    sucessiva por 2 para obter seu equivalente bin√°rio. O resultado dever√° ser o n√∫mero original

        19826

        19826 // 2 = 9913, resto 0
        9913 // 2 = 4956, resto 1
        4956 // 2 = 2478, resto 0
        2478 // 2 = 1239, resto 0
        1239 // 2 = 619, resto 1
        619 // 2 = 309, resto 1
        309 // 2 = 154, resto 1
        154 // 2 = 77, resto 0
        77 // 2 = 38, resto 1
        38 // 2 = 19, resto 0
        19 // 2 = 9, resto 1
        9 // 2 = 4, resto 1
        4 // 2 = 2, resto 0
        2 // 2 = 1, resto 0
        1 // 2 = 1

        Resultado dos restos: 010011101011001

        Resultado final, invertido: 100110101110010

SOBRE O COMPUTADOR:

- A Mem√≥ria, √© onde se armazena e endere√ßa informa√ß√µes e dados. √â nela onde se permite
guardar informa√ß√µes e registr√°-las e mant√™-las enquanto o programa ou a m√°quina estiver ligada.
√â nela onde o processador se comunica retornando informa√ß√µes. Ela se divide em dois pontos:

    . Endere√ßo fixo: O local referente onde os dados est√£o armazenados

    . Conte√∫do varti√°vel: O conte√∫do que est√° armazenado no endere√ßo e pode ser mut√°vel

- 1 byte cont√©m 8 bits

- Os computadores tradicionais se comp√µem de uma grande sequencia de bytes de 8 bits

- A ideia original de que o byte deva ter 8 bits surgiu da necessidade de se ter um c√≥digo
para representar cada um dos caracteres vis√≠veis (letras, n√∫meros, sinais de pontua√ß√£o e
alguns s√≠mbolos mais utilizados como o $, %, @ e outros), al√©m de caracteres de controle
(invis√≠veis) tais como o comando de saltar linha na tela ou soar o beep do PC. Chegou na
conclus√£o que 8 bits era mais que o suficiente

- A tabela ASCII, √© um formato interpretador que serve de base para interpreta√ß√£o unicode
dos dados. Ela possui seus caracteres em 8 bits e foi uma das bases mais usadas e at√© hoje
√© bastante utilizada. Nela, a letra 'a' t√™m o valor de 01100001 (97 em decimal) e o caracter
num√©rico '1' tem o valor de 00110001 (49 em decimal).

- No caso dos n√∫meros, este valor √© meramente um identificador do s√≠mbolo do n√∫mero, porque
o seu valor matem√°tico est√° nos bits conforme vimos anteriormente. E como disse acima,
49 n√£o representa o valor matem√°tico 1 e sim representa o tipo de texto 1, ou seja,
o valor simb√≥lico, n√£o literal.

- O byte √© um agrupamento voltado aos conte√∫dos da mem√≥ria, sendo que a quantidade de bits
para fazer o endere√ßamento da mem√≥ria segue outra contagem. Os primiros Pcs pessoais tinham mem√≥ria
com endere√ßamento de 8 bits, o que permitia apenas 256 endere√ßos.

- A CPU (Central Processing Unit), √© o mecanismo principal do computador. √â nele onde as instru√ß√µes
s√£o processadas e ela √© respons√°vel por trabalhar com o conte√∫do das mem√≥ria, recebendo dados
e retornando-as / escrevendo para tal. Ela realiza um procedimento de coleta de cada item
endere√ßado na mem√≥ria, e faz um trabalho X nela dependendo do dado, procedimento pedido e 
comportamento do sistema com o hardware.

- Os conte√∫dos da CPU s√£o:

    . Instru√ß√µes:

        - Dizem a CPU o que fazer

        - Cada instru√ß√£o, possui um SET, que √© respons√°vel por dizer a CPU que coisas devem acontecer

            EX de um computador elementar de 4 bits a n√≠vel bin√°rio:

                x----------x--------------------------------------------------------------------x
                | Conte√∫do |                            A√ß√£o                                    |
                x----------x--------------------------------------------------------------------x
                |   0000   | Interrompe a execu√ß√£o do programa                                  |
                x----------x--------------------------------------------------------------------x
                |   0100   | L√™ o conte√∫do da mem√≥ria que est√° no endere√ßo logo a seguir a esta |
                |          | instru√ß√£o e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |   0110   | L√™ o conte√∫do da mem√≥ria que est√° no endere√ßo logo a seguir a esta |
                |          | instru√ß√£o e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |          | Soma o conte√∫do do registrador 1 com o conte√∫do do registrador 2   |
                |   0111   | e armazena o resultado no endere√ßo de mem√≥ria cujo n√∫mero equivale |
                |          | ao conte√∫do do endere√ßo a seguir a esta instru√ß√£o                  |
                x----------x--------------------------------------------------------------------x

            PS: Cada c√≥digo bin√°rio representa uma a√ß√£o espec√≠fica, previamente definida pela 
            arquitetura da CPU.

    . Dados:

        - Manipulados pelas instru√ß√µes para que determinado pedido ou resultado seja obtido


- Linguagem bin√°ria ou de m√°quina: √â a linguagem do computador, respons√°vel por seguir
sequencias complexas de instru√ß√µes, tudo isso seguindo no princ√≠pio bin√°rio.

- Linguagem Assembly: rela√ß√£o direta entre as instru√ß√µes em linguagem bin√°ria e express√µes
mnem√¥nicas.

    Instru√ß√£o Bin√°ria       Correspondente eletr√¥nico
          0000                         stop
          0100                         read 1
          0110                         read 2
          0111                         add 1 2

- Esta "altitude" do n√≠vel de uma linguagem diz respeito, em linhas gerais, a facilidade e rapidez
com que se produz um programa. Ou seja, s√£o necess√°rias menos instru√ß√µes escritas pelo programador
para se obter um mesmo resultado. Em outras palavras uma instru√ß√£o escrita produz mais instru√ß√µes
bin√°rias. Por√©m, linguagens de alto n√≠vel, costumam produzir programas de desempenho inferior

- Os compiladores leem o programa fonte e produzem um programa execut√°vel independente de qualquer
outro software que n√£o seja o sistema operacional do computador.

            PROGRAMA -> COMPILADOR -> PROGRAMA.exe 
            
        ps: Em sistemas UNIX PROGRAMA.exe, retorna apenas PROGRAMA, mas no fundo √© um execut√°vel 
        tamb√©m

- Os interpretadores leem o programa fonte, criam este programa na mem√≥ria (bin√°rio) e o executam.
N√£o existe programa executavel gerado.Tudo √© realizado pelo interpretador.

    . Os interpretadores facilitam o trabalho de manuten√ß√£o principalmente em grandes sistemas
    compostos de muitos programas

    . Em ambientes de muitos programas rodando simultaneamente, os interpretadores consomem menos
    mem√≥ria

    . Considerando uma mesma linguagem, o seu computador produz programas mais r√°pidos do que
    o seu interpretador.

SOBRE PROGRAMAS

- Um programa √© um conjunto de passos e instru√ß√µes, organizadas de maneira l√≥gica, que realiza um ou mais servi√ßos
de processamento de dados.

- Processamento de dados √© o ato de tratar dados brutos e obter dados tranformados, seguindo especifica√ß√µes previamente
estabelecidas, ou obter infortma√ß√µes com esses dados contextualizados.


                    DADOS BRUTOS -> PROGRAMA -> DADOS TRABALHADOS

- Um programa pode ser simples ou composto por diversos outros programas

- Um algoritmo √© uma sequencia finita de passos, etapas ou instru√ß√µes que resolvem determinados
problemas. Um algoritmo √© dito determin√≠stico quando se obt√©m sempre o mesmo resultado a partir dos
mesmos dados. Um programa pode ter 1 ou N algor√≠tmos.

- Um exemplo de um algoritmo funcional:

    . Cada linguagem t√™m uma estrutura ou sintaxe

    . Cada programa possui uma linha de execu√ß√£o. Dependendo da linguagem, ela precisa ser fechada
    ou conclu√≠da, para referenciar outra linha ou se fecha automaticamente.

    . vari√°veis s√£o defini√ß√µes e referencias a objetos ou valores no programa. Eles s√£o escopos
    de mem√≥ria onde se realizar√° procedimentos e armazenazem temp√≥r√°ria de dados e informa√ß√µes.
    Elas n√£o podem come√ßar com n√∫meros e s√≠mbolos que n√£o sejam _ e tamb√©m com espa√ßos.

    EX: ISSO FOI CRIADO POR MIM, UMA FORMA INTERPRETATIVA MINHA DE MOLDAR ALGORITMO FORA DA M√ÅQUINA
    √â MERA INTERPRETA√á√ÉO, PODEMOS USAR FERRAMENTAS J√Å PRONTAS QUE LEIAM EM PORTUGU√äS OU PODE MONTAR DO
    SEU JEITO, CONTANTO, QUE SIGA NORMAS E PADR√ïES DA COMPUTA√á√ÉO E QUE FIQUE F√ÅCIL DE VOC√ä APLICAR,
    LER E IMPLEMENTAR EM OUTRAS LINGUAGENS.

        T√çTULO: "Soma"
        OBSERVACAO: "Vai realizar a soma de dois n√∫mero"

        INICIO

        num1: int = int(ler("N1: "))
        num2: int = int(ler("N2: "))

        soma: int = num1 + num2   # Realiza a soma

        exibir f"Resultado = {soma}"

        FIM

- Um outro exemplo no qual usamos fun√ß√µes. Fu√ß√µes s√£o blocos de c√≥digos, especializados
para executar fun√ß√µes espec√≠ficas de c√≥digo, ou seja, realizam procedimentos dentro de um escopo,
para que seja implementado no escopo principal. Ela facilita a leitura e entendimento do c√≥digo e 
traz mais efici√™ncia, legibilidade e pode ser usada e reaproveitada em outros programas.

    T√çTULO: "Fun√ß√£o"
    OBSERVACAO: "Vai realizar uma demonstra√ß√£o do que √© uma fun√ß√£o"

    INICIO

    REALIZAR M√âDIA DE DOIS N√öMEROS
    [fun√ßao] media
        params:
            n1: int
            n2: int
        a√ß√µes:
            retornar (n1 + n2) / 2
    [fimfuncao]


    num1: float = float(ler("N1: "))
    num2: float = float(ler("N2: "))

    media: float = media(num1, num2)

    exibir f"A m√©dia √© {media:.2f}"

    FIM

- Ide vs Editor de c√≥digo fonte:

    . Ide (Integrated Development Environment): Uma IDE √© um ambiente completo 
    de desenvolvimento. Ela integra v√°rias ferramentas em um s√≥ lugar.

        O que uma IDE j√° traz integrada:

            + Editor de c√≥digo

            + Compilador / interpretador

            + Debugger (passo a passo)

            + Gerenciador de projetos

            + Gerenciador de depend√™ncias
            
            + Build / Run com um clique
            
            + Testes integrados

        A IDE entende:

            o projeto

            a linguagem

            a estrutura

            as depend√™ncias

        Exemplos t√≠picos

            . PyCharm

            . IntelliJ IDEA

            . Eclipse

            . Visual Studio

            . NetBeans

        ‚Üí ‚ÄúEu desenvolvo software aqui‚Äù

    . Editor de c√≥digo fonte: Um editor de c√≥digo √© uma ferramenta focada em 
    escrever e editar texto/c√≥digo. Ele n√£o se preocupa com o projeto inteiro,
    s√≥ com o arquivo que voc√™ est√° editando. 
    
        Um editor oferece:

            + Destaque de sintaxe (cores)

            + Numera√ß√£o de linhas

            + Busca e substitui√ß√£o

            + Autocompletar b√°sico

            + Leve e r√°pido
        
        Exemplos t√≠picos

            . VS Code (editor avan√ßado)

            . Sublime Text

            . Notepad++

            . Vim / Nano

        ‚Üí ‚ÄúEu escrevo c√≥digo aqui‚Äù


TABELA ASCII (origem hist√≥rica):

- ASCII foi o primeiro padr√£o de caracteres.

- Caracter√≠sticas:

    . 7 bits (0 a 127)

    . Letras A‚ÄìZ, a‚Äìz

    . D√≠gitos 0‚Äì9

    . S√≠mbolos b√°sicos

    . Sem acentos

- ASCII n√£o suporta:

    . √ß

    . √°, √©, √≠

    . emojis
 
    . l√≠nguas n√£o latinas

UNICODE (padr√£o universal)

- Unicode √© um cat√°logo gigante de caracteres do mundo inteiro.

- Inclui:

    . Letras latinas com acento

    . Japon√™s, chin√™s, √°rabe

    . S√≠mbolos matem√°ticos

    . Emojis üòÑüî•

    . Alfabetos antigos

- Cada caractere tem um c√≥digo √∫nico

- Unicode √© abstrato (s√≥ define os c√≥digos).

UTF-8 (codifica√ß√£o)

- UTF-8 √© a forma de guardar Unicode em bytes.

- Caracter√≠sticas:

    . Compat√≠vel com ASCII

    . Usa 1 a 4 bytes por caractere

    . Padr√£o da internet

    . Padr√£o do Python

- Unicode = o que √©

- UTF-8 = como √© armazenado


UM POUCO SOBRE L√ìGICA DE PROGRAMA√á√ÉO:

    Vari√°veis:

        - Vari√°vel √© um nome que guarda um valor na mem√≥ria para ser usado depois.

        . Vari√°vel = caixa com nome

        . Valor = conte√∫do da caixa

        . O valor pode mudar ao longo do programa

        . Serve para guardar dados tempor√°rios

        Por que vari√°veis existem?

            . Evitam repetir valores

            . Facilitam c√°lculos

            . Permitem decis√µes (if)

            . Permitem repeti√ß√µes (while, for)

        Antes de criar qualquer vari√°vel, pergunte:

            1. Que informa√ß√£o eu preciso guardar?

            2. Essa informa√ß√£o muda ou √© fixa?

            3. Vou usar esse valor depois?

            4. Esse nome est√° claro para um humano?

        - Nome bom de vari√°vel explica o que ela guarda.

        TIPOS MAIS COMUNS DE VARI√ÅVEIS (conceito):

            | Tipo    | Guarda o qu√™?       | Exemplo         |
            | ------- | ------------------- | --------------- |
            | inteiro | n√∫meros sem v√≠rgula | idade = 20      |
            | real    | n√∫meros com v√≠rgula | altura = 1.75   |
            | texto   | palavras/frases     | nome = "Renato" |
            | l√≥gico  | verdadeiro ou falso | aprovado = True |

        EXEMPLOS SIMPLES:

            Exemplo 1 ‚Äî Guardar valor

                idade = 20

            Mental: ‚ÄúCriei uma caixa chamada idade e coloquei o valor 20 dentro.‚Äù

            Exemplo 2 ‚Äî Usar vari√°vel

                preco = 10
                total = preco + 5
            
            Mental: ‚ÄúUsei o valor guardado para calcular outro.‚Äù

            Exemplo 3 ‚Äî Valor muda

                contador = 0
                contador = contador + 1

            Mental: ‚ÄúA vari√°vel continua existindo, mas o valor mudou.‚Äù
        
        ERROS COMUNS:

            Usar nomes confusos:

                x = 10   # ruim

            Melhor:

                quantidade = 10

            Usar vari√°vel sem valor:

                print(total)  # erro se total n√£o existir

            Pensar que vari√°vel √© o valor:

                - N√£o √©

                Vari√°vel √© o nome, n√£o o conte√∫do.

        FRASE-CHAVE (decora essa)

            . Vari√°vel n√£o √© n√∫mero, nem texto.

            . Vari√°vel √© um nome que aponta para um valor.

        DICAS:

            . Pense no nome antes do valor
            . Vari√°vel deve ter sentido humano
            . Uma vari√°vel = uma informa√ß√£o
            . Se travar, pergunte: ‚ÄúO que eu preciso guardar?‚Äù
    
    =====================================================================

    Constantes:

        - Constante √© um valor que N√ÉO deve mudar durante o programa.

        . Constante = valor fixo

        . Serve para representar regras, limites ou padr√µes

        . Evita ‚Äún√∫meros m√°gicos‚Äù espalhados no c√≥digo

        . Deixa o programa mais claro e seguro

        Ideia-chave:

            - Se n√£o pode mudar, n√£o deve ser vari√°vel.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Perguntas obrigat√≥rias antes de decidir:

                1. Esse valor pode mudar durante a execu√ß√£o?

                2. Ele representa uma regra do problema?

                3. Se mudar no futuro, deveria mudar em um s√≥ lugar?

                4. Esse valor tem significado fixo no mundo real?

            Se a resposta for ‚Äún√£o muda‚Äù ‚Üí constante

        DIFEREN√áA CLARA: VARI√ÅVEL √ó CONSTANTE:

            | Conceito  | Pode mudar?  | Exemplo        |
            | --------- | ------------ | -------------- |
            | Vari√°vel  | ‚úÖ Sim       | idade, saldo   |
            | Constante | ‚ùå N√£o       | PI, taxa fixa  |

        - Constante n√£o depende do usu√°rio, nem do tempo.

        COMO REPRESENTAR CONSTANTES (boa pr√°tica):

            Em Python, usa-se:

                . Nome em MAI√öSCULO

                . Separa√ß√£o com _

                EX:

                    PI = 3.14
                    TAXA_JUROS = 0.05
                    IDADE_MINIMA = 18
        
            Mesmo que Python permita mudar, a regra √© l√≥gica, n√£o da linguagem.

        Exemplo 1 ‚Äî Regra matem√°tica

            PI = 3.14
            area = PI * 10 * 10

        Mental: ‚ÄúPI n√£o muda. O raio pode mudar.‚Äù

        Exemplo 2 ‚Äî Regra de neg√≥cio
            
            IDADE_MINIMA = 18
            idade = 20

        Mental: ‚ÄúA idade muda, a regra n√£o.‚Äù

        Exemplo 3 ‚Äî Evitando n√∫mero m√°gico

            Ruim:

                total = preco * 0.1

            Bom:

                DESCONTO = 0.1
                total = preco * DESCONTO
            
        ERROS COMUNS:

            . Usar valor fixo direto no c√≥digo

            . Espalhar o mesmo n√∫mero em v√°rios lugares

            . Tratar regra como vari√°vel

            . Nomear constante como vari√°vel comum

        Regra pr√°tica:

            - Se voc√™ precisar procurar o n√∫mero no c√≥digo para entender, ele 
            deveria ser uma constante.

        FRASE-CHAVE PARA MEMORIZAR:

            . Vari√°vel guarda estado.

            . Constante guarda regra.

        DICAS:

            . Regra ‚Üí constante
            . Dado do usu√°rio ‚Üí vari√°vel
            . Constante no topo do c√≥digo
            . Nome claro e em mai√∫sculo
            . Menos n√∫meros ‚Äúsoltos‚Äù = menos erro

    =====================================================================

    Tipos de dados:

        - Tipo de dado define o que uma informa√ß√£o √© e o que pode ser feito 
        com ela.

        Existem duas grandes vis√µes:

            . Primitivos √ó Compostos

            . Objeto √ó N√£o-objeto

            Essas vis√µes se complementam, n√£o competem.
        
        TIPOS PRIMITIVOS (ou simples):

            - Guardam um √∫nico valor simples.

            Caracter√≠sticas:

                Valor √∫nico

                N√£o possuem partes internas

                Representam dados b√°sicos

            Exemplos comuns:

                N√∫mero inteiro ‚Üí 10

                N√∫mero real ‚Üí 2.5

                Texto ‚Üí "Ol√°"

                L√≥gico ‚Üí True / False

            Ideia-chave:

                - Primitivo = uma informa√ß√£o s√≥.

        TIPOS COMPOSTOS:

            - Guardam v√°rios valores ou estruturas internas.

            Caracter√≠sticas:

                Podem conter v√°rios dados

                Organizam informa√ß√µes relacionadas

                Facilitam trabalhar com conjuntos

            Exemplos comuns:

                Lista

                Tupla

                Conjunto

                Dicion√°rio

            Ideia-chave:

                - Composto = v√°rias informa√ß√µes agrupadas.

        COMPARA√á√ÉO R√ÅPIDA:

            | Tipo      | Quantidade de dados |
            | --------- | ------------------- |
            | Primitivo | 1 valor             |
            | Composto  | V√°rios valores      |

        N√ÉO-OBJETO (vis√£o l√≥gica):

            - Dado sem comportamento pr√≥prio.

            . S√≥ representa um valor

            . N√£o ‚Äúfaz coisas‚Äù
            
            . Usado diretamente em c√°lculos e decis√µes

            Exemplos:

                N√∫mero

                Texto

                Booleano

            Pense assim:

                . √â s√≥ dado, n√£o √© coisa.

        OBJETO (vis√£o mais avan√ßada):

            - Objeto = dado + comportamento.

            Caracter√≠sticas:

                . Tem valor

                . Tem a√ß√µes

                . Possui estrutura interna

                . Pode ser manipulado por m√©todos

            Exemplo conceitual:

                . Uma lista guarda valores e sabe adicionar, remover, ordenar.

            Objeto √© algo que:

                - Guarda dados

                - Sabe operar sobre si mesmo

                - Referencia moldes espec√≠ficos para se realizar a√ß√µes

        OBJETO √ó N√ÉO-OBJETO (resumo mental):

            | Conceito   | O que √©      |
            | ---------- | ------------ |
            | N√£o-objeto | Dado puro    |
            | Objeto     | Dado + a√ß√µes |

        Em Python:
        
            Tudo √© objeto, mas conceitualmente essa separa√ß√£o ajuda muito a 
            entender POO.

        Exemplo 1 ‚Äî Primitivo

            idade = 20

        Mental: Um √∫nico valor.

        Exemplo 2 ‚Äî Composto

            notas = [7, 8, 9]

        Mental: V√°rios valores agrupados.

        Exemplo 3 ‚Äî Objeto em a√ß√£o

            notas.append(10)

        Mental: A lista faz algo.

        Exemplo 4 ‚Äî N√£o-objeto

            soma = 10 + 5

        Mental: Apenas valores sendo usados.

        ERROS COMUNS:

            - Achar que tudo √© s√≥ n√∫mero
            - Confundir tipo com valor
            - N√£o perceber quando precisa de estrutura
            - Tentar resolver tudo com primitivos

            Regra pr√°tica:

                . Muitos dados relacionados ‚Üí tipo composto.

        FRASES-CHAVE PARA MEMORIZAR:

            Primitivo = um valor
            Composto = v√°rios valores
            Objeto = dado que sabe agir
            N√£o-objeto = dado puro

    =====================================================================

    Verifica√ß√£o de tipo (type, issinstance, issubclass):

        - Verificar tipo √© perguntar: ‚Äúque tipo de coisa √© isso?‚Äù

        Em Python, usamos isso para:

            Evitar erros

            Tomar decis√µes

            Garantir que um dado √© do tipo esperado

            Trabalhar com objetos e heran√ßa

        VIS√ÉO L√ìGICA (ANTES DO C√ìDIGO):

            Sempre pense assim:

                1. Isso √© um valor ou um objeto?

                2. Preciso saber exatamente o tipo ou apenas se pertence a um 
                grupo?

                3. Estou lidando com classe ou inst√¢ncia?

            Essas perguntas definem qual ferramenta usar.

        type() ‚Äî qual √© o tipo exato:

            - Retorna o tipo exato do valor ou objeto.

            Ideia-chave:

                . type compara identidade de tipo, n√£o parentesco.

            Exemplo:
                
                x = 10
                type(x)

            Leitura humana:

                ‚ÄúO tipo exato de x √© inteiro.‚Äù

            Compara√ß√£o direta:

                type(x) == int

            S√≥ ser√° True se for exatamente int.

            Quando usar type?

                . Testes simples
                . Depura√ß√£o
                . Verifica√ß√£o r√≠gida

                . N√£o √© ideal para POO e heran√ßa

        isinstance() ‚Äî pertence a esse tipo?

            - Verifica se um valor √© inst√¢ncia de um tipo ou de seus subtipos.

            Ideia-chave:

                . isinstance respeita heran√ßa.

            Exemplo:

                x = 10
                isinstance(x, int)

            Leitura humana:

                ‚Äúx √© um inteiro ou algo derivado de inteiro?‚Äù

            M√∫ltiplos tipos:

                isinstance(x, (int, float))

            Mental: ‚Äú√â n√∫mero?‚Äù

            Quando usar isinstance?

                . C√≥digo real
                . Fun√ß√µes gen√©ricas
                . Valida√ß√£o de entrada
                . POO

            √â o mais usado na pr√°tica.

        issubclass() ‚Äî classe filha de outra?

            - Verifica se uma classe herda de outra classe.

            PS: N√£o funciona com valores, s√≥ com classes.

            Exemplo:

                issubclass(bool, int)

            Leitura humana:

                ‚Äúbool √© uma subclasse de int?‚Äù

            Sim (True)

            Outro exemplo:

                issubclass(list, object)

            Sim ‚Äî tudo herda de object.

        COMPARA√á√ÉO FINAL (anote isso):

            | Fun√ß√£o       | Pergunta que responde       |
            | ------------ | --------------------------- |
            | `type`       | Qual √© o tipo exato?        |
            | `isinstance` | √â desse tipo ou derivado?   |
            | `issubclass` | Essa classe herda de outra? |

        ERROS COMUNS:

            . Usar type quando deveria usar isinstance
            . Usar issubclass com objetos
            . Comparar tipos sem entender heran√ßa
            . Verificar tipo quando n√£o precisa

            Regra pr√°tica:

                - Prefira isinstance em c√≥digo de verdade.

        FRASES-CHAVE PARA MEMORIZAR

            type √© r√≠gido
            isinstance √© flex√≠vel
            issubclass √© estrutural

    ===================================================================== 

    Entrada e sa√≠da de dados (Input / Output ‚Äî I/O):

        - Entrada de dados √© quando o programa recebe informa√ß√£o de fora.
        
        - Sa√≠da de dados √© quando o programa mostra informa√ß√£o para fora.

        . Entrada ‚Üí usu√°rio, arquivo, sistema

        . Sa√≠da ‚Üí tela, arquivo, sistema

        . Todo programa √∫til recebe algo e entrega algo

        ENTRADA DE DADOS (conceito):

            Em Python, a entrada padr√£o vem do teclado:

                input()

            Importante:

                input() sempre retorna TEXTO (string).

            Exemplo simples:

                nome = input("Digite seu nome: ")
                print(nome)

        SA√çDA DE DADOS (conceito):

            Sa√≠da padr√£o √© feita com:

                print()

            Serve para:

                Mostrar resultados

                Informar erros

                Exibir mensagens

            Exemplo com texto:

                print("Ol√°, mundo!")
        
        CONVERS√ÉO DE TIPO (obrigat√≥rio entender):

            Como input() retorna texto, precisamos converter:

                idade = int(input("Digite sua idade: "))

            Se n√£o converter ‚Üí erro em c√°lculo.

            Exemplo 1 ‚Äî N√∫mero:

                numero = int(input("Digite um n√∫mero: "))
                print(numero)

            Exemplo 2 ‚Äî Soma:

                a = int(input("Digite o primeiro n√∫mero: "))
                b = int(input("Digite o segundo n√∫mero: "))
                soma = a + b
                print(soma)

            Exemplo 3 ‚Äî Texto formatado:

                nome = input("Nome: ")
                idade = int(input("Idade: "))
                print(f"{nome} tem {idade} anos")

        ERROS COMUNS:

            . Esquecer convers√£o de tipo
            . Fazer c√°lculo com string
            . Entrada confusa para o usu√°rio
            . N√£o guardar o valor em vari√°vel

            Regra de ouro:

                . Entrada ‚Üí vari√°vel ‚Üí processamento ‚Üí sa√≠da

        FRASE-CHAVE PARA MEMORIZAR:

            - Programa sem entrada e sa√≠da n√£o conversa com o mundo.

        DICAS:

            . Leia a entrada com calma
            . Converta logo ap√≥s o input
            . Guarde tudo em vari√°veis
            . S√≥ depois fa√ßa contas
            . Mostre sa√≠da clara para o usu√°rio

    =====================================================================

    Interpola√ß√£o e concatena√ß√£o e formata√ß√£o:

        - Concatena√ß√£o junta textos manualmente.
        
        - Interpola√ß√£o insere valores dentro do texto automaticamente.
        
        - Formata√ß√£o controla como o texto e os n√∫meros aparecem.

        Objetivo principal:

            - mostrar informa√ß√µes de forma clara para humanos.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Pergunte sempre:

                Vou juntar textos?

                Vou mostrar valores dentro do texto?

                Preciso controlar casas decimais, alinhamento ou formato?

                O usu√°rio entenderia essa sa√≠da facilmente?

        CONCATENA√á√ÉO (forma antiga):

            . Juntar textos usando +

            EX:

                nome = "Renato"
                idade = "20"
                print("Nome: " + nome + " | Idade: " + idade)

            Observa√ß√£o importante:

                . S√≥ funciona bem com texto

                . Fica confuso com n√∫meros

                . Pouco usado hoje

            Problema comum:

                print("Idade: " + 20)  # erro

        INTERPOLA√á√ÉO (forma moderna ‚Äî RECOMENDADA):

            - Inserir valores dentro do texto automaticamente

            Em Python, usamos f-strings:

                print(f"Nome: {nome} | Idade: {idade}")

            Vantagens:

                Mais leg√≠vel

                Aceita qualquer tipo

                Mais profissional

                Menos erro

            Use isso sempre que poss√≠vel.

        FORMATA√á√ÉO DE VALORES:

            - Controlar como o valor aparece

            + Casas decimais:

                preco = 10.56789
                print(f"Pre√ßo: {preco:.2f}")

            Mostra apenas 2 casas decimais.

            + Texto alinhado:

                print(f"{nome:<10} {idade:>3}")

            . < esquerda

            . > direita

            . n√∫mero = largura

            + Formata√ß√£o monet√°ria (simples):

                total = 1234.5
                print(f"Total: R$ {total:.2f}")

        Ruim (concatena√ß√£o excessiva):

            print("Total: R$ " + str(total))

        Bom (interpola√ß√£o):

            print(f"Total: R$ {total:.2f}")

        ERROS COMUNS:

            . Usar concatena√ß√£o com n√∫meros
            . Converter tudo para string sem necessidade
            . Sa√≠da confusa para o usu√°rio
            . N√£o formatar valores financeiros

        Regra pr√°tica:

            - Se tem vari√°vel no texto ‚Üí use f-string.

        FRASES-CHAVE PARA MEMORIZAR:

            Concatena√ß√£o √© manual
            
            Interpola√ß√£o √© autom√°tica
            
            Formata√ß√£o √© controle visual

        DICAS:

            . Use f"" sempre
            . Formate n√∫meros financeiros
            . Sa√≠da clara vale mais que c√≥digo curto
            . Pense no usu√°rio lendo

        Outras sa√≠das:

            Sa√≠da com v√≠rgula no print:

                Voc√™ pode passar v√°rios valores no print separados por v√≠rgula:

                    nome = "Renato"
                    idade = 20
                    print("Nome:", nome, "| Idade:", idade)

            Por padr√£o o print coloca um espa√ßo entre os itens.
            Voc√™ pode controlar com sep e end:

                print("A", "B", "C", sep="-")   # A-B-C
                print("Oi", end="!")           # Oi!

            Formata√ß√£o com % (antiga, mas cai em exerc√≠cios):

                Sintaxe:

                    %s texto

                    %d inteiro

                    %.2f float com 2 casas

                EX:

                    nome = "Renato"
                    idade = 20
                    print("Nome: %s | Idade: %d" % (nome, idade))

                    preco = 10.567
                    print("Pre√ßo: R$ %.2f" % preco)

            Formata√ß√£o com .format():

                Por posi√ß√£o:

                    nome = "Renato"
                    idade = 20
                    print("Nome: {} | Idade: {}".format(nome, idade))

                Por nome:

                    print("Nome: {n} | Idade: {i}".format(n=nome, i=idade))

                Casas decimais:

                    total = 1234.5
                    print("Total: R$ {:.2f}".format(total))

    =====================================================================

    Operadores aritm√©ticos:

        - Operadores aritm√©ticos servem para fazer c√°lculos matem√°ticos no 
        programa.

        Eles permitem:

            Somar

            Subtrair

            Multiplicar

            Dividir

            Divis√£o inteira

            Resto da divis√£o

            Pot√™ncia

        Sem operadores, o programa n√£o calcula nada.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO)

            Pergunte sempre:

                Que c√°lculo o problema pede?
                
                √â conta de escola (soma, divis√£o, m√©dia, etc.)?
                
                O resultado precisa ser inteiro ou decimal?
                
                Preciso do resto ou s√≥ do resultado?

            A l√≥gica vem antes do s√≠mbolo.

        OPERADORES ARITM√âTICOS EM PYTHON:

            | Operador | Nome            | Exemplo  |
            | -------- | --------------- | -------- |
            | `+`      | Soma            | `a + b`  |
            | `-`      | Subtra√ß√£o       | `a - b`  |
            | `*`      | Multiplica√ß√£o   | `a * b`  |
            | `/`      | Divis√£o         | `a / b`  |
            | `//`     | Divis√£o inteira | `a // b` |
            | `%`      | Resto (m√≥dulo)  | `a % b`  |
            | `**`     | Pot√™ncia        | `a ** b` |
        
        Soma:

            a = 10
            b = 3
            print(a + b)   # 13

        Divis√£o (sempre gera decimal):

            print(10 / 3)  # 3.3333...

        Divis√£o inteira:

            print(10 // 3) # 3

        . Quantas vezes cabe, sem quebrar.

        Resto da divis√£o:

            print(10 % 3)  # 1
        
        . Muito usado para:

            Par ou √≠mpar

            Ciclos

            Quebras de grupo

        Pot√™ncia:

            print(2 ** 3)  # 8

            print(pow(2, 3))  # 8

        Subtra√ß√£o:

            a = 10
            b = 3
            print(a - b)   # 7

        Multiplica√ß√£o:

            a = 10
            b = 3
            print(a * b)   # 30

        Adicional: Raizes

            indice = 2
            radicando = 4

            raiz = radicando**(1/indice)

            print(raiz)  # 2.0

        abs() ‚Äî valor absoluto:

            - Retorna o valor sem sinal (dist√¢ncia at√© o zero).

            Ex:

                print(abs(10))    # 10
                print(abs(-10))   # 10

                # tp√©cnica em caso de negativos, fazer convers√£o expl√≠cita
                print(-(-10)) # 10

        round() ‚Äî arredondamento:

            - Arredonda um n√∫mero.

            Ex:

                print(round(3.6))      # 4
                print(round(3.14159, 2))  # 3.14

            Pode receber:

                - 1 argumento ‚Üí arredonda inteiro

                - 2 argumentos ‚Üí casas decimais

        min() e max() ‚Äî menor e maior:

            print(min(3, 7, 2))  # 2
            print(max(3, 7, 2))  # 7
            
            # Com iteraveis de tipo num√©rico:
            valores = [10, 3, 8]
            print(min(valores))
            print(max(valores))

        divmod() ‚Äî divis√£o + resto:

            - Retorna quociente e resto juntos.

            q, r = divmod(10, 3)
            print(q, r)  # 3 1

        int(), float() ‚Äî convers√£o num√©rica:

            - PS: int() corta, n√£o arredonda.

                print(int(3.9))    # 3
                print(float(10))   # 10.0

        PRECED√äNCIA (ordem das contas):

            - Python segue a matem√°tica.

            Ordem:

                1. ()

                2. **

                3. * / // %

                4. + -

            Exemplo:

                resultado = 10 + 2 * 3

            Resultado: 16, n√£o 36.

            Use par√™nteses para deixar claro:

                resultado = (10 + 2) * 3

             Resultado: 36.

        ERROS COMUNS

            . Esquecer convers√£o do input()
            . Usar / achando que retorna inteiro
            . Confundir % com porcentagem
            . N√£o usar par√™nteses quando precisa
            . Achar que abs arredonda
            . Confundir int() com round()
            . N√£o usar fun√ß√µes prontas
            . Repetir c√°lculo manual desnecess√°rio

            % n√£o √© porcentagem, √© resto da divis√£o.

            Se parece ‚Äúb√°sico demais‚Äù, provavelmente j√° existe fun√ß√£o pronta.

        DICAS:

            . Converta o input imediatamente
            . Pense na matem√°tica antes do operador
            . Use par√™nteses sem medo
            . Teste com n√∫meros simples (2, 3, 10)

    =====================================================================

    Operadores de atribui√ß√£o:

        - Operadores de atribui√ß√£o servem para colocar ou atualizar valores em 
        vari√°veis.

        Eles fazem duas coisas ao mesmo tempo:

            1. Executam uma opera√ß√£o

            2. Guardam o resultado na vari√°vel

        N√£o √© matem√°tica pura, √© estado do programa mudando.

        COMO PENSAR COMO L√ìGICO:

            Sempre leia assim:

                ‚ÄúPegue o valor atual da vari√°vel, fa√ßa algo, e guarde de volta.‚Äù

            Se voc√™ n√£o entende isso, vai errar la√ßo, contador e soma acumulada.

        ATRIBUI√á√ÉO SIMPLES:

            . =
                
                x = 10

            Mental: ‚ÄúColoque 10 dentro de x.‚Äù / ‚Äúx recebe 10‚Äù /
            ‚Äúx atribui 10‚Äù / ‚Äúx referencia 10‚Äù

        ATRIBUI√á√ÉO COM OPERA√á√ÉO:

            | Operador | Significado             |
            | -------- | ----------------------- |
            | `+=`     | soma e guarda           |
            | `-=`     | subtrai e guarda        |
            | `*=`     | multiplica e guarda     |
            | `/=`     | divide e guarda         |
            | `//=`    | divide inteiro e guarda |
            | `%=`     | resto e guarda          |
            | `**=`    | pot√™ncia e guarda       |

        . +=

            total = 0
            total += 5

        Mesmo que:

            total = total + 5

        . -=

            saldo = 100
            saldo -= 30

        Mesmo que:

            saldo = saldo - 30

        . *=

            preco = 10
            preco *= 2

        Mesmo que:

            preco = preco * 2

        . /=

            media = 10
            media /= 2

        Mesmo que:

            media = media / 2

        . %= (muito usado em ciclos)

            x = 10
            x %= 3   # sobra 1

        Mesmo que:

            x = x % 3

        . **=

            n = 2
            n **= 3

        Mesmo que:

            n = n ** 3

        LEITURA HUMANA:

            Leia como:

                ‚Äúx recebe x mais 1‚Äù

            Nunca como:

                ‚Äúx mais igual 1‚Äù

        ERROS COMUNS

            . Usar sem entender o valor anterior
            . Confundir = com ==
            . Achar que cria vari√°vel nova
            . Usar antes de inicializar

            Regra de ouro:

                Nunca use += sem inicializar a vari√°vel antes.

        FRASE-CHAVE PARA MEMORIZAR

            - Operador de atribui√ß√£o muda o estado da vari√°vel.

        DICAS:

            . Inicialize sempre
            . Leia o operador como frase
            . Use muito em contadores
            . Use em la√ßos (em breve!)

    =====================================================================

    Operadores l√≥gicos:

        - Operadores l√≥gicos combinam condi√ß√µes e produzem verdadeiro ou falso.

        Eles trabalham com valores l√≥gicos:

            True (verdadeiro)

            False (falso)

        S√£o usados para:

            Decidir caminhos (if)

            Validar dados

            Criar regras compostas

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre pergunte:

                1. Quantas condi√ß√µes existem?

                2. Todas precisam ser verdadeiras ou s√≥ uma?

                3. Existe nega√ß√£o de alguma condi√ß√£o?

            Traduza a frase humana para l√≥gica.

        and ‚Äî E:

            - S√≥ √© True se todas forem verdadeiras.

            EX:

                idade = 20
                tem_documento = True

                print(idade >= 18 and tem_documento)

            Tabela verdade (and):

                |    A    |   B    | A and B |
                | ------- | ------ | ------- |
                | True    | True   | True    |
                | True    | False  | False   |
                | False   | True   | False   |
                | False   | False  | False   |

        or ‚Äî OU

            √â True se pelo menos uma condi√ß√£o for verdadeira.

            EX:

                dia = "s√°bado"
                print(dia == "s√°bado" or dia == "domingo")

            Leitura humana:

                ‚Äú√â s√°bado ou domingo?‚Äù

            Tabela verdade (or):

                |    A    |   B    | A or B |
                | ------- | ------ | ------ |
                | True    | True   | True   |
                | True    | False  | True   |
                | False   | True   | True   |
                | False   | False  | False  |

        not ‚Äî N√ÉO

            - Inverte o valor l√≥gico.

            Exemplo:

                chovendo = False
                print(not chovendo)

            Leitura humana:

                ‚ÄúN√£o est√° chovendo.‚Äù

            Tabela Verdade:

                |   A   |   not A   |
                | ----- | --------- |
                | True  |   False   |
                | False |   True    |

        COMBINA√á√ïES (muito comum):

            Ex1:

                idade = 17
                estudante = True

                print(idade < 18 and estudante)

            Ex2:

                senha_correta = False
                print(not senha_correta)

        PRECED√äNCIA L√ìGICA (importante):

            Ordem:

                1. not

                2. and

                3. or
            
            Use par√™nteses para clareza:

                (idade >= 18 and tem_documento) or autorizado

        ERROS COMUNS

            . Esquecer par√™nteses
            . Confundir and com or
            . Escrever frases mal traduzidas
            . Usar l√≥gica sem pensar na frase humana

            Regra de ouro:

                Se n√£o d√° pra ler em portugu√™s, a l√≥gica est√° errada.

        FRASES-CHAVE PARA MEMORIZAR

            and exige tudo
            or aceita um
            not inverte

        DICAS:

            . Traduza para frase humana
            . Use par√™nteses sem medo
            . Teste com valores verdadeiros e falsos
            . N√£o complique a l√≥gica cedo demais

        CONCEITO AVAN√áADO (MUITO IMPORTANTE):

            - and e or retornam operandos, n√£o booleanos

            - Eles usam short-circuit evaluation (avalia√ß√£o curta)

            Isso permite padr√µes como:

                valor = entrada or valor_padrao

            ou

                condicao and funcao()

        Opera√ß√£o de Curto Circuito:

            - Curto-circuito √© quando o Python para de avaliar uma express√£o
            l√≥gica assim que o resultado j√° est√° decidido.

            Ele acontece com:

                and
                or

            REGRAS SIMPLES:

                and

                    Para no primeiro falsy

                        0 and 5

                    . 0 j√° √© falsy

                    . Python nem olha o 5

                or

                    Para no primeiro truthy

                        0 or 5

                    . 0 √© falsy

                    . Vai para 5

                    . 5 √© truthy ‚Üí para aqui

                not

                    N√£o tem curto-circuito, s√≥ inverte o valor.

                        not 0   # True

            POR QUE ISSO √â IMPORTANTE?

                Evita erros

                        lista = []
                        lista and lista[0]

                    n√£o d√° erro, porque lista √© falsy

                Mais performance:

                    . Menos opera√ß√µes

                    . Menos avalia√ß√µes

            FRASE PARA MEMORIZAR:

                and para no falso
                or para no verdadeiro

    =====================================================================

    Operadores relacionais:

        - Operadores relacionais comparam valores e geram um resultado l√≥gico:
            
            True ou False.

        Eles respondem perguntas como:

            √â maior?

            √â menor?

            √â igual?

            √â diferente?

            Sem operadores relacionais, n√£o existe decis√£o no programa.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre leia como pergunta humana:

                . ‚ÄúEsse valor √© maior que aquele?‚Äù

                . ‚ÄúS√£o iguais?‚Äù

                . ‚Äú√â diferente?‚Äù

            O resultado nunca √© n√∫mero, √© verdadeiro ou falso.

        OPERADORES RELACIONAIS EM PYTHON:

            | Operador | Significado    |
            | -------- | -------------- |
            |  >       | maior que      |
            |  <       | menor que      |
            |  >=      | maior ou igual |
            |  <=      | menor ou igual |
            |  ==      | igual          |
            |  !=      | diferente      |

        EXEMPLOS EXPLICADOS:

            . Maior / Menor

                print(10 > 5)    # True
                print(3 < 1)     # False

            . Maior ou igual / Menor ou igual

                print(18 >= 18)  # True
                print(5 <= 3)    # False

            . Igualdade (==)

                print(10 == 10)  # True
                print(10 == 5)   # False

            . Diferente (!=)

                print(10 != 5)   # True
                print(10 != 10)  # False

        Aten√ß√£o:

            x = 10   # atribui√ß√£o
            x == 10  # compara√ß√£o


        Rela√ß√µes com texto:

            - Strings tamb√©m podem ser comparadas com operadores relacionais.


            COMPARANDO TEXTO:

                nome = "Renato"
                print(nome == "Renato")   # True
                print(nome != "Ana")      # True

            Compara√ß√£o de texto √© exata (mai√∫scula ‚â† min√∫scula).

            Python compara strings:

                . caractere por caractere

                . seguindo a ordem alfab√©tica (tabela Unicode / ASCII)

                PS: N√£o √© ‚Äútamanho‚Äù, √© ordem lexical.

            COMO O PYTHON COMPARA STRINGS:

                A compara√ß√£o acontece:

                    1 - Do primeiro caractere

                    2 - Depois o segundo

                    3 - At√© encontrar diferen√ßa

                Exemplo mental:

                    "casa" vs "carro"
                    c  == c
                    a  == a
                    s  >  r   ‚Üí decis√£o aqui

            EXEMPLOS IMPORTANTES:

                . Ordem alfab√©tica

                    print("ana" < "bia")   # True
                    print("casa" > "carro")  # True

                . Mai√∫scula x min√∫scula (pegadinha!)

                    print("ana" < "Ana")  # False

                PS: Letras mai√∫sculas v√™m antes das min√∫sculas.

                . Comparando palavras:

                    palavra = "banana"
                    print(palavra >= "abacate")

            COMPARA√á√ÉO COM len():

                √Äs vezes o que voc√™ quer n√£o √© ordem, √© tamanho:

                    print(len("casa") > len("sol"))

                Comparar tamanho ‚â† comparar string diretamente.

        COMPARA√á√ïES COMBINADAS:

            idade = 20
            print(idade >= 18 and idade <= 65)

        Mental: ‚ÄúEst√° entre 18 e 65?‚Äù

        ERROS COMUNS

            . Usar = no lugar de ==
            . Comparar tipos diferentes sem querer
            . Esquecer que o resultado √© True/False
            . Fazer compara√ß√£o sem sentido l√≥gico

            . Achar que "z" > "ab" por tamanho
            . Ignorar mai√∫sculas e min√∫sculas
            . Comparar string quando queria comparar tamanho
            . N√£o normalizar entrada do usu√°rio

            Regra de ouro:

                Operador relacional sempre responde uma pergunta.

                Python compara texto como dicion√°rio, n√£o como humano.

        FRASES-CHAVE PARA MEMORIZAR

            . Relacional compara
            . L√≥gico combina
            . Aritm√©tico calcula
            . Atribui√ß√£o guarda

            . String √© comparada por ordem, n√£o por tamanho.
            . Mai√∫scula vem antes de min√∫scula.
            . Normalize antes de comparar.

        DICAS:

            . Leia cada compara√ß√£o em voz alta
            . Teste com valores simples
            . Use par√™nteses para clareza
            . Combine com operadores l√≥gicos

            . Normalize strings
            . Leia compara√ß√£o como dicion√°rio
            . Use len() quando quiser tamanho
            . Teste com mai√∫sculas e min√∫sculas

    =====================================================================

    in e is:

        - in pergunta se algo est√° dentro de outra coisa.
        
        - is pergunta se duas vari√°veis apontam para o MESMO objeto.

        Eles n√£o fazem a mesma coisa e n√£o s√£o intercambi√°veis.

        COMO PENSAR COMO L√ìGICO:

            Antes de escolher:

                Quero saber se pertence? ‚Üí in

                Quero saber se √© o mesmo objeto na mem√≥ria? ‚Üí is

            Valor igual ‚â† objeto igual.

        in ‚Äî pertin√™ncia:

            - Verifica se um elemento est√° contido em uma sequ√™ncia ou cole√ß√£o.

            Funciona com:

                str

                list

                tuple

                set

                dict (verifica chaves)
            
            . Exemplos com string:

                print("a" in "casa")     # True
                print("z" in "casa")     # False

            . Exemplos com lista

                numeros = [1, 2, 3]
                print(2 in numeros)      # True
                print(5 in numeros)      # False

            . Exemplo com dicion√°rio

                dados = {"nome": "Renato", "idade": 20}
                print("nome" in dados)   # True
                print("Renato" in dados) # False

            Em dicion√°rios, in verifica chaves, n√£o valores.

        is ‚Äî identidade

            - Verifica se duas vari√°veis apontam para o mesmo objeto na mem√≥ria.

            Exemplo simples:

                a = None
                print(a is None)   # True

            Uso correto cl√°ssico de is.

            Exemplo com n√∫meros (pegadinha)

                a = 256
                b = 256
                print(a is b)   # True (por otimiza√ß√£o interna)

                a = 1000
                b = 1000
                print(a is b)   # Pode ser False

            N√£o confie em is para comparar valores.

            Exemplo com listas:

                a = [1, 2, 3]
                b = [1, 2, 3]

                print(a == b)   # True (valores iguais)
                print(a is b)   # False (objetos diferentes)

        COMPARA√á√ÉO FINAL

            | Operador | Pergunta           |
            | -------- | ------------------ |
            | `in`     | Est√° dentro?       |
            | `is`     | √â o mesmo objeto?  |
            | `==`     | Tem o mesmo valor? |

        ERROS COMUNS

            . Usar is no lugar de ==
            . Comparar string com is
            . Usar in achando que compara igualdade
            . N√£o entender dicion√°rio com in

            Regra de ouro:

                Para valores ‚Üí ==
                Para identidade ‚Üí is

        FRASES-CHAVE PARA MEMORIZAR:

            in √© pertin√™ncia
            
            is √© identidade

            Igual n√£o √© o mesmo

        DICAS:

            . Leia o operador como pergunta
            . Nunca use is para comparar valor
            . Use is None sempre
            . Teste com listas para entender mem√≥ria

    =====================================================================

    Incremento / Decremento:

        - Incrementar √© aumentar um valor passo a passo.

        - Decrementar √© diminuir um valor passo a passo.

        Em Python n√£o existe ++ ou --.

            Tudo √© feito com operadores de atribui√ß√£o.

        COMO PENSAR COMO L√ìGICO:

            Leia sempre assim:

                ‚ÄúPegue o valor atual, altere um pouco, e guarde de volta.‚Äù

            Isso √© mudan√ßa de estado.

        FORMAS DE INCREMENTAR:

            . Forma cl√°ssica

                x = x + 1

            . Forma recomendada

                x += 1
            
            Ambas fazem a mesma coisa.

            . Incrementar por outro valor

                x += 5

        FORMAS DE DECREMENTAR:

            . Forma cl√°ssica

                x = x - 1

            . Forma recomendada

                x -= 1

            . Decrementar por outro valor

                x -= 3
        
        EXEMPLOS PR√ÅTICOS:

            . Contador

                contador = 0
                contador += 1
                contador += 1
                print(contador)  # 2

            . Contagem regressiva

                x = 5
                x -= 1
                x -= 1
                print(x)  # 3

            . Acumulador

                soma = 0
                soma += 10
                soma += 5
                print(soma)  # 15

        ERROS COMUNS

            . Tentar usar x++ ou x-- (isso n√£o existe em Python)
            . Usar incremento sem inicializar
            . Confundir incremento com atribui√ß√£o simples

            Regra de ouro:

                Sempre inicialize antes de incrementar.

        FRASES-CHAVE PARA MEMORIZAR

            
            Incrementar soma
            
            Decrementar subtrai
            
            Python n√£o tem ++

        DICAS:

            . Inicialize sempre
            . Leia o c√≥digo em voz alta
            . Use para contar, somar, iterar
            . Pense em estado, n√£o em f√≥rmula

    =====================================================================

    Preced√™ncia dos operadores e uso de um ou mais operadores:

        - Preced√™ncia define a ordem em que os operadores s√£o avaliados.

        Se voc√™ n√£o controlar a ordem, o Python controla por voc√™ ‚Äî e isso
        nem sempre √© o que voc√™ quer.

        Par√™nteses sempre vencem.

        COMO PENSAR COMO L√ìGICO:

            Pergunte sempre:

                Qual parte deve ser calculada primeiro?

                Essa conta √© clara para um humano?

                Preciso for√ßar a ordem com par√™nteses?
            
            C√≥digo claro > c√≥digo curto.

        ORDEM DE PRECED√äNCIA:

            Aritm√©ticos:

                1. ()
                2. **
                3. * / // %
                4. + -

            Relacionais:

                5. > < >= <=
                6. == !=

            L√≥gicos

                7. not
                8. and
                9. or

            Atribui√ß√£o

                10. = += -= *= /= ...

            Atribui√ß√£o sempre por √∫ltimo.
        
        Exemplo 1 ‚Äî Aritm√©tica simples:

            resultado = 10 + 2 * 3
            print(resultado)   # 16

        PS: Multiplica√ß√£o vem antes da soma.

        Exemplo 2 ‚Äî For√ßando ordem

            resultado = (10 + 2) * 3
            print(resultado)   # 36

        Exemplo 3 ‚Äî Relacional + aritm√©tico

            print(10 + 2 > 11)   # True

        PS: Soma primeiro, depois compara√ß√£o.

        Exemplo 4 ‚Äî L√≥gico + relacional

            idade = 17
            print(idade >= 18 or idade >= 16 and idade < 18)

        Avalia√ß√£o real:

            >= e <
            and
            or

        Exemplo 5 ‚Äî Com par√™nteses (melhor)

            print(idade >= 18 or (idade >= 16 and idade < 18))

        PS: Mesmo resultado, mais leg√≠vel.

        USO DE M√öLTIPLOS OPERADORES:

            Ruim

                if a > b and c < d or e == f:

            Bom:

                if (a > b and c < d) or e == f:

        ERROS COMUNS

            . Confiar s√≥ na preced√™ncia
            . Esquecer par√™nteses
            . C√≥digo imposs√≠vel de ler
            . Misturar tudo na mesma linha

            Regra de ouro:

                Se precisa pensar demais para entender, use par√™nteses.

        FRASES-CHAVE PARA MEMORIZAR:

            Par√™nteses mandam
            Pot√™ncia vem cedo
            and vence or
            Atribui√ß√£o √© a √∫ltima

        DICAS:

            . Sempre pense na ordem
            . Use par√™nteses por clareza
            . Misture operadores conscientemente
            . Leia a express√£o em voz alta

        Tabela completa de preced√™ncia (maior ‚Üí menor):

            | Prioridade | Operadores / forma                                                                | Observa√ß√µes r√°pidas                                |                                                                       |
            | ---------: | --------------------------------------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------- |
            |          1 | **Agrupamento / acesso**: `(...)`, `x[...]`, `x(...)`, `x.attr`                   | Par√™nteses, indexa√ß√£o, chamada de fun√ß√£o, atributo |                                                                       |
            |          2 | **Await**: `await x`                                                              | Em async                                           |                                                                       |
            |          3 | **Pot√™ncia**: `**`                                                                | **Associativa √† direita**: `2**3**2 = 2**(3**2)`   |                                                                       |
            |          4 | **Un√°rios**: `+x`, `-x`, `~x`                                                     | Ex.: `-n`, `+n`, bitwise NOT `~`                   |                                                                       |
            |          5 | **Multiplicativos**: `*`, `@`, `/`, `//`, `%`                                     | `@` √© multiplica√ß√£o matricial                      |                                                                       |
            |          6 | **Aditivos**: `+`, `-`                                                            | Soma/subtra√ß√£o                                     |                                                                       |
            |          7 | **Shifts**: `<<`, `>>`                                                            | Deslocamento de bits                               |                                                                       |
            |          8 | **Bitwise AND**: `&`                                                              |                                                    |                                                                       |
            |          9 | **Bitwise XOR**: `^`                                                              |                                                    |                                                                       |
            |         10 | **Bitwise OR**: `                                                                 | `                                                  |                                                                       |
            |         11 | **Compara√ß√µes**: `<`, `<=`, `>`, `>=`, `!=`, `==`, `in`, `not in`, `is`, `is not` | Compara√ß√µes podem ‚Äúencadear‚Äù: `a < b < c`          |                                                                       |
            |         12 | **NOT l√≥gico**: `not x`                                                           | `not` vem antes de `and/or`                        |                                                                       |
            |         13 | **AND l√≥gico**: `and`                                                             |                                                    |                                                                       |
            |         14 | **OR l√≥gico**: `or`                                                               |                                                    |                                                                       |
            |         15 | **Condicional (tern√°rio)**: `x if cond else y`                                    | Avalia `cond` e escolhe `x` ou `y`                 |                                                                       |
            |         16 | **Lambda**: `lambda`                                                              | √â o mais fraco entre ‚Äúexpress√µes normais‚Äù          |                                                                       |
            |         17 | **Walrus**: `:=`                                                                  | Atribui√ß√£o como express√£o (bem baixa)              |                                                                       |
            |         18 | **Atribui√ß√µes**: `=`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`, `&=`, `^=`, `   | =`, `<<=`, `>>=`, `@=`                             | **N√£o √© express√£o** comum (√© statement); fica ‚Äúpor √∫ltimo‚Äù na pr√°tica |

        Detalhes important√≠ssimos:

            ** (pot√™ncia) √© mais forte que un√°rio, e √© √† direita:

                -2**2 vira -(2**2) = -4

                (-2)**2 = 4

            Compara√ß√µes t√™m uma faixa √∫nica: tudo de < at√© is e in tem a mesma
            prioridade, e pode encadear:

                1 < x < 10 (equivale a 1 < x and x < 10, mas sem avaliar x duas 
                            vezes)
            
            L√≥gicos: not > and > or.

    =====================================================================

    Swap:

        - Swap √© a troca de valores entre duas vari√°veis.

        Ap√≥s um swap:

            . o valor de a vai para b

            . o valor de b vai para a

        As vari√°veis continuam as mesmas ‚Äî s√≥ os valores mudam.

        COMO PENSAR COMO L√ìGICO (ESSENCIAL):

            Antes do c√≥digo, pense assim:

                Tenho dois valores

                Quero trocar os valores

                N√£o posso perder nenhum no processo

            O problema central do swap √© n√£o sobrescrever um valor antes de 
            salv√°-lo.

        O ERRO CL√ÅSSICO (N√ÉO FUNCIONA):

                a = 5
                b = 10

                a = b
                b = a

            O que acontece de verdade:

                . a vira 10

                . b recebe a (que j√° √© 10)

                . o 5 se perde

            Esse erro mostra por que o swap existe.

        SWAP COM VARI√ÅVEL AUXILIAR (FORMA UNIVERSAL):

            - Funciona em qualquer linguagem.

                a = 5
                b = 10
                
                temp = a
                a = b
                b = temp
            
            Leitura humana:

                1. Guarde a em temp

                2. Coloque b em a

                3. Coloque temp em b

            . Seguro
            . Did√°tico
            . √ìtimo para aprender l√≥gica

        SWAP EM PYTHON (FORMA IDIOM√ÅTICA):

            - Python permite swap sem vari√°vel auxiliar, usando desempacotamento.

                a = 5
                b = 10

                a, b = b, a

            O que acontece internamente:

                . Python cria uma tupla tempor√°ria

                . Depois distribui os valores

            N√£o √© m√°gica, √© recurso da linguagem.

        SWAP COM EXPRESS√ïES (IMPORTANTE):

                x = 3
                y = x + 2

                x, y = y, x

            Primeiro o Python avalia tudo do lado direito, depois faz as 
            atribui√ß√µes.

            Isso evita conflito de valores.

        SWAP ‚â† COMPARA√á√ÉO:

            Errado:

                a == b

            Correto:

                a, b = b, a

            == compara, n√£o troca.

        SWAP E MEM√ìRIA (IDEIA IMPORTANTE):

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            . As refer√™ncias s√£o trocadas
            . As listas n√£o s√£o copiadas

        ERROS COMUNS

            . Fazer a = b; b = a
            . Confundir swap com compara√ß√£o
            . Achar que Python copia valores
            . N√£o entender avalia√ß√£o do lado direito

            Regra de ouro:

                Nunca sobrescreva um valor antes de salv√°-lo.

        FRASES-CHAVE PARA MEMORIZAR

            Swap troca valores, n√£o vari√°veis
            Swap exige preservar informa√ß√£o
            Python avalia antes de atribuir

        DICAS:

            . Pense em preservar valores
            . Lado direito √© avaliado primeiro
            . Use swap Python quando poss√≠vel
            . Use vari√°vel auxiliar para entender l√≥gica

        SWAP COM ITER√ÅVEIS:

            - Swap em iter√°veis √© a troca de elementos dentro de uma estrutura.

            . Iter√°vel = algo que tem v√°rios valores (lista, string, tupla, etc.)

            . Swap = trocar posi√ß√µes ou refer√™ncias

            . Base de ordenacÃßaÃÉo, invers√£o, reorganiza√ß√£o

            Quase todo algoritmo cl√°ssico usa swap em iter√°veis.

            COMO PENSAR COMO L√ìGICO:

                Antes de fazer swap em iter√°vel, pergunte:

                    Vou trocar valores ou posi√ß√µes?

                    O iter√°vel √© mut√°vel ou imut√°vel?

                    A troca √© local (√≠ndices) ou global (estrutura inteira)?

                Isso define a t√©cnica.

            1) SWAP DE ELEMENTOS EM LISTAS (FORMA B√ÅSICA)

                - Listas s√£o mut√°veis, ent√£o podemos trocar posi√ß√µes.

                    lista = [10, 20, 30]
                    lista[0], lista[2] = lista[2], lista[0]

                Resultado:

                    [30, 20, 10]

                Troca de elementos, n√£o da lista inteira.

            2) SWAP COM VARI√ÅVEL AUXILIAR (DID√ÅTICO)

                    lista = [1, 2, 3]

                    temp = lista[0]
                    lista[0] = lista[1]
                    lista[1] = temp

            3) SWAP EM ITER√ÅVEIS IMUT√ÅVEIS (STRING / TUPLA)

                - Strings e tuplas n√£o podem ser alteradas diretamente.

                Errado:

                    s = "abc"
                    s[0], s[2] = s[2], s[0]

                Correto (converter):

                    s = "abc"
                    lista = list(s)
                    lista[0], lista[2] = lista[2], lista[0]
                    s = "".join(lista)

                Imut√°vel ‚Üí cria novo objeto.

            4) SWAP DE FATIAS (SLICES)

                Inverter partes

                    lista = [1, 2, 3, 4, 5]
                    lista[:2], lista[2:] = lista[2:], lista[:2]

                Resultado:

                    [3, 4, 5, 1, 2]

                Muito usado em rota√ß√µes.

            5) SWAP PARA INVERS√ÉO DE LISTA (ALGOR√çTMICO)

                . Manual (com dois √≠ndices)

                    lista = [1, 2, 3, 4]
                    i = 0
                    j = len(lista) - 1

                    while i < j:
                        lista[i], lista[j] = lista[j], lista[i]
                        i += 1
                        j -= 1

            Aqui o swap √© o motor da invers√£o.

            6) SWAP EM ALGORITMOS DE ORDENA√á√ÉO

                . Bubble sort (exemplo cl√°ssico)

                    for i in range(len(lista)):
                        for j in range(len(lista) - 1):
                            if lista[j] > lista[j + 1]:
                                lista[j], lista[j + 1] = lista[j + 1], lista[j]

                Sem swap, n√£o existe ordena√ß√£o.

            7) SWAP DE REFER√äNCIAS (LISTAS INTEIRAS)

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            Aqui n√£o troca elementos ‚Äî troca quem aponta para quem.

            ERROS COMUNS

                . Tentar trocar string direto
                . Confundir troca de elemento com troca de refer√™ncia
                . Errar √≠ndice
                . Sobrescrever valor antes do swap

                Regra de ouro:

                    Swap em iter√°veis sempre depende de √≠ndice ou refer√™ncia.

            FRASES-CHAVE PARA MEMORIZAR:

                Lista troca elemento
                String cria outra
                Swap move posi√ß√£o
                Algoritmo vive de swap

            DICAS:

                . Identifique mutabilidade
                . Use √≠ndices conscientemente
                . Swap √© ferramenta, n√£o fim
                . Algoritmo = repeti√ß√£o + compara√ß√£o + swap

    =====================================================================

    Casting:

        - Casting √© a convers√£o expl√≠cita de um tipo de dado para outro.

        Em Python, usamos fun√ß√µes para isso:

            . int()

            . float()

            . str()

            . bool()

            . list(), tuple(), set()

        Casting n√£o muda o valor em si, muda como o Python interpreta esse valor.

        COMO PENSAR COMO L√ìGICO:

            Sempre se pergunte:

                Que tipo esse dado tem agora?

                Que tipo eu preciso para operar?

                A convers√£o √© segura ou pode gerar erro?

            Erros de casting s√£o erros de l√≥gica, n√£o de sintaxe.

        CASTING NUM√âRICO:

            . int()

                - Converte para inteiro (corta decimais).

                    print(int(3.9))     # 3
                    print(int("10"))    # 10

                Erro:

                    int("abc")

            . float()

                Converte para decimal.

                    print(float(10))       # 10.0
                    print(float("3.14"))   # 3.14

            . str()

                Converte para texto.

                    idade = 20
                    print("Idade: " + str(idade))

                Muito usado em sa√≠da de dados.

        CASTING L√ìGICO (bool()):

            - Converte valores para True ou False.

            . Regras importantes

                bool(0)        # False
                bool(1)        # True
                bool(-5)       # True
                bool("")       # False
                bool("abc")    # True
                bool([])       # False
                bool([1, 2])   # True

            Falsy:

                0
                0.0
                ""
                []
                {}
                None

            Todo o resto √© Truthy.

        CASTING COM ITER√ÅVEIS:

            . String ‚Üí lista

                list("abc")   # ['a', 'b', 'c']

            . Lista ‚Üí tupla

                tuple([1, 2, 3])

            . Lista ‚Üí conjunto

                set([1, 1, 2, 3])   # {1, 2, 3}

            Conjunto remove duplicados.

        CASTING AUTOM√ÅTICO (IMPL√çCITO):

            Python faz isso em alguns casos:

                print(10 + 2.5)   # 12.5

            O inteiro vira float automaticamente.

            Mas n√£o confie demais nisso.

        ERROS COMUNS:

            . Esquecer que input() retorna str
            . Converter string inv√°lida para n√∫mero
            . Achar que int() arredonda
            . Usar casting sem entender o dado

            Regra de ouro:

                Sempre valide antes de converter.

        FRASES-CHAVE PARA MEMORIZAR:

            Casting muda o tipo, n√£o o dado
            int() corta
            bool() segue truthy/falsy
            input() sempre retorna string

        DICAS:

            . Converta logo ap√≥s a entrada
            . Teste casos inv√°lidos
            . Use try/except quando avan√ßar
            . Entenda truthy/falsy profundamente

    =====================================================================

    Coer√ß√£o:

        - Coer√ß√£o √© quando o Python converte automaticamente um tipo em outro 
        durante uma opera√ß√£o.

        . N√£o √© voc√™ que manda converter

        . √â o Python tentando n√£o quebrar o programa

        . Acontece principalmente em opera√ß√µes mistas

        Coer√ß√£o ‚â† Casting

            Casting ‚Üí voc√™ manda

            Coer√ß√£o ‚Üí Python decide

        COMO PENSAR COMO L√ìGICO:

            Pergunte sempre:

                Estou misturando tipos diferentes?

                Existe um tipo ‚Äúmais abrangente‚Äù?

                O Python precisa escolher um tipo comum?

            O Python nunca perde informa√ß√£o na coer√ß√£o (sempre sobe o tipo).

        REGRA FUNDAMENTAL DA COER√á√ÉO:

            - O Python promove o tipo mais simples para o mais geral.

            Exemplo cl√°ssico:

                int  ‚Üí  float  ‚Üí  complex

            Nunca o contr√°rio.

        COER√á√ÉO NUM√âRICA:

            . int + float ‚Üí float

                    print(10 + 2.5)      # 12.5
                    print(type(10 + 2.5))  # float

                O 10 vira 10.0 automaticamente.

            . float + complex ‚Üí complex

                print(2.5 + 1j)

        COER√á√ÉO EM OPERA√á√ïES L√ìGICAS:

            . Booleano como n√∫mero

                    print(True + 1)    # 2
                    print(False * 10)  # 0
            
                Porque:

                    True ‚Üí 1
                    False ‚Üí 0

                Isso √© coer√ß√£o impl√≠cita.

        COER√á√ÉO EM EXPRESS√ïES CONDICIONAIS:

                if 10:
                    print("Executa")

            O 10 vira True automaticamente.

                if "":
                    print("N√£o executa")

            String vazia ‚Üí False.

            Aqui entra truthy e falsy (coer√ß√£o para bool).

        COER√á√ÉO QUE N√ÉO EXISTE (IMPORTANTE):

            Python n√£o faz coer√ß√£o perigosa.

            N√£o existe:

                "10" + 5

            N√£o existe:

                "3" * 2.5

            Aqui o Python exige casting expl√≠cito.

        COER√á√ÉO EM OPERADORES L√ìGICOS (and, or):

            Pegadinha importante:

                    print(0 or 10)    # 10
                    print(10 and 5)   # 5

                and e or:

                    . n√£o retornam True/False

                    . retornam um dos operandos

                Eles usam coer√ß√£o para decidir, mas retornam valores reais.

        COER√á√ÉO EM COMPARA√á√ïES:

                print(1 == True)   # True
                print(0 == False)  # True

            Booleano √© subclasse de int.

            Compara√ß√£o funciona, mas n√£o √© boa pr√°tica.

        COER√á√ÉO √ó CASTING (tabela mental)

            | Conceito | Quem decide | Exemplo     |
            | -------- | ----------- | ----------- |
            | Casting  | Voc√™        | `int("10")` |
            | Coer√ß√£o  | Python      | `10 + 2.5`  |

        ERROS COMUNS

            . Confiar demais na coer√ß√£o
            . Misturar tipos sem perceber
            . Achar que Python converte string para n√∫mero
            . Usar coer√ß√£o como ‚Äúatalho l√≥gico‚Äù

            Regra de ouro:

                Coer√ß√£o ajuda, mas n√£o substitui casting consciente.

        FRASES-CHAVE PARA MEMORIZAR:

            Coer√ß√£o √© autom√°tica
            Python sobe o tipo
            Nunca perde informa√ß√£o
            String n√£o vira n√∫mero sozinha

        DICAS:

            . N√£o confie em coer√ß√£o silenciosa
            . Prefira casting expl√≠cito
            . Teste tipos com type()
            . C√≥digo claro > c√≥digo esperto

    =====================================================================

    Caracteres de controle:

        - Caracteres de controle s√£o sequ√™ncias especiais que come√ßam com \ e 
        alteram a forma como o texto √© interpretado ou exibido.

        Eles servem para:

            . Quebra de linha

            . Tabula√ß√£o

            . Aspas dentro de texto

            . Sons, cursores e efeitos

            . Unicode e caracteres especiais

        N√£o aparecem ‚Äúvisualmente‚Äù, mas controlam o comportamento do texto.

        COMO PENSAR COMO L√ìGICO:

            Sempre pense assim:

                Texto normal ‚Üí aparece

                Caractere de controle ‚Üí controla o texto

            Eles n√£o s√£o letras, s√£o comandos embutidos.

        TABELA COMPLETA ‚Äî CARACTERES DE CONTROLE EM PYTHON:

            | Sequ√™ncia | Nome            | O que faz                    |
            | --------- | --------------- | ---------------------------- |
            | `\n`      | New line        | Quebra de linha              |
            | `\t`      | Tab             | Tabula√ß√£o horizontal         |
            | `\\`      | Backslash       | Mostra `\`                   |
            | `\'`      | Aspa simples    | Mostra `'`                   |
            | `\"`      | Aspa dupla      | Mostra `"`                   |
            | `\r`      | Carriage return | Retorna ao in√≠cio da linha   |
            | `\b`      | Backspace       | Apaga um caractere anterior  |
            | `\f`      | Form feed       | Avan√ßa p√°gina (legado)       |
            | `\v`      | Vertical tab    | Tabula√ß√£o vertical           |
            | `\a`      | Bell            | Alerta sonoro (se suportado) |
            | `\0`      | Null            | Caractere nulo               |

        CARACTERES NUM√âRICOS (ASCII / OCTAL / HEX):

            . Octal

                "\101"   # 'A'

            . Hexadecimal

                "\x41"   # 'A'
            
            Pouco usados hoje, mas existem.

        UNICODE (ESSENCIAL EM PYTHON):

            . Unicode de 16 bits

                "\u2764"   # ‚ù§

            . Unicode completo (32 bits)

                "\U0001F600"   # üòÄ

            Python √© totalmente Unicode.

        STRING RAW (IMPORTANTE):

            - String raw ignora caracteres de controle.

                print(r"C:\Users\Renato\Docs")

            Sem r, isso quebraria (\U, \D, etc.).

        EXEMPLOS PR√ÅTICOS:

            Quebra de linha:

                print("Linha 1\nLinha 2")

            Tabula√ß√£o:

                print("Nome\tIdade\tCidade")

            Aspas dentro de texto:

                print("Ele disse: \"Ol√°\"")

            \r sobrescrevendo linha

                print("Carregando...\rFeito!")

            Unicode

                print("Cora√ß√£o: \u2764")

        ERROS COMUNS

            . Esquecer que \n quebra linha
            . Caminhos do Windows sem string raw
            . Usar \ achando que √© caractere normal
            . Confundir \t com espa√ßos

            Regra de ouro:

                Se come√ßa com \, n√£o √© letra ‚Äî √© comando.

        FRASES-CHAVE PARA MEMORIZAR:

            \n quebra
            \t organiza
            \r retorna
            r"" protege
            Unicode manda

        DICAS:

            . Use \n para clareza
            . Use \t para alinhamento simples
            . Sempre use r"" em caminhos
            . Unicode funciona em tudo

    =====================================================================

    N√∫meros (inteiros e reais):

        - N√∫meros representam valores matem√°ticos usados em c√°lculos, 
        compara√ß√µes e decis√µes.

        Em Python, os principais tipos num√©ricos b√°sicos s√£o:

            Inteiros (int) ‚Üí n√∫meros sem parte decimal

            Reais (float) ‚Üí n√∫meros com parte decimal

        Python n√£o limita o tamanho de inteiros (diferente de C, Java).

        COMO PENSAR COMO L√ìGICO:

            Antes de usar n√∫meros, pergunte:

                Esse valor pode ter v√≠rgula?

                Preciso de exatid√£o absoluta ou aproxima√ß√£o?

                Esse n√∫mero vai crescer muito?

                Vou usar em compara√ß√µes, c√°lculos ou controle de fluxo?

            A escolha entre int e float √© l√≥gica, n√£o sint√°tica.

        1) N√öMEROS INTEIROS (int)

            O que s√£o?

                . Valores sem parte decimal

                . Positivos, negativos ou zero

                . Precisos (exatos)

                EX:

                    a = 10
                    b = -3
                    c = 0

            Caracter√≠sticas importantes:

                . Precis√£o exata

                . Sem limite de tamanho:

                    x = 10**100

            Ideais para:

                . contadores

                . √≠ndices

                . quantidades

                . idade, unidades, pe√ßas

            Opera√ß√µes comuns com int:

                10 + 3     # soma
                10 - 3     # subtra√ß√£o
                10 * 3     # multiplica√ß√£o
                10 // 3    # divis√£o inteira
                10 % 3     # resto
                10 ** 3    # pot√™ncia

            Divis√£o com inteiros:

                10 / 2     # 5.0 (float!)

            Toda divis√£o / gera float, mesmo entre inteiros.

        2) N√öMEROS REAIS (float)

            O que s√£o?

                . Valores com parte decimal

                . Representados internamente em ponto flutuante

                . Aproximados (n√£o exatos)

                EX:

                    x = 3.14
                    y = -0.5
                    z = 10.0

            Caracter√≠sticas importantes:

                . Possuem erro de precis√£o

                . N√£o s√£o ideais para dinheiro

                . Bons para:

                    m√©dias

                    medidas

                    c√°lculos cient√≠ficos

                    porcentagens

            PROBLEMA CL√ÅSSICO DE PRECIS√ÉO:

                print(0.1 + 0.2)  # 0.30000000000000004

            Isso n√£o √© bug, √© limita√ß√£o matem√°tica do float.

        3) CONVERS√ÉO ENTRE INT E FLOAT

            . int()

                    int(3.9)    # 3

                PS: Corta, n√£o arredonda.

            . float()

                    float(10)   # 10.0

            . round()

                round(3.6)      # 4
                round(3.14159, 2)  # 3.14

        4) OPERA√á√ïES MISTAS (COER√á√ÉO)

            EX:

                10 + 2.5   # 12.5

            O int √© convertido automaticamente para float.

            Python sempre sobe o tipo, nunca desce.

        5) COMPARA√á√ïES COM N√öMEROS

                10 > 5
                3.5 <= 4
                10 == 10.0   # True

            Cuidado com float:

                0.1 + 0.2 == 0.3   # False

            Melhor:

                abs((0.1 + 0.2) - 0.3) < 1e-9

        6) FUN√á√ïES NUM√âRICAS IMPORTANTES

            | Fun√ß√£o     | Uso             |
            | ---------- | --------------- |
            | `abs()`    | valor absoluto  |
            | `round()`  | arredondar      |
            | `pow()`    | pot√™ncia        |
            | `min()`    | menor           |
            | `max()`    | maior           |
            | `sum()`    | soma            |
            | `divmod()` | divis√£o + resto |

        ERROS COMUNS

            . Usar float para dinheiro
            . Comparar floats diretamente
            . Achar que int() arredonda
            . Esquecer que / gera float

            Regra de ouro:

                Contagem ‚Üí int
                Medida ‚Üí float

        FRASES-CHAVE PARA MEMORIZAR:

            Inteiro √© exato
            Float √© aproximado
            Divis√£o sempre flutua
            Precis√£o importa

        int, long e limites de 32/64 bits:

            Em Python moderno (3.x), n√£o existe mais long separado.
            
            Todo inteiro √© do tipo int e cresce automaticamente.

            Limites de 32 e 64 bits n√£o se aplicam da mesma forma em Python.

            1) int √ó long (hist√≥rico importante)

                . Python 2 (ANTIGO)

                    int ‚Üí limitado (32 ou 64 bits)

                    long ‚Üí inteiros grandes (ex: 1234567890123456789L)

                . Python 3 (ATUAL)

                    long n√£o existe

                    Tudo √© int

                    Inteiros t√™m precis√£o arbitr√°ria

                    O Python cuida do tamanho automaticamente.

            2) O MITO DOS 32 E 64 BITS EM PYTHON

                Python n√£o limita inteiros a 32 ou 64 bits como C/Java.

                Em linguagens como C:

                    int ‚Üí 32 bits

                    long ‚Üí 64 bits (depende da arquitetura)

                Em Python:

                    int cresce conforme necess√°rio

                    O limite √© mem√≥ria dispon√≠vel

                N√£o ocorre overflow aritm√©tico em int.

            3) ENT√ÉO O QUE SIGNIFICA 32 OU 64 BITS?

                Isso se refere √† arquitetura da m√°quina e ao ponteiro de mem√≥ria, 
                n√£o ao n√∫mero em si.

                . Python 32-bit:

                    - Ponteiros de 32 bits

                    - Menos mem√≥ria endere√ß√°vel

                . Python 64-bit:

                    - Ponteiros de 64 bits

                    - Mais mem√≥ria endere√ß√°vel

                O valor inteiro continua ilimitado, s√≥ o consumo de mem√≥ria muda.

            4) CUSTO DE MEM√ìRIA DE INTEIROS GRANDES

                Inteiros grandes:

                    Usam mais mem√≥ria

                    S√£o mais lentos que inteiros pequenos

                Python usa m√∫ltiplas ‚Äúpalavras‚Äù internas para representar
                o n√∫mero.

                Python √© mais seguro, por√©m menos previs√≠vel em performance 
                extrema.

            5) FLOAT AINDA TEM LIMITE (IMPORTANTE)

                Apesar do int ser ilimitado:

                    - float continua limitado (IEEE 754)

                    - Aproximadamente:

                        . ~1.8 √ó 10¬≥‚Å∞‚Å∏ (m√°ximo)

                        . ~15‚Äì17 d√≠gitos de precis√£o
                
                EX:

                    x = 1e308
                    x * 10   # inf

                Overflow ainda existe em float.

        CAMPO DE ESTUDO ‚Äî FUN√á√ïES ESPECIAIS DE int E float:

            - int e float n√£o s√£o apenas n√∫meros: s√£o objetos com m√©todos 
            pr√≥prios.

            Esses m√©todos servem para:

                Inspecionar o n√∫mero

                Converter formatos

                Trabalhar com bits

                Lidar com precis√£o

                Representa√ß√£o interna
            
            Isso diferencia Python de linguagens ‚Äúmais simples‚Äù.

            FUN√á√ïES ESPECIAIS DE int:

                1. bit_length():

                    Retorna quantos bits s√£o necess√°rios para representar o 
                    inteiro.

                    EX:

                        n = 10
                        print(n.bit_length())  # 4

                    10 em bin√°rio ‚Üí 1010 (4 bits)

                2. to_bytes() e from_bytes()

                    . to_bytes()

                        Converte inteiro para bytes.

                            n = 1024
                            b = n.to_bytes(2, byteorder="big")
                            print(b)
                    
                    . from_bytes()

                        Faz o caminho inverso.

                            n2 = int.from_bytes(b, byteorder="big")
                            print(n2)

                3. __int__() (conceitual)

                    Convers√£o interna para inteiro.

                        int(3.7)  # usa __int__

                    Raramente usado diretamente, mas fundamental para coer√ß√£o.

                4. Representa√ß√µes: bin(), oct(), hex()

                    n = 42
                    print(bin(n))  # 0b101010
                    print(oct(n))  # 0o52
                    print(hex(n))  # 0x2a

                5. int() com base (MUITO IMPORTANTE)

                    int("1010", 2)   # 10
                    int("FF", 16)    # 255
                    int("77", 8)     # 63

                Converte string em n√∫mero usando base num√©rica.
            
            FUN√á√ïES ESPECIAIS DE float:

                1. is_integer()

                    Verifica se o float representa um inteiro exato.

                        x = 10.0
                        y = 10.5

                        print(x.is_integer())  # True
                        print(y.is_integer())  # False

                    Muito √∫til para valida√ß√µes.
                
                2. as_integer_ratio()

                    Retorna o float como fra√ß√£o exata.

                        x = 0.75
                        print(x.as_integer_ratio())  # (3, 4)

                    Mostra como o float √© representado matematicamente.

                3. hex() (do float!)

                        x = 3.14
                        print(x.hex())

                    E o inverso:

                        float.fromhex(x.hex())

                    Representa√ß√£o exata do float em hexadecimal.

                4. __float__() (conceitual)

                    Usado quando Python for√ßa convers√£o para float:

                        float(10)

                    Importante para coer√ß√£o autom√°tica.

            QUANDO USAR ISSO NA VIDA REAL

                bit_length() ‚Üí seguran√ßa, criptografia

                to_bytes() ‚Üí arquivos, rede

                is_integer() ‚Üí valida√ß√£o de c√°lculo

                as_integer_ratio() ‚Üí precis√£o matem√°tica

                int(base) ‚Üí parsing de dados

                hex/bin ‚Üí debug de baixo n√≠vel

    =====================================================================

    strings e caracteres:

        - String √© uma sequ√™ncia de caracteres.

        - Em Python, string √© um objeto do tipo str, imut√°vel e Unicode.

        . Caractere ‚Üí unidade b√°sica (letra, n√∫mero, s√≠mbolo)

        . String ‚Üí v√°rios caracteres juntos

        . Python n√£o tem tipo char, s√≥ str

        . Cada caractere √© um Unicode code point

        CARACTERE vs STRING:

            . Em Python:

                letra = "a"
                palavra = "abc"

            Ambos s√£o str:

                type("a")      # str
                type("abc")    # str

            N√£o existe diferen√ßa de tipo entre caractere e string curta.

        EM PYTHON (codifica√ß√£o):

                texto = "cora√ß√£o üòÑ"

            . Isso √© str

            . J√° √© Unicode

            . N√£o precisa configurar nada

            Em Python 3, str √© Unicode por padr√£o.

        str COMO OBJETO:

            - str √© uma classe, e strings s√£o objetos.

                s = "Python"
            
                type(s)        # str
                isinstance(s, str)  # True

            - Por isso strings t√™m m√©todos.

        PROPRIEDADES IMPORTANTES DE str

            . Imutabilidade

                    s = "abc"
                    # s[0] = "x"  # erro

                . Strings n√£o podem ser alteradas
                . Qualquer ‚Äúmodifica√ß√£o‚Äù cria outra string

            . Index√°vel

                    s = "Python"
                    print(s[0])    # 'P'
                    print(s[-1])   # 'n'

            . Iter√°vel

                    for c in "abc":
                        print(c)

            . Comprimento

                    len("Python")  # 6

        M√âTODOS ESSENCIAIS DE str

            - Transforma√ß√£o

                . Converter tudo em min√∫scula:

                    s.lower()

                . Converter tudo em mai√∫scula:

                    s.upper()

                . Converter as primeiras letras em mai√∫sculas:

                    s.capitalize()

                . Converter apenas a primeira letra da string em mai√∫scula:

                    s.title()

            - Remo√ß√£o de espa√ßos:

                . Remover espa√ßos a direita e esquerda:

                    s.strip()

                . Remover espa√ßos esquerda apenas:

                    s.lstrip()

                . Remover espa√ßos a direita apenas:

                    s.rstrip()

            - Testes (retornam bool)

                s.isalpha()     # s√≥ letras
                s.isdigit()     # s√≥ n√∫meros
                s.isalnum()     # letras e n√∫meros
                s.isspace()     # s√≥ espa√ßos
                s.islower()     # se est√° em min√∫scula
                s.isupper()     # se est√° em mai√∫scula

            - Busca

                s.find("a")        # √≠ndice ou -1
                "a" in s           # True / False
                s.startswith("a")  # Se o in√≠cio cont√©m string 'a'. Se sim True sen√£o False
                s.endswith("a")    # Se o final cont√©m string 'a'. Se sim True sen√£o False

            - Substitui√ß√£o:

                s.replace("a", "x")

            - Quebra e jun√ß√£o:

                "1,2,3".split(",")  # Quebra
                "-".join(["a", "b", "c"])  # Une apenas listas do tipo string

        FUN√á√ïES RELACIONADAS A CARACTERES

            - C√≥digo Unicode:

                ord("a")   # 97
                ord("√ß")   # 231

            - Caractere pelo c√≥digo

                chr(97)    # 'a'
                chr(231)   # '√ß'

        SLICING (FATIAMENTO):

            - Slicing √© extrair partes de uma string usando √≠ndices.

            Sintaxe geral:

                texto[in√≠cio:fim:passo]

            . in√≠cio ‚Üí √≠ndice inicial (inclusivo)

            . fim ‚Üí √≠ndice final (exclusivo)

            . passo ‚Üí de quantos em quantos caracteres

            Todos s√£o opcionais.

            EXEMPLOS B√ÅSICOS:

                s = "Python"

                Primeiro caractere:

                    s[0]      # 'P'

                √öltimo caractere

                    s[-1]     # 'n'

                Do √≠ndice 1 ao 3

                    s[1:4]    # 'yth'

                Do come√ßo at√© o √≠ndice 3

                    s[:4]     # 'Pyth'

                Do √≠ndice 2 at√© o final

                    s[2:]     # 'thon'

            SLICING COM PASSO

                Pulando caracteres

                    s[::2]    # 'Pto'

                Invertendo string

                    s[::-1]   # 'nohtyP'

                Forma curta para invers√£o.

                - Slicing cria nova string

        CONCATENA√á√ÉO

            - Concatena√ß√£o √© juntar strings.

            . Com operador +

                a = "Py"
                b = "thon"

                c = a + b

            Resultado:

                Python

            - Isso cria uma nova string.

            . Com +=

                s = "Py"
                s += "thon"

            - Tamb√©m cria nova string (imut√°vel).

        CUIDADO COM CONCATENA√á√ÉO EM LOOP:

                texto = ""
                for c in "abc":
                    texto += c

            Ineficiente para strings grandes.

            Melhor:

                lista = []
                for c in "abc":
                    lista.append(c)

                texto = "".join(lista)

        CONCATENA√á√ÉO COM TIPOS DIFERENTES

            Erro:

                "Idade: " + 20

            Correto:

                "Idade: " + str(20)

            Melhor:

                f"Idade: {20}"

        CONCATENA√á√ÉO x INTERPOLA√á√ÉO

            | Forma      | Quando usar           |
            | ---------- | --------------------- |
            | `+`        | Strings simples       |
            | `+=`       | Acumular poucas vezes |
            | `f-string` | Formata√ß√£o            |
            | `.join()`  | Muitas strings        |

        EXEMPLOS CL√ÅSSICOS

            Extrair dom√≠nio de e-mail

                email = "user@gmail.com"
                dominio = email[email.index("@")+1:]

            Remover prefixo/sufixo

                texto = "###dados###"
                limpo = texto.strip("#")

        PEGADINHAS IMPORTANTES

            . Tamanho visual ‚â† tamanho real

                    len("üòÑ")  # 1

                Mas em bytes:

                    len("üòÑ".encode("utf-8"))  # 4
            
            . Compara√ß√£o depende de Unicode

                    "Z" < "a"   # True

                Mai√∫sculas v√™m antes no Unicode.

        FRASES-CHAVE PARA MEMORIZAR

            Python n√£o tem char
            Tudo √© Unicode
            UTF-8 √© codifica√ß√£o
            String √© objeto imut√°vel
            Caractere √© uma string de tamanho 1
            Slicing fatia
            Fim n√£o inclui
            Passo controla salto
            Concatena√ß√£o cria nova string

        Erros comuns:

            Achar que existe char em Python (n√£o existe). "a" ainda √© str.
            
            Confundir str com bytes (texto vs dados bin√°rios).
            
            Achar que string √© mut√°vel: tentar s[0] = "x" d√° erro.
            
            Esquecer que input() vem com texto, e n√£o n√∫mero.
            
            Esquecer de normalizar: comparar sem .lower() / .strip().
            
            Usar .strip() achando que remove ‚Äúno meio‚Äù (ele s√≥ remove nas pontas).
            
            Comparar texto com is em vez de ==.
            
            Achar que "Z" > "a" segue ‚Äúalfabeto humano‚Äù (√© ordem Unicode)
            
            Usar in achando que √© ‚Äúpalavra inteira‚Äù (√© substring).
            
            Usar .find() e esquecer que -1 significa ‚Äún√£o achou‚Äù.
            
            Usar .replace() achando que altera a string original (n√£o altera; 
            cria outra).

            Achar que o fim em s[inicio:fim] √© inclusivo (n√£o √©).

            Errar √≠ndice negativo (ex.: s[-0] √© igual a s[0]).
            
            Confundir s[::-1] (invers√£o) com ‚Äúordenar‚Äù.

        Dicas:

            - Normalize antes de comparar

            - Pense em √≠ndice, fatia, busca, separa√ß√£o (split) e jun√ß√£o (join).

            - Escolha a ferramenta certa

            - Slicing: fim n√£o entra

            - Teste com casos chatos

            - Sempre mostre com aspas no debug

    =====================================================================

    parsings:

        - Parsing √© o processo de analisar uma string e extrair partes com 
        significado.

        Ou seja:

            Entrada √© texto bruto

            Sa√≠da s√£o dados organizados (n√∫meros, campos, estruturas)

        - Parsing ‚â† valida√ß√£o
        - Parsing ‚â† formata√ß√£o
        - Parsing = interpretar

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre responda:

                1. Qual √© o formato esperado do texto?

                2. Onde est√£o os delimitadores? (@, ,, ;, :‚Ä¶)

                3. O texto √© fixo ou vari√°vel?

                4. O que eu preciso extrair?

            Parsing come√ßa no formato, n√£o no c√≥digo.

        TIPOS COMUNS DE PARSING

            1. Parsing por delimitador

                Quando o texto tem separadores claros.

                Exemplo:

                    nome;idade;cidade

                C√≥digo:

                    linha = "Ana;20;SP"
                    nome, idade, cidade = linha.split(";")

            2. Parsing por posi√ß√£o fixa

                Quando cada campo tem posi√ß√£o conhecida.

                Exemplo:

                    20240115BRSP

                C√≥digo:

                    data = texto[0:8]
                    pais = texto[8:10]
                    estado = texto[10:12]

                Muito usado em arquivos antigos (mainframe).

            3. Parsing por busca (find, index)

                Quando o delimitador pode variar de posi√ß√£o.

                Exemplo:

                    email = "user.name+tag@gmail.com"
                    pos = email.find("@")

                    usuario = email[:pos]
                    dominio = email[pos+1:]

            4. Parsing progressivo (passo a passo)

                Quando voc√™ ‚Äúconsome‚Äù a string.

                    texto = "10:20:30"
                    partes = texto.split(":")
                    h, m, s = map(int, partes)

        FERRAMENTAS DE PARSING EM STRINGS

            + .split()

                "1,2,3".split(",")

            + .find() / .index

                s.find("@")   # -1 se n√£o achar
                s.index("@")  # erro se n√£o achar

            + .startswith() / .endswith()

                email.endswith(".com")

            + Slicing

                texto[a:b]

            + .replace() (pr√©-processamento)

                valor = "1.234,56".replace(".", "").replace(",", ".")

        PARSING + CONVERS√ÉO DE TIPO:

            Parsing geralmente vem antes de converter tipo.

            Exemplo:

                valor = "R$ 12,50"
                valor = valor.replace("R$", "").strip()
                valor = float(valor.replace(",", "."))

            Ordem correta:

                limpar ‚Üí extrair ‚Üí converter

        PARSING ‚â† REGEX (IMPORTANTE)

            . Parsing simples ‚Üí split, find, slicing

            . Parsing complexo/padr√µes ‚Üí regex (re)

            N√£o use regex quando split resolve.

        ERROS COMUNS EM PARSING

            Assumir que o formato sempre vem certo

            N√£o tratar caso de erro (find retornar -1)

            Fazer parsing e convers√£o tudo junto

            N√£o normalizar antes (strip, lower)

            Usar regex para tudo (overkill)

        FRASES-CHAVE PARA MEMORIZAR

            Parsing √© leitura estruturada
            Delimitador manda
            Limpa antes de converter
            Texto primeiro, n√∫mero depois

        DICAS

            Desenhe o formato

            Ache os delimitadores

            Extraia em partes

            S√≥ depois converta tipo

            Teste entradas ‚Äúfeias‚Äù

    =====================================================================

    Blocos e escopos:

        - Bloco √© um agrupamento de c√≥digo.

        - Escopo define onde uma vari√°vel √© vis√≠vel.

        Em Python:

            Blocos s√£o definidos por indenta√ß√£o

            Escopo n√£o depende de {} (como em C/Java)

            Nem todo bloco cria um novo escopo

        BLOCOS EM PYTHON

            - Um bloco come√ßa ap√≥s : e √© definido pela indenta√ß√£o.

            Exemplos de blocos:

                if condicao:
                    ...

                for x in lista:
                    ...

                while condicao:
                    ...

                def func():
                    ...

            Indenta√ß√£o errada = erro ou bug l√≥gico.

        ESCOPO (VISIBILIDADE)

            Escopo responde:

                ‚ÄúEssa vari√°vel existe aqui?‚Äù

            Python segue a regra LEGB:

                1. local
                2. Enclosing
                3. global
                4. Built-in

            . ESCOPO LOCAL:

                - Vari√°veis criadas dentro de fun√ß√µes.

                    def f():
                        x = 10

                    # x n√£o existe aqui
  
                S√≥ existem dentro da fun√ß√£o.

            . ESCOPO GLOBAL

                - Vari√°veis criadas fora de fun√ß√µes.

                    x = 5

                    def f():
                        print(x)

                . Pode ler

                . N√£o pode atribuir sem a palavra resrvada global

            . global (cuidado)

                    x = 10

                    def f():
                        global x
                        x = 20

                . Altera o valor global

                . Pode causar bugs dif√≠ceis

            . nonlocal

                - Usado em fun√ß√µes dentro de fun√ß√µes.

                    def externa():
                        x = 10
                        def interna():
                            nonlocal x
                            x = 20

        BLOCO ‚â† ESCOPO (PEGADINHA CL√ÅSSICA)

            if, for, while N√ÉO criam escopo:

                if True:
                    y = 10

                print(y)  # funciona

            Diferente de C/Java.

            Fun√ß√µes criam escopo:

                def f():
                    z = 5

                print(z)  # erro

        SOMBREAMENTO (SHADOWING)

            - Vari√°vel local com mesmo nome de uma global.

                x = 10

                def f():
                    x = 5   # sombra

            Global continua existindo, mas ‚Äúescondida‚Äù dentro da fun√ß√£o.

        ERROS COMUNS

            Achar que if cria escopo

            Esquecer indenta√ß√£o

            Usar global sem necessidade

            Modificar global dentro de fun√ß√£o sem perceber

            Criar vari√°veis dentro de loop achando que ‚Äúmorrem‚Äù

        DICAS DE ATAQUE

            Sempre leia a indenta√ß√£o

            Pergunte: ‚Äúonde essa vari√°vel nasceu?‚Äù

            Prefira retornar valores a usar global

            Evite nomes iguais em escopos diferentes

            Use fun√ß√µes para isolar l√≥gica

        FRASES-CHAVE PARA MEMORIZAR

            Indenta√ß√£o manda
            Fun√ß√£o cria escopo
            Loop n√£o cria
            global √© perigoso
            Escopo evita bugs

        UM POUCO MAIS SOBRE LEGB:

            Quando o Python encontra um nome (x, print, len‚Ä¶), ele procura 
            nesta ordem exata:

                1. Local
                2. Enclosing
                3. Global
                4. Built-in

            Ele para no primeiro que encontrar.

            LOCAL (L):

                - Vari√°veis criadas dentro da fun√ß√£o atual.

                    def f():
                        x = 10
                        print(x)

                    f()

                . x existe s√≥ dentro de f

                . √â o primeiro lugar que o Python procura

                Fora da fun√ß√£o:

                    print(x)  # erro

                Local √© o escopo mais forte.

            ENCLOSING (E):

                - Vari√°veis da fun√ß√£o externa que envolve a fun√ß√£o atual.

                    def externa():
                        y = 20
                        def interna():
                            print(y)
                        interna()

                    externa()

                . y n√£o √© local de interna

                . Tamb√©m n√£o √© global

                . √â enclosing

                + nonlocal (controla o enclosing):

                    def externa():
                        y = 20
                        def interna():
                            nonlocal y
                            y = 30
                        interna()
                        print(y)  # 30

                . Sem nonlocal, voc√™ n√£o pode atribuir ao enclosing.

            GLOBAL (G):

                - Vari√°veis criadas fora de qualquer fun√ß√£o.

                    x = 5

                    def f():
                        print(x)

                    f()

                . Pode ler vari√°vel global

                . N√£o pode atribuir sem global

                + global (cuidado!):

                    x = 5

                    def f():
                        global x
                        x = 10

                . Altera o valor global

                . Pode causar bugs dif√≠ceis de rastrear

            BUILT-IN (B):

                - Nomes que j√° v√™m com o Python.

                Exemplos:

                    print
                    len
                    int
                    str
                    range

                C√≥digo:

                    print(len("abc"))  # 3

                . √öltimo lugar onde o Python procura.

                Sombreamento perigoso (shadowing):

                        len = 10
                        print(len("abc"))  # ERRO

                    . Voc√™ escondeu o len built-in.

            ORDEM REAL DE BUSCA (PASSO A PASSO)

                Quando o Python v√™:

                    print(x)

                Ele faz:

                    1. x existe no local?

                    2. N√£o? existe no enclosing?

                    3. N√£o? existe no global?

                    4. N√£o? existe no built-in?

                    5. N√£o? ‚Üí NameError

            EXEMPLO COMPLETO LEGB:

                    x = "global"

                    def externa():
                        x = "enclosing"
                        def interna():
                            x = "local"
                            print(x)  # Built-in
                        interna()

                    externa()

                Sa√≠da:

                    local

                Se voc√™ remover x = "local":

                    enclosing

                Se remover tamb√©m:

                    global

                Se n√£o existir global:

                    NameError

            ERROS COMUNS COM LEGB:

                Achar que if cria escopo

                Usar global sem perceber

                N√£o entender nonlocal

                Sombrear print, list, str

                Pensar que Python ‚Äúadivinha‚Äù escopo

            DICAS:

                Sempre pergunte: onde esse nome nasceu?

                Fun√ß√£o ‚Üí cria escopo

                Loop ‚Üí n√£o cria

                Prefira retorno a global

                Evite nomes iguais aos built-ins

            FRASE FINAL PRA MEMORIZAR:

                . Python procura nomes como uma cebola:

                . local ‚Üí enclosing ‚Üí global ‚Üí built-in

    =====================================================================

    Estruturas condicionais / tern√°rios:

        - Estruturas condicionais controlam o fluxo de execu√ß√£o do programa com 
        base em express√µes l√≥gicas.

        Formalmente:

            Avaliam uma condi√ß√£o booleana

            Executam um bloco entre alternativas poss√≠veis

            S√£o a base de decis√£o, ramifica√ß√£o e l√≥gica de neg√≥cio

        Sem condicionais, um programa √© apenas sequencial.

        if:

            - Executa um bloco se a condi√ß√£o for verdadeira.

            Sintaxe:

                if condi√ß√£o:
                    bloco

            Exemplo:

                idade = 18

                if idade >= 18:
                    print("Maior de idade")

                if True:  # SE TROCAR POR False N√ÉO IR√Å ENTRAR NO BLOCO
                    print("Sempre vai passar aqui")

            Caracter√≠sticas:

                . Condi√ß√£o deve resultar em verdade l√≥gico (truthy)

                . Se for falsa, o bloco √© ignorado

                . Pode existir sozinho

            Uso t√≠pico:

                valida√ß√£o

                checagem simples

                guarda de execu√ß√£o

        if if if ... (ifs independentes):

            - M√∫ltiplos if n√£o s√£o ligados entre si.

            Sintaxe:

                if A:
                    bloco
                if B:
                    bloco
                if C:
                    bloco

            Exemplo:

                x = 10

                if x > 0:
                    print("x √© positivo")

                if x % 2 == 0:
                    print("x √© par")

                if x >= 10:
                    print("x √© maior ou igual a 10")

            . Cada condi√ß√£o √© avaliada sempre

            . Mais de um bloco pode executar

            . N√£o √© escolha exclusiva

            Use quando condi√ß√µes s√£o independentes.

        if / elif:

            - Estrutura de escolha exclusiva.

            Sintaxe:

                if A:
                    bloco
                elif B:
                    bloco
                elif C:
                    bloco

            Exemplo:

                nota = 7.5

                if nota >= 8:
                    print("Nota alta")
                elif nota > 6 and nota < 8:
                    print("Nota na m√©dia")

            Caracter√≠sticas:

                . Avalia√ß√£o sequencial

                . Apenas um bloco executa

                . Para no primeiro verdadeiro

                . elif √© um acr√¥nimo a else if

                . elif depende exclusivamente de um if, ou seja, n√£o consegue 
                rodar sozinho

            Modela decis√£o hier√°rquica.

        if / else:

            - Escolha bin√°ria: ou isso, ou aquilo.

            Sintaxe:
            
                if A:
                    bloco
                else:
                    bloco

            Exemplo:

                nome = "Carro"

                if nome == "Carro":
                    print("Automotor de 4 eixos")
                else:
                    print("Outro objeto")
                
            . Garante execu√ß√£o de um dos dois blocos

            . Muito usado para valida√ß√£o

            . Um else depende exclusivamente de if, ou seja, n√£o pode rodar
            sozinho

        if / elif / else:

            - Forma mais comum de decis√£o completa.

            Sintaxe:

                if A:
                    bloco
                elif B:
                    bloco
                elif C:
                    bloco
                else:
                    bloco

            Exemplo:

                permissao = 0

                if permissao == 0:
                    print("Sem permiss√£o")
                elif permissao == 1:
                    print("Permissao total")
                else:
                    print("Fora do limite de permiss√£o")

            . Todas as possibilidades s√£o cobertas

            . else √© o caso residual

            . Estrutura fechada e previs√≠vel

            Ideal quando h√° categorias mutuamente exclusivas.

        if ANINHADO (if dentro de if):

            - Condi√ß√µes dependentes de condi√ß√µes anteriores.

            Sintaxe:

                if A:
                    if B:
                        ...

            Exemplo:

                nome = "Jo√£o"
                idade = 22

                if nome == "Jo√£o":

                    if idade >= 18:
                        print("√â de maior")
                    elif 15 <= idade < 18:
                        print("√â adolescente")
                    else:
                        if idade == 14:
                            print("T√™m 14 anos")
                        print("√â menos de idade")

                else:
                    print("Nome inv√°lido")

            PS: Nota que podemos aninhar todas as vers√µes anteriores se
            necess√°rio.

            Caracter√≠sticas:

                . Cria √°rvore de decis√£o

                . Pode aumentar complexidade rapidamente

                . Pode ser reescrito como elif em muitos casos

            Aninhamento profundo = alerta de design.

        IF TERN√ÅRIO (express√£o condicional)

            - Condicional como express√£o, n√£o como bloco.

            Forma geral:

                valor = X if condi√ß√£o else Y

            Exemplo:

                acesso_a_entrada = True
                pode_passar = True if acesso_a_entrada else False

            Caracter√≠sticas:

                Retorna um valor

                Mais conciso

                N√£o cria bloco

            Use para atribui√ß√µes simples, n√£o para l√≥gica complexa.

        IF TERN√ÅRIO ANINHADO

            - V√°rios tern√°rios encadeados.

            Forma geral:

                valor = A if c1 else B if c2 else C

            Exemplo:

                x = -3

                resultado = (  # () Serve nesse caso para linhar e deixar mais leg√≠vel
                    "positivo" if x > 0
                    else "zero" if x == 0
                    else "negativo"
                )

                print(resultado)

            Caracter√≠sticas:

                . Funciona

                . Legibilidade cai r√°pido

                . Deve ser usado com extremo cuidado

                Em geral, prefira if / elif / else.

        match (Python 3.10+)

            - Estrutura de pattern matching (equivalente moderno ao switch).

            Sintaxe:

                match valor:
                    case X:
                    case Y:
                    case _:

            Exemplo:

                opcao = input("Escolha uma op√ß√£o (1, 2, 3, a, b): ")

                match opcao:
                    case "1":
                        print("Op√ß√£o 1 selecionada")

                    case "2" | "3":
                        print("Op√ß√£o 2 ou 3 selecionada")

                    case x if x in ("a", "b", "c"):
                        print("Op√ß√£o de letra v√°lida (a, b ou c)")

                    case _:
                        print("Op√ß√£o inv√°lida")

            Caracter√≠sticas:

                . Compara√ß√£o estrutural

                . Melhor que if/elif para muitos casos fixos

                . _ √© o caso padr√£o (else)

                . Match s√≥ aceita condi√ß√µes l√≥gicas bit-wise, exemplo acima: |

                . Pode fazer verifica√ß√µes com ifs tern√°rios

            Excelente para:

                enums

                comandos

                protocolos

                parsing

        IFs MAL PROJETADOS (M√ÅS PR√ÅTICAS)

            . Condi√ß√µes longas e ileg√≠veis:

                if a and b or c and not d and e:

            . Aninhamento profundo:

                if A:
                    if B:
                        if C:
                            if D:

            . Repeti√ß√£o de condi√ß√£o:

                if x > 10:
                    ...
                elif x > 10 and y > 5:
                    ...

            . Uso excessivo de else:

                - else escondendo erro

                - l√≥gica impl√≠cita perigosa

        BOAS PR√ÅTICAS COM CONDICIONAIS:

            . Prefira retornos antecipados
            . Use elif em vez de aninhar
            . Quebre condi√ß√µes complexas em vari√°veis
            . Use par√™nteses para clareza
            . Cada if deve ter uma responsabilidade

        if + return (PADR√ÉO PROFISSIONAL EM FUN√á√ïES E M√âTODOS DE CLASSE)

            - Retornar cedo simplifica l√≥gica.

            Ruim:

                if cond:
                    resultado = X
                else:
                    resultado = Y
                return resultado

            Bom:

                if cond:
                    return X
                return Y

            Benef√≠cios:

                Menos indenta√ß√£o

                Fluxo mais claro

                C√≥digo mais leg√≠vel

            Early return √© padr√£o profissional.
        
        FRASES-CHAVE PARA MEMORIZAR

            if decide
            elif organiza
            else cobre o resto
            Tern√°rio √© express√£o
            match √© escolha estrutural
            Muitos ifs = sinal de design ruim

        ERROS COMUNS EM ESTRUTURAS CONDICIONAIS

            1) Confundir if independentes com if/elif

                    if x > 0:
                        ...
                    if x > 10:
                        ...

                PS: Ambos podem executar.

                Use elif quando a decis√£o for exclusiva.

            2) Aninhamento excessivo

                    if A:
                        if B:
                            if C:
                                if D:

                - C√≥digo dif√≠cil de ler e manter

                Correto: Reescreva com elif, and ou early return

            3) Condi√ß√µes longas e ileg√≠veis

                    if a and b or c and not d and e:

                - Alto risco de bug

                Correto: Quebre em vari√°veis intermedi√°rias

            4) else gen√©rico escondendo erro

                    if valido:
                        processa()
                    else:
                        processa_outra_coisa()

                PS: O else pode engolir casos inesperados

                Correto: Trate casos expl√≠citos

            5) Comparar booleanos explicitamente

                    if cond == True:

                - Desnecess√°rio

                Use apenas:
                
                    if cond:

            6) Tern√°rio complexo demais

                    x = a if c1 else b if c2 else d if c3 else e

                Legibilidade p√©ssima

                Correto: Use if/elif/else

            7) Repeti√ß√£o de condi√ß√£o

                    if x > 10:
                        ...
                    elif x > 10 and y > 5:

                - Redund√¢ncia

                Correto: Reorganize a l√≥gica

            8) match usado como if comum

                - Usar match para poucas condi√ß√µes simples

                Correto: Use quando h√° m√∫ltiplos padr√µes claros

            9) Usar is para comparar valor

                    if x is 10:

                - Errado
                
                Correto: if x == 10:

            10) N√£o entender truthy/falsy

                    if valor:

                PS: "0" √© True

            11) Condi√ß√µes impl√≠citas demais

                    if a and b or c:

                - Amb√≠guo

                Correto: Use par√™nteses ou vari√°veis intermedi√°rias

            12) Usar in achando que √© igualdade

                    if "a" in "ana":

                PS: Isso √© substring, n√£o palavra inteira

        DICAS:

            - Decis√£o √© exclusiva ou independente?

            - Liste os casos poss√≠veis antes de codar

            - Use early return sempre que poss√≠vel

            - Prefira clareza a concis√£o

            - Se tem muitos elif, pense em match.

            - Se o if cresce demais, √© sinal de design ruim

            - Leia a condi√ß√£o em voz alta

            - Pergunte: que objeto est√° sendo avaliado?

            - Qual operador est√° sendo usado?

            - Esse operador retorna bool ou objeto?

            - Esse objeto √© truthy ou falsy?

            - Preciso comparar valor (==) ou identidade (is)?

            - Preciso normalizar antes (strip, lower)?

        OPERADORES E OBJETOS EM CONDI√á√ïES:

            - Em Python, condi√ß√µes avaliam objetos, n√£o apenas valores booleanos.

            Qualquer express√£o em um if passa por:

                bool(express√£o)

            Por isso, objetos t√™m comportamento condicional.

            1. Operadores Relacionais:

                - Usados para comparar valores.

                    if idade >= 18:
                    if nome == "Ana":

                Resultado: bool

            2. Operadores L√≥gicos:

                - Combinam condi√ß√µes.

                    if idade >= 18 and tem_doc:

                    if n1 * n2 == n1 + n2 or is_prime():

                    if not (valor_zerado):

                Retornam operandos, mas em if s√£o avaliados como booleanos.

            3. Operadores de Pertin√™ncia:

                - Verificam pertencimento.

                    if "@" in email:

                    if nome not in lista:

                Chamam internamente m√©todos como __contains__.

            4. Operadores de Identidade:

                - Verificam identidade de objeto, n√£o valor.

                    if x is None:

                Usado para sentinelas, n√£o para compara√ß√£o de valor.

            OBJETOS EM CONDI√á√ïES (TRUTHY / FALSY):

                Objetos Falsy (avaliam como False):

                    False
                    None
                    0, 0.0
                    ""
                    [], {}, set()

                    EX:

                        if lista:
                            ...

                    S√≥ entra se a lista n√£o estiver vazia.
            
                Objetos Truthy:

                    Todo objeto que n√£o √© falsy.

                    EX:

                        if "abc":
                        if [1]:
                        if 10:

                    Conte√∫do n√£o importa ‚Äî s√≥ o estado l√≥gico.

            M√âTODOS DE OBJETOS EM CONDI√á√ïES:

                Strings:

                    if nome.strip():
                    if texto.isdigit():

                Listas:

                    if lista:

                Dicion√°rios:

                    if "chave" in d:

                Condi√ß√µes frequentemente usam m√©todos do objeto, n√£o operadores 
                puros.

            OPERADORES CHAMAM M√âTODOS (IMPORTANTE)

                Quando voc√™ escreve:

                    a == b

                Python executa:

                    a.__eq__(b)

                Isso significa:

                    . Objetos controlam como s√£o comparados

                    . Classes podem redefinir comportamento condicional

                Isso √© base de polimorfismo.

            CONDI√á√ïES COM FUN√á√ïES (RETORNO)

                    if func():

                . A fun√ß√£o √© chamada

                . O retorno √© convertido com bool()

                . Decide o fluxo

                Fun√ß√µes devem retornar algo sem√¢ntico para condi√ß√µes.


    =====================================================================

    Estruturas de repeti√ß√£o:

        - Estruturas de repeti√ß√£o executam um bloco de c√≥digo m√∫ltiplas vezes 
        enquanto uma condi√ß√£o for satisfeita ou enquanto houver elementos a 
        percorrer.

        Formalmente:

            Reduzem repeti√ß√£o de c√≥digo

            Modelam processos iterativos

            S√£o base de algoritmos, busca, acumula√ß√£o e simula√ß√£o

        while:

            - Repeti√ß√£o controlada por condi√ß√£o

            - Executa o bloco enquanto a condi√ß√£o for verdadeira.

            EX:

                while condi√ß√£o:
                    bloco

            Exemplo classico:

                cont = 0

                while cont < 10:
                    print(cont)
                    cont += 1

            . Leia-se, enquanto a vari√°vel chamada cont for menor que 10
            . Mostre cont
            . Incremente + 1 em cont

            Caracter√≠sticas:

                Teste ocorre antes da execu√ß√£o

                Pode executar zero ou mais vezes

                Ideal quando n√£o se sabe o n√∫mero de itera√ß√µes

            Iter√°veis com while:

                Uso cl√°ssico com √≠ndice:

                        i = 0
                        while i < len(lista):
                            lista[i]
                            i += 1

                    Exige:

                        controle manual de √≠ndice

                        incremento expl√≠cito

                        maior chance de erro

                Uso de operadores com while:

                    Relacionais: controlam a condi√ß√£o

                    Aritm√©ticos: contadores

                    L√≥gicos: m√∫ltiplas condi√ß√µes

                        while i < 10 and ativo:

            while aninhado:

                - Um while dentro de outro.

                EX:
                    
                    while A:
                        while B:

                C√≥digo:

                    linha = 0

                    while linha < 3:
                        coluna = 0

                        while coluna < 4:
                            print(f"linha={linha}, coluna={coluna}")
                            coluna += 1

                        linha += 1


                    i = 1

                    while i <= 3:
                        j = 1

                        while j <= 5:
                            print(f"{i} x {j} = {i * j}")
                            j += 1

                        print("-----")
                        i += 1

                . Modela repeti√ß√µes bidimensionais

                . Usado em matrizes, tabelas, for√ßa bruta

                . Risco alto de complexidade O(n¬≤)

            while True:

                - Loop incondicional.

                EX:

                    while True:
                        if condicao_de_saida:
                            break   # Para o loop

                Usado quando:

                    . a condi√ß√£o de parada √© interna

                    . leitura cont√≠nua

                    . menus

                    . eventos

                Sempre deve existir break.

            Loop infinito:

                    while True:
                        pass

                . Pode travar o programa

                . √Äs vezes √© intencional (servidores, sistemas reativos)

                . Em scripts comuns ‚Üí bug

            Fun√ß√µes especiais no while:

                break ‚Üí sai do loop

                continue ‚Üí pula para pr√≥xima itera√ß√£o

                pass ‚Üí n√£o faz nada (placeholder)

            while else:

                Executa o else se o loop terminar sem break.

                EX:

                    while cond:
                        ...
                        if erro:
                            break
                    else:
                        # terminou normalmente

                Pouco usado, mas poderoso para:

                    . busca

                    . valida√ß√£o

                    . detec√ß√£o de falha

        for:

            - Repeti√ß√£o controlada por iter√°vel

            - Percorre cada elemento de um iter√°vel.

            Sintaxe:

                for elemento in iter√°vel:
                    bloco

            Caracter√≠sticas:

                Mais seguro que while

                N√£o exige √≠ndice manual

                Preferido em Python

            Iter√°veis com for:

                Exemplos:

                    string
                    lista
                    tupla
                    set
                    dict
                    range

                EX Sintaxe:

                    for c in "Python":

                . range:

                    - Gerador de sequ√™ncia num√©rica.

                        range(inicio, fim, passo)

                    . fim √© exclusivo

                    . Muito usado para contagem

                        for i in range(10):

                . Uso de operadores com for:

                        soma = 0
                        for x in range(10):
                            soma += x

                    Modelo cl√°ssico: acumulador

                . Aplica√ß√µes cl√°ssicas de for:

                    1. Contador

                            contador = 0
                            for _ in range(10):
                                contador += 1

                        . _: significa, n√£o chamar nada, apenas executar

                    2. Acumulador

                            total = 0
                            for n in lista:
                                total += n

                    3. Busca

                            for x in lista:
                                if x == alvo:
                                    break

                    4. Filtragem

                            for x in lista:
                                if x > 0:

                    5. Transforma√ß√£o

                            for x in lista:
                                novo = x * 2

            for aninhado:

                Sintaxe:

                    for i in range(n):
                        for j in range(m):

                EX:

                    for i in range(1, 5):
                        for j in range(1, 5):
                            if i != j:
                                print(f"({i}, {j})")


                    letras = ["A", "B", "C"]
                    for l1 in letras:
                        for l2 in letras:
                            if l1 != l2:
                                print(l1 + l2)

                . Matrizes

                . Tabelas

                . Combina√ß√µes

                . Complexidade cresce r√°pido

            Fun√ß√µes especiais no for

                break
                continue
                pass
                enumerate
                zip

                Exemplo:

                    for i, valor in enumerate(lista):

            for else:

                - Executa o else se o loop terminar sem break.

                Sintaxe:

                    for x in lista:
                        if x == alvo:
                            break
                    else:
                        # n√£o encontrou

                Muito usado em busca.

            ERROS COMUNS EM LOOPS:

                Esquecer incremento no while

                Loop infinito acidental

                Usar while quando for √© melhor

                Aninhamento excessivo

                Misturar l√≥gica demais dentro do loop

                N√£o usar break quando deveria

                Usar while sem atualizar estado

                Tentar controlar √≠ndice dentro de for

                Misturar responsabilidades (contador + condi√ß√£o confusa)

                Off-by-one (< vs <=)

                Incrementar fora do lugar correto

            DICAS:

                Sabe quantas vezes? ‚Üí for
                N√£o sabe quando para? ‚Üí while
                Percorre cole√ß√£o? ‚Üí for
                Menu / evento / leitura cont√≠nua? ‚Üí while True
                Busca? ‚Üí for + break + else
                Muito aninhamento? ‚Üí repense o algoritmo
                Pergunte: quem controla o passo? voc√™ ‚Üí while | Python ‚Üí for
                Se precisar decrementar, pense em range com passo negativo
                Se tem contador manual em for, talvez precise de enumerate
                Se o loop n√£o termina, procure o incremento
                Atualiza√ß√£o do estado deve ser √≥bvia ao ler o c√≥digo

            FRASES-CHAVE PARA MEMORIZAR:

                while depende de condi√ß√£o
                for depende de cole√ß√£o
                break encerra
                continue pula
                else s√≥ roda sem break
                loop ruim = design ruim
                while exige atualiza√ß√£o expl√≠cita
                for itera sozinho
                Incremento move o estado
                Sem incremento, n√£o h√° progresso


        INCREMENTO E DECREMENTO EM LOOPS:

            - Como o estado do loop evolui

            - Incrementar/decrementar √© alterar o estado que controla a repeti√ß√£o.
            
            - Sem isso, o loop n√£o progride ‚Üí loop infinito.

            Em termos formais:

                Loop = condi√ß√£o + estado + atualiza√ß√£o

                Incremento/decremento = atualiza√ß√£o do estado

            Papel no while:

                - No while, VOC√ä √© respons√°vel por atualizar a vari√°vel de 
                controle.

                Estrutura conceitual:

                    estado_inicial
                    while condi√ß√£o(estado):
                        bloco
                        atualiza√ß√£o_do_estado

                . Incremento cl√°ssico:

                        i = 0
                        while i < 5:
                            print(i)
                            i += 1

                    Leitura l√≥gica:

                        i come√ßa em 0
                        enquanto i < 5
                        imprime
                        incrementa i
                        volta para testar

                    Sem i += 1 ‚Üí loop infinito.

                . Decremento cl√°ssico:

                        i = 5
                        while i > 0:
                            print(i)
                            i -= 1

                    Leitura:

                        contador regressivo
                        usado em temporizadores, contagem reversa

                Incremento/decremento com operadores:

                        while x < 10:
                            x = x + 2      # incremento de 2

                        while saldo > 0:
                            saldo -= gasto
                    
                    Incremento n√£o precisa ser de 1.

                Exemplo cl√°ssico de bug:

                    i = 0
                    while i < 10:
                        print(i)
                    # i nunca muda

            while True + incremento

                    i = 0
                    while True:
                        print(i)
                        i += 1
                        if i == 5:
                            break

                Aqui o incremento controla a sa√≠da, n√£o a condi√ß√£o do while.

        INCREMENTO / DECREMENTO NO for:

            . Conceito fundamental

                No for, o incremento √© impl√≠cito.

            Voc√™ n√£o controla o √≠ndice manualmente.

                for i in range(5):
                    print(i)

            Internamente:

                . Python pega o pr√≥ximo valor do iter√°vel

                . N√£o existe i += 1 vis√≠vel

                N√£o tente controlar i manualmente dentro do for.

            Incremento com range:

                    for i in range(0, 10, 2):
                        print(i)

                Incremento de 2:

                    0 ‚Üí 2 ‚Üí 4 ‚Üí 6 ‚Üí 8

            Decremento com range:

                    for i in range(5, 0, -1):
                        print(i)

                . Passo negativo ‚Üí decremento.

            Acumuladores (incremento indireto)

                Muito comum em for:

                        soma = 0
                        for x in range(10):
                            soma += x

                    Aqui:

                        x muda automaticamente

                        soma √© incrementada manualmente

                    Dois tipos de ‚Äúincremento‚Äù coexistem:

                        do iterador

                        do acumulador

            N√ÉO FA√áA ISSO EM for

                    for i in range(10):
                        i += 1  # in√∫til

                . Isso n√£o altera o loop

                . S√≥ muda a vari√°vel local naquela itera√ß√£o

        QUANDO USAR CADA LOOP:

            Use for quando:

                Voc√™ tem uma cole√ß√£o
                Voc√™ sabe quantas vezes vai iterar
                Est√° percorrendo lista, string, dicion√°rio
                Est√° acumulando valores
                Est√° fazendo busca simples

                - Em Python, for √© a escolha padr√£o.

            Use while quando:

                A condi√ß√£o de parada √© din√¢mica
                Voc√™ n√£o sabe quantas itera√ß√µes haver√°
                O loop depende de eventos, entradas ou estados
                Menus interativos
                Leitura at√© erro/sentinela

                - while √© mais poderoso ‚Äî e mais perigoso.

        LOOPS COM CONDICIONAIS:

            - Loop sem if quase n√£o decide nada.

            - if fora de loop quase n√£o escala.

            O poder est√° na combina√ß√£o.

            1) Condicional controla perman√™ncia no loop

                while:
                
                        while x < 10:

                    Aqui:

                        Condi√ß√£o mant√©m ou encerra o loop

            2) Condicional controla sa√≠da antecipada (break)

                    for x in lista:
                        if x == alvo:
                            break

                Busca eficiente: para quando encontra.
            
            3) Condicional controla pulo (continue)

                    for x in lista:
                        if x < 0:
                            continue
                        processa(x)

                Filtragem elegante.

            4) Condicional controla processamento

                    for x in lista:
                        if x % 2 == 0:
                            pares += 1
    
                L√≥gica de neg√≥cio dentro do loop.

            5) Condicional decide acumula√ß√£o

                    total = 0
                    for x in lista:
                        if x > 0:
                            total += x

                S√≥ acumula quando faz sentido.

            6) Condicional controla finaliza√ß√£o (for/while else)

                for x in lista:
                    if x == alvo:
                        break
                else:
                    print("N√£o encontrado")

            ERROS CL√ÅSSICOS (LOOP + IF):

                1) Condi√ß√£o errada ‚Üí loop infinito

                        while i < 10:
                            if i == 5:
                                pass
                
                2) if no lugar errado

                        if x > 0:
                            for x in lista:

                    (geralmente o if deveria estar dentro)

                3) break fora do contexto correto

                    sai do loop errado
                    encerra cedo demais

                4) continue pulando atualiza√ß√£o

                        while i < 10:
                            if i == 5:
                                continue
                            i += 1

                    Loop infinito (i nunca muda quando i == 5)

                5) Misturar l√≥gica demais dentro do loop

                    loop vira ‚Äúbola de lama‚Äù
                    dif√≠cil de provar correto

            BOAS PR√ÅTICAS (LOOPS + IF)

                . Prefira for a while
                . Condi√ß√£o de parada clara
                . Atualiza√ß√£o do estado sempre vis√≠vel
                . Use break para encurtar busca
                . Use continue para filtrar
                . Use else para sucesso/falha
                . Se ficou complexo ‚Üí extraia fun√ß√£o

    =====================================================================

    Itera√ß√µes e Iter√°veis:

        - Itera√ß√£o √© o processo de percorrer elementos um a um.
        
        - Iter√°vel √© algo que pode ser percorrido.
        
        - Iterador √© quem faz a itera√ß√£o acontecer.

        Em Python:

            for n√£o percorre diretamente

            Ele usa iteradores

            Isso √© um modelo formal e poderoso

        ITERA√á√ÉO:

            Iterar significa executar um processo repetidamente, avan√ßando 
            passo a passo em uma sequ√™ncia de dados.

            Exemplos de itera√ß√£o:

                . Percorrer uma lista

                . Ler caracteres de uma string

                . Consumir valores de um gerador

                . Avan√ßar em um range
            
            Itera√ß√£o ‚â† repeti√ß√£o cega

            Itera√ß√£o envolve estado + avan√ßo + t√©rmino

        ITER√ÅVEL (Iterable):

            Um iter√°vel √© um objeto que pode fornecer um iterador.

            Formalmente:

                iter√°vel ‚Üí pode ser passado para iter()

            Exemplos de iter√°veis:

                str

                list

                tuple

                set

                dict

                range

                arquivos

                geradores

                    iter("abc")
                    iter([1, 2, 3])

                - Se iter(obj) funciona ‚Üí √© iter√°vel.

            Iter√°vel N√ÉO percorre sozinho:

                    lista = [1, 2, 3]

                . A lista n√£o anda

                . Ela apenas permite ser percorrida

                Quem anda √© o iterador.

        ITERADOR (Iterator):

            - Um iterador √© o objeto que mant√©m o estado da itera√ß√£o.

            Formalmente, um iterador:

                Possui m√©todo __next__()

                Lembra onde parou

                Lan√ßa StopIteration quando acaba

                EX:

                    it = iter([1, 2, 3])

                    next(it)  # 1
                    next(it)  # 2
                    next(it)  # 3
                    next(it)  # StopIteration

                Iterador √© consum√≠vel.

        Iterador ‚â† Iter√°vel (diferen√ßa crucial):

            | Caracter√≠stica      | Iter√°vel | Iterador |
            | ------------------- | -------- | -------- |
            | Pode gerar iterador | Sim      | N√£o      |
            | Mant√©m estado       | N√£o      | Sim      |
            | Pode ser reiniciado | Sim      | N√£o      |
            | Possui `__next__`   | N√£o      | Sim      |

            Um iterador geralmente n√£o pode ser reutilizado.
        
        COMO O for FUNCIONA (POR DENTRO):

            Quando voc√™ escreve:

                for x in lista:
                    ...

            O Python faz (conceitualmente):

                it = iter(lista)
                while True:
                    try:
                        x = next(it)
                    except StopIteration:
                        break
                    ...

            O for √© um while com iterador.

            Isso √© MUITO importante.

        ITERA√á√ÉO EM DIFERENTES TIPOS:

            . String

                    for c in "abc":

                Itera caractere por caractere.

            . Lista

                    for chave in d:

                Itera elemento por elemento.

            . Dicion√°rio

                    for chave in d:

                Itera chaves por padr√£o.

                    for k, v in d.items():

            . Range

                    for i in range(5):

                range √© iter√°vel pregui√ßoso, n√£o lista.

        ITERADORES S√ÉO ESTADO + PROGRESSO

            Exemplo de problema comum:

                it = iter([1, 2, 3])

                for x in it:
                    print(x)

                for x in it:
                    print(x)  # n√£o imprime nada

            O iterador foi consumido.

        FUN√á√ïES RELACIONADAS √Ä ITERA√á√ÉO

            . iter()

                Cria um iterador:

                    iter(obj)

            . next()

                Avan√ßa o iterador:

                    next(it)

            . enumerate()

                Itera com √≠ndice:

                    for i, v in enumerate(lista):

            . zip()

                Itera em paralelo:

                    for a, b in zip(lista1, lista2):

            . any() / all()

                Consomem iter√°veis:

                    any(x > 0 for x in lista)
                    all(x > 0 for x in lista)

        ERROS COMUNS

            . Confundir iter√°vel com iterador
            . Tentar reutilizar iterador consumido
            . Converter tudo para lista sem necessidade
            . Usar √≠ndice quando o for j√° resolve
            . Alterar cole√ß√£o enquanto itera

        DICAS:

            . Pergunte: isso √© iter√°vel ou iterador?
            . Preciso percorrer mais de uma vez? ‚Üí use iter√°vel
            . Quero economizar mem√≥ria? ‚Üí use iterador
            . Quero simplicidade? ‚Üí use for
            . Quero controle fino? ‚Üí use iter + next

        FRASES-CHAVE PARA MEMORIZAR

            Iter√°vel permite
            Iterador percorre
            for consome iterador
            Iterador tem estado
            StopIteration encerra

    =====================================================================

    Fun√ß√µes e lambdas:

        - Fun√ß√£o √© uma unidade de comportamento reutiliz√°vel, que recebe entrada, 
        processa e pode produzir sa√≠da.

        Formalmente:

            . Encapsula l√≥gica
            
            . Reduz repeti√ß√£o
            
            . Controla fluxo
            
            . Cria abstra√ß√£o

        Fun√ß√µes simples:

                def f():
                    bloco

            . N√£o recebe par√¢metros

            . Pode ou n√£o retornar valor

            . Executa uma tarefa espec√≠fica

        Fun√ß√µes com par√¢metros e sem par√¢metros:

            Sem par√¢metros

                def mostrar_menu():

            Com par√¢metros
            
                def soma(a, b):

            Par√¢metros s√£o entradas expl√≠citas do comportamento

        Fun√ß√µes com par√¢metros definidos (default):

                def saudacao(nome="Usu√°rio"):

            Permitem chamadas flex√≠veis

            Devem vir ap√≥s par√¢metros obrigat√≥rios

            Usar defaults reduz quantidade de par√¢metros.
        
        NORMA DE C√ìDIGO LIMPO:

            - Quanto menos par√¢metros, melhor.

            0‚Äì2 ‚Üí ideal

            3 ‚Üí aceit√°vel

            4+ ‚Üí sinal de design ruim

            Muitos par√¢metros indicam:

                . fun√ß√£o fazendo coisas demais

                . falta de encapsulamento

                . necessidade de objeto/dict

        Escopo em Python ‚Äî regra LEGB:

            - Python procura vari√°veis nesta ordem como vimos antes:

                L ‚Üí Local
                E ‚Üí Enclosing
                G ‚Üí Global
                B ‚Üí Built-in

                Isso se chama regra LEGB.

            1. Local (L) ‚Äî dentro da fun√ß√£o:

                    def f():
                        x = 10   # local
                        print(x)

                    f()

                - S√≥ existe dentro da fun√ß√£o

                - N√£o pode ser acessada fora

            2. Enclosing (E) ‚Äî fun√ß√£o dentro de fun√ß√£o:

                    def externa():
                        x = 20  # enclosing

                        def interna():
                            print(x)  # acessa enclosing

                        interna()

                    externa()

                - x n√£o √© local da interna, mas est√° no escopo envolvente 
                (enclosing).

            3. Global (G) ‚Äî topo do c√≥digo (arquivo)

                    x = 30  # global

                    def f():
                        print(x)  # l√™ global

                    f()

                - Fun√ß√µes podem ler vari√°veis globais
                
                - N√£o podem alterar sem global

            4. Built-in (B) ‚Äî nomes do Python

                    print(len([1, 2, 3]))

                . len, print, sum, int etc.

                PS: N√£o sobrescreva isso (p√©ssima ideia). Cuidado com
                sombreamento.

            Como usar vari√°vel do topo (global) dentro de fun√ß√£o:

                Apenas ler ‚Üí funciona direto:

                    x = 5

                    def f():
                        print(x)

                    f()

                Alterar sem global ‚Üí erro

                    x = 5

                    def f():
                        x = x + 1  # UnboundLocalError

            Alterar usando global:

                    x = 5

                    def f():
                        global x
                        x += 1

                    f()
                    print(x)  # 6

                global diz:

                    ‚Äúessa vari√°vel n√£o √© local, use a global‚Äù

            nonlocal ‚Äî quando existe fun√ß√£o dentro de fun√ß√£o:

                Situa√ß√£o:

                    vari√°vel n√£o √© local

                    n√£o √© global

                    est√° na fun√ß√£o externa

                C√≥digo:

                    def externa():
                        x = 10

                        def interna():
                            nonlocal x
                            x += 1

                        interna()
                        print(x)

                    externa()

                Sem nonlocal, isso daria erro.

            - global ‚Üí arquivo inteiro

            - nonlocal ‚Üí fun√ß√£o imediatamente externa

            Fun√ß√£o deve receber dados por par√¢metro e devolver por retorno.
            global e nonlocal s√£o exce√ß√µes, n√£o regra.

        COMPORTAMENTO E FLUXO:

            Fun√ß√µes:

                Criam fronteira de execu√ß√£o

                Controlam in√≠cio, meio e fim

                Facilitam racioc√≠nio local

            O fluxo entra, executa, retorna.

        return:

            - return encerra a fun√ß√£o e devolve um valor.

            Sintaxe:

                return valor

            . Pode haver v√°rios return

            . Usado para controle de fluxo

        return vs print (CRUCIAL):

            | `return`      | `print`          |
            | ------------- | ---------------- |
            | devolve valor | mostra na tela   |
            | afeta fluxo   | efeito colateral |
            | test√°vel      | n√£o test√°vel     |
            | reutiliz√°vel  | n√£o reutiliz√°vel |

            - Fun√ß√µes devem retornar, n√£o imprimir.

        Fun√ß√µes com loops e condicionais:

                def soma_positivos(lista):
                    total = 0
                    for x in lista:
                        if x > 0:
                            total += x
                    return total

            - Fun√ß√£o = comportamento

            - Loop = repeti√ß√£o

            - If = decis√£o

        Fun√ß√µes compostas:

            - Fun√ß√µes que chamam outras fun√ß√µes.

            Ex:

                    def processar():
                        validar()
                        calcular()
                        salvar()

                - Base da arquitetura de software.

        Fun√ß√µes aninhadas:

                def externa():
                    def interna():
                        ...

            . Escopo enclosing

            . Usadas para encapsular l√≥gica auxiliar

        FUN√á√ïES COMO OBJETO:

            - Em Python, fun√ß√µes s√£o objetos de primeira classe.

            Isso significa:

                podem ser atribu√≠das a vari√°veis

                passadas como argumento

                retornadas por outras fun√ß√µes

            Ex:

                f = soma

        CLOSURES:

            Closure = fun√ß√£o + ambiente capturado.

            EX:

                def externa(x):
                    def interna():
                        return x
                    return interna

            - x permanece vivo mesmo ap√≥s externa terminar.

            Usos:

                configura√ß√£o

                encapsulamento

                estado privado

        CURRYING:

            - Transformar fun√ß√£o de m√∫ltiplos par√¢metros em fun√ß√µes parciais.

            EX:

                def soma(a):
                    def soma_b(b):
                        return a + b
                    return soma_b

            Muito usado em programa√ß√£o funcional.

        DECORADORES:

            - Fun√ß√£o que envolve outra fun√ß√£o para modificar comportamento.

            EX:

                @decorador
                def f():

            Conceito:

                fun√ß√£o recebe fun√ß√£o
                retorna nova fun√ß√£o

            Usos:

                logging
                autentica√ß√£o
                cache
                valida√ß√£o

            Decoradores = aplica√ß√£o pr√°tica de closures.

        FUN√á√ïES COMO CALLBACKS:

            - Callback √© uma fun√ß√£o passada como argumento para ser chamada 
            depois.

            Ou seja:

                Voc√™ n√£o executa a fun√ß√£o agora

                Voc√™ entrega o comportamento

                Quem chama decide quando executar

            Invers√£o de controle.

            Pensamento: ‚ÄúN√£o me diga como fazer, diga o que fazer quando algo 
            acontecer.‚Äù

            Exemplo conceitual:

                def processar(valor, acao):
                    return acao(valor)

                def dobrar(x):
                    return x * 2

                processar(10, dobrar)

            dobrar √© callback.

        FUN√á√ïES COMO ESTRAT√âGIAS (Strategy Pattern):

            - Estrat√©gia √© trocar o comportamento sem mudar o c√≥digo que usa.

            Voc√™ tem:

                uma interface de comportamento

                v√°rias implementa√ß√µes

            √â um padr√£o cl√°ssico de design.

            Pensamento: ‚ÄúO algoritmo √© o mesmo, o comportamento muda.‚Äù

            Exemplo conceitual:

                def ordenar(lista, estrategia):
                    return estrategia(lista)

                def crescente(l):
                    return sorted(l)

                def decrescente(l):
                    return sorted(l, reverse=True)

            A estrat√©gia define como ordenar.

            Quando usar:

                regras de neg√≥cio vari√°veis

                c√°lculos diferentes

                pol√≠ticas (pre√ßo, desconto, imposto)

                valida√ß√µes alternativas

        DISPATCH POR FUN√á√ÉO:

            - Dispatch √© escolher qual fun√ß√£o executar com base em uma chave.

            Em vez de:

                if cmd == "add":
                elif cmd == "remove":
                elif cmd == "list":

            Voc√™ usa:

                fun√ß√µes

                mapeamento direto

            Remove condicionais desnecess√°rios.

            Pensamento: ‚ÄúDados escolhem comportamento.‚Äù

            Exemplo conceitual:

                def add():
                    ...

                def remove():
                    ...

                def listar():
                    ...

                acoes = {
                    "add": add,
                    "remove": remove,
                    "list": listar
                }

                acoes[cmd]()

            Isso √© dispatch por fun√ß√£o.

        FUN√á√ïES GERADORAS (yield):

            - Produzem valores sob demanda.

            EX:

                def gerador():
                    yield valor

            . Retornam iterador

            . Mant√™m estado interno

            . Muito eficientes em mem√≥ria

            yield pausa a fun√ß√£o.

        *args e **kwargs:

            . *args

                - argumentos posicionais vari√°veis

                    def f(*args):

            . **kwargs

                - argumentos nomeados vari√°veis

                    def f(**kwargs):

            Use com modera√ß√£o.

        LAMBDAS (lambda):

            - Lambda √© uma fun√ß√£o an√¥nima de express√£o √∫nica.

            - Lambda n√£o substitui fun√ß√£o.

            - Lambda remove ru√≠do quando o comportamento √© simples.

            Sintaxe:

                lambda x: x + 1

            COMPORTAMENTO E FLUXO

                . Executa express√£o

                . Retorna valor automaticamente

                . N√£o tem return expl√≠cito

                . N√£o tem bloco

            Lambda com par√¢metros e sem par√¢metros:

                lambda: 10
                lambda x: x * 2
                lambda x, y: x + y

            NORMA DE C√ìDIGO LIMPO (LAMBDA)

                - Se n√£o cabe em uma linha clara, n√£o √© lambda.

                Lambdas complexas s√£o m√° pr√°tica.

            Lambda com par√¢metros definidos (default):

                lambda x=10: x * 2

            Lambda key (uso mais comum):

                    sorted(lista, key=lambda x: x.valor)

                - Essencial para ordena√ß√£o e agrupamento.

            Lambda com condicionais:

                    lambda x: x if x > 0 else 0

                - Forma tern√°ria apenas.

                - N√£o existe loop em lambda. Se precisar de loop ‚Üí use def.

            Lambda funcional:

                Usadas com:

                    map
                    filter
                    sorted
                    min, max

                EX:

                    map(lambda x: x*2, lista)

            FUN√á√ïES INLINE:

                - Fun√ß√£o inline √© um comportamento definido no ponto de uso,
                sem nome.

                EX:

                    sorted(lista, key=lambda x: x.idade)

                . N√£o merece um def

                . Usada uma √∫nica vez

                . Express√£o simples

                Lambda = fun√ß√£o inline por natureza.

                PS: Se voc√™ precisa pensar para ler ‚Üí n√£o √© inline.

            ESTRAT√âGIAS R√ÅPIDAS:

                - Estrat√©gia r√°pida √© trocar comportamento sem criar v√°rias 
                fun√ß√µes nomeadas.

                    EX:

                        operacao = lambda a, b: a + b

                    Depois:

                        operacao = lambda a, b: a * b

                Estrat√©gia definida no local.

            CALLBACKS SIMPLES:

                - Callback simples √© um comportamento pequeno passado para ser 
                executado depois.

                EX:

                    processar(lista, lambda x: x > 0)

                Mental: ‚ÄúQuando isso acontecer, fa√ßa isso.‚Äù

                Exemplo cl√°ssico:

                    filter(lambda x: x % 2 == 0, lista)

            ADAPTA√á√ÉO DE INTERFACE:

                - Adapter com lambda ajusta uma fun√ß√£o ao formato esperado por 
                outra.

                Voc√™ tem:

                    def soma(a, b):
                        return a + b

                Mas precisa de:

                    f(x)

                Solu√ß√£o:

                    f = lambda x: soma(x, 10)

                Lambda atua como adaptador.

        ERROS COMUNS

            Lambdas longas

            Lambdas com efeitos colaterais

            Usar lambda no lugar de def complexo

            Fun√ß√£o com muitos par√¢metros

            Confundir print com retorno

        FRASES-CHAVE PARA MEMORIZAR

            . Fun√ß√£o √© comportamento
            . return encerra
            . Fun√ß√£o √© objeto
            . Closure captura estado
            . Decorador envolve
            . Lambda √© express√£o

    =====================================================================

    Recurs√µes:

        Resolver um problema chamando o pr√≥prio problema

        - Recurs√£o √© uma t√©cnica em que uma fun√ß√£o chama a si mesma para 
        resolver um problema menor do mesmo tipo.

        Toda recurs√£o correta tem:

            1. Caso base ‚Üí quando parar

            2. Caso recursivo ‚Üí chamada para um problema menor

            3. Progresso ‚Üí cada chamada se aproxima do caso base

            Se faltar qualquer um ‚Üí bug.

        COMO A RECURS√ÉO FUNCIONA (POR DENTRO):

            Exemplo conceitual:

                f(3)
                ‚îî‚îÄ f(2)
                    ‚îî‚îÄ f(1)
                        ‚îî‚îÄ f(0)  ‚Üê caso base

            . Cada chamada cria um novo frame na pilha (stack)

            . Vari√°veis s√£o locais √†quela chamada

            . Quando o caso base retorna, a pilha desempilha

            Isso se chama call stack.
        
        CALL STACK (PILHA DE EXECU√á√ÉO):

            . Estrutura LIFO (Last In, First Out)

            . Cada chamada ocupa mem√≥ria

            . Python n√£o otimiza tail recursion

            Recurs√£o profunda ‚Üí risco real.

        STACK OVERFLOW:

            - Stack overflow ocorre quando a recurs√£o cria chamadas demais
            antes de retornar.

            Causas:

                . caso base inexistente
                . caso base errado
                . problema grande demais
                . recurs√£o infinita

            Exemplo cl√°ssico de erro:

                def f(n):
                    return f(n + 1)

            Em Python:

                RecursionError: maximum recursion depth exceeded

        QUANDO USAR RECURS√ÉO (E QUANDO N√ÉO):

            Use recurs√£o quando:

                problema √© naturalmente recursivo

                estrutura em √°rvore

                divis√£o em subproblemas claros

                clareza > performance

            Evite recurs√£o quando:

                h√° la√ßo simples equivalente

                profundidade pode ser grande

                performance e mem√≥ria s√£o cr√≠ticas

            Em Python, loops geralmente s√£o melhores.

        T√âCNICAS E ESTRAT√âGIAS DE RECURS√ÉO:

            1. Recurs√£o direta simples

                - A fun√ß√£o chama a si mesma.

                Exemplo conceitual:

                    f(n) = f(n-1)

                Usos:

                    fatorial

                    soma

                    contagem

            2. Recurs√£o linear

                - Uma chamada recursiva por execu√ß√£o.

                EX:

                    f(n) ‚Üí f(n-1)

                Profundidade = n

            3. Recurs√£o m√∫ltipla (ramificada)

                - Mais de uma chamada recursiva.

                Ex:

                    f(n) ‚Üí f(n-1) + f(n-2)

                . Crescimento exponencial

                . Cuidado com performance

            4. Recurs√£o em estruturas:

                Muito comum em:

                    listas aninhadas

                    √°rvores

                    dicion√°rios aninhados

                EX:

                    processa(no):
                        para cada filho:
                            processa(filho)

            5. Dividir para conquistar

                - Quebra o problema em partes.

                Exemplos:

                    busca bin√°ria

                    merge sort

                    quicksort

            6. Recurs√£o com acumulador (quase tail recursion)

                EX:

                    f(n, acc)

                . reduz trabalho p√≥s-retorno

                . Python n√£o otimiza, mas melhora clareza

        RECURS√ÉO ‚Äî COMPLEMENTOS ESSENCIAIS:

            - Toda recurs√£o √© um if disfar√ßado.

            A forma geral √©:

                if caso_base:
                    return valor
                else:
                    return chamada_recursiva(...)

            - Sem if ‚Üí n√£o existe parada ‚Üí loop infinito na stack.

            . Caso base √© uma condi√ß√£o:

                if n == 0:
                    return 1

            . Caso recursivo √© outra condi√ß√£o

                return n * f(n - 1)

            Recurs√£o √© controle de fluxo condicional, n√£o m√°gico.

            RECURS√ÉO √ó LOOPS (RELA√á√ÉO REAL):

                - Recurs√£o substitui loops, mas n√£o elimina repeti√ß√£o.

                . N√£o use loop para SIMULAR a recurs√£o

                . Use loop para ITERAR n√≠veis, e recurs√£o para ESTRUTURA

                Conceitualmente:

                    for / while ‚Üí repeti√ß√£o expl√≠cita

                    recurs√£o ‚Üí repeti√ß√£o impl√≠cita via chamadas

                    Exemplo mental:

                        for i in range(n):

                    ‚âà

                        f(n):
                            f(n-1)

                Cada chamada equivale a uma itera√ß√£o.

                N√ÉO misture loop e recurs√£o sem motivo:

                        def f(n):
                            for i in range(n):
                                f(i)

                    PS: Complexidade explode

                    - Use uma t√©cnica por vez, salvo casos espec√≠ficos.

            return EM RECURS√ÉO (PONTO CRUCIAL):

                - Em recurs√£o, return n√£o √© opcional.

                Erro comum:

                        def f(n):
                            if n == 0:
                                return
                            f(n - 1)

                    - Retorna None

                    - Resultado in√∫til

                Forma correta:

                        def f(n):
                            if n == 0:
                                return 0
                            return 1 + f(n - 1)

                    - Cada chamada deve retornar algo para a anterior.

            PAR√ÇMETRO AUXILIAR:

                - √© um par√¢metro acumulador ou par√¢metro de controle.

                Tamb√©m conhecido como:

                    . √≠ndice de progresso

                    . estado da recurs√£o

                    . contador recursivo

                    Ele representa onde a recurs√£o est√°.

                . EX Forma conceitual:

                        soma(lista, i):
                            se i chegou no fim:
                                retorna 0
                            sen√£o:
                                retorna lista[i] + soma(lista, i+1)

                    Esse padr√£o √© chamado de:

                        recurs√£o com estado expl√≠cito

            RECURS√ÉO COM ACUMULADOR:

                Outro padr√£o cl√°ssico:

                    def soma_lista(lista, i=0, total=0):

                . i ‚Üí controle
                . total ‚Üí acumulador

                Equivale a:

                    total = 0
                    for x in lista:
                        total += x

            T√âCNICA: DIVIDIR E CONQUISTAR:

                - Dividir e conquistar quebra o problema em partes 
                independentes, resolve cada parte e combina os resultados.

                Estrutura formal:

                    Dividir o problema

                    Resolver subproblemas

                    Combinar resultados

                . Exemplo conceitual (soma)

                    soma(lista):
                        divide em duas metades
                        soma_esq = soma(esq)
                        soma_dir = soma(dir)
                        retorna soma_esq + soma_dir

                Profundidade menor que recurs√£o linear.


        ERROS COMUNS EM RECURS√ÉO

            . esquecer o caso base
            . caso base nunca ser alcan√ßado
            . mudar vari√°vel errada
            . retornar antes da recurs√£o
            . achar que recurs√£o √© sempre melhor
            . confundir recurs√£o com loop

        DICAS:

            . Defina o caso base primeiro
            . Pergunte: qual √© a vers√£o menor do problema?
            . Cada chamada deve reduzir o problema
            . Teste manualmente com n = 0, 1, 2
            . Desenhe a √°rvore de chamadas
            . Se ficou confuso ‚Üí escreva vers√£o iterativa

        FRASES-CHAVE PARA MEMORIZAR

            Caso base manda
            Problema menor a cada passo
            Stack cresce
            Python n√£o otimiza tail recursion
            Recurs√£o √© modelo mental
            Loop percorre n√≠vel
            Recurs√£o percorre profundidade
            N√£o simule recurs√£o com loop
            Use loop dentro da recurs√£o, n√£o o contr√°rio

    =====================================================================

    tabelas de decis√£o:

        - Tabela de decis√£o √© uma estrutura que mapeia combina√ß√µes de 
        condi√ß√µes ‚Üí a√ß√µes.

        Em vez de:

            . muitos if / elif / else

            . l√≥gica espalhada

        Voc√™ tem:

            . regras expl√≠citas

            . decis√£o orientada a dados

            . baixo acoplamento

        √â uma t√©cnica de design, n√£o apenas de c√≥digo.

        O PROBLEMA QUE A TABELA DE DECIS√ÉO RESOLVE:

            Considere l√≥gica assim:

                if A and B:
                elif A and not B:
                elif not A and B:
                else:

            Isso gera:

                . explos√£o combinat√≥ria

                . c√≥digo dif√≠cil de manter

                . bugs silenciosos

                Tabela de decis√£o resolve isso.

        O QUE √â UMA TABELA DE DECIS√ÉO (FORMALMENTE):

            Uma tabela de decis√£o possui:

                1. Condi√ß√µes (entradas)

                2. Combina√ß√µes poss√≠veis

                3. A√ß√£o associada a cada combina√ß√£o

            Matematicamente:

                (condi√ß√£o1, condi√ß√£o2, ..., condi√ß√£oN) ‚Üí a√ß√£o

        MODELO MENTAL CORRETO:

            - Dados escolhem comportamento.

            Voc√™ n√£o pergunta:

                ‚ÄúQual if eu escrevo agora?‚Äù

            Voc√™ pergunta:

                ‚ÄúQuais estados existem e o que deve acontecer em cada um?‚Äù

        TABELA DE DECIS√ÉO EM PYTHON (FORMA NATURAL):

            Em Python, a forma mais comum √©:

                - dict

                - chaves compostas (tuple)

                - valores como fun√ß√µes ou resultados

            . Exemplo conceitual simples

                Regras:

                    usu√°rio vip?

                    possui cart√£o?

                | VIP | Cart√£o | A√ß√£o                |
                | --- | ------ | ------------------- |
                | Sim | Sim    | desconto_vip_cartao |
                | Sim | N√£o    | desconto_vip        |
                | N√£o | Sim    | desconto_cartao     |
                | N√£o | N√£o    | sem_desconto        |

            Representa√ß√£o:

                tabela = {
                    (True, True): acao1,
                    (True, False): acao2,
                    (False, True): acao3,
                    (False, False): acao4
                }

            Isso √© uma tabela de decis√£o expl√≠cita.

        TABELA DE DECIS√ÉO √ó IF/ELIF:

            | Crit√©rio       | `if/elif` | Tabela  |
            | -------------- | --------- | ------- |
            | Clareza        | M√©dia     | Alta    |
            | Escalabilidade | Baixa     | Alta    |
            | Manuten√ß√£o     | Dif√≠cil   | F√°cil   |
            | Testes         | Complexos | Simples |
            | Extens√£o       | Perigosa  | Segura  |

            Quanto mais regras ‚Üí mais a tabela vence.

        QUANDO USAR TABELA DE DECIS√ÉO:

            Use quando:

                . h√° muitas combina√ß√µes
                . regras s√£o est√°veis
                . l√≥gica √© determin√≠stica
                . regras s√£o parte do neg√≥cio

            Exemplos reais:

                . regras de desconto
                . permiss√µes
                . valida√ß√µes
                . impostos
                . workflows

        QUANDO N√ÉO USAR:

            N√£o use quando:

                . l√≥gica depende de sequ√™ncia temporal
                . decis√µes s√£o probabil√≠sticas
                . regras mudam durante execu√ß√£o
                . poucas condi√ß√µes simples

            N√£o √© bala de prata.
        
        TABELA DE DECIS√ÉO + FUN√á√ïES:

            A√ß√£o n√£o precisa ser valor ‚Äî pode ser fun√ß√£o.

                tabela[(True, False)]()

            Isso une:

                tabela de decis√£o

                dispatch por fun√ß√£o

                estrat√©gia

        TABELA DE DECIS√ÉO PARCIAL:

            - Nem todas as combina√ß√µes precisam existir.

                tabela.get(chave, acao_padrao)

            Isso substitui else.

        ERROS COMUNS:

            . chaves mal definidas
            . duplicar l√≥gica dentro das a√ß√µes
            . misturar regra com execu√ß√£o
            . usar tabela para l√≥gica sequencial
            . n√£o tratar caso padr√£o

        DICAS:

            . Liste todas as condi√ß√µes
            . Liste todos os estados poss√≠veis
            . Defina a a√ß√£o de cada estado
            . Crie chave composta (tuple)
            . Separe decis√£o de execu√ß√£o
            . Teste cada linha da tabela

        FRASES-CHAVE PARA MEMORIZAR:

            Regra vira dado
            Dado escolhe a√ß√£o
            Menos ifs, mais clareza
            Tabela escala melhor

    =====================================================================

    Operadores bit-wise:

        - Pensando como o computador

        - Operadores bit-wise operam diretamente nos bits (0 e 1) de um n√∫mero 
        inteiro.

        Eles n√£o trabalham com valores, mas com a representa√ß√£o bin√°ria do valor.

        BIN√ÅRIO, VERDADE E FALSO:

            No n√≠vel mais baixo:

                0 ‚Üí False

                1 ‚Üí True

            Mas aten√ß√£o:

                Em bit-wise, cada bit √© avaliado individualmente, n√£o o n√∫mero 
                inteiro.

            Exemplo:

                6  ‚Üí 110
                3  ‚Üí 011

            Cada coluna √© uma ‚Äúverdade‚Äù independente.

        OPERADORES BIT-WISE EM PYTHON:

            | Operador | Nome        | Leitura            |
            | -------- | ----------- | ------------------ |
            | `&`      | AND         | e                  |
            | `|`      | OR          | ou                 |
            | `^`      | XOR         | ou exclusivo       |
            | `~`      | NOT         | nega√ß√£o            |
            | `<<`     | SHIFT LEFT  | desloca √† esquerda |
            | `>>`     | SHIFT RIGHT | desloca √† direita  |

        . 1) AND (&)

            Regra l√≥gica

                1 & 1 = 1
                1 & 0 = 0
                0 & 1 = 0
                0 & 0 = 0

            C√°lculo bit a bit:

                6  = 110
                3  = 011
                ---------
                &  = 010  ‚Üí 2

            Interpreta√ß√£o:

                O bit s√≥ √© 1 se ambos forem 1.

        . 2) OR (|)

            Regra l√≥gica

                1 | 1 = 1
                1 | 0 = 1
                0 | 1 = 1
                0 | 0 = 0

            C√°lculo:

                6  = 110
                3  = 011
                ---------
                |  = 111 ‚Üí 7

            Interpreta√ß√£o

                O bit √© 1 se qualquer um for 1.

        . 3) XOR (^) ‚Äî OU EXCLUSIVO:

            Regra l√≥gica:

                1 ^ 1 = 0
                1 ^ 0 = 1
                0 ^ 1 = 1
                0 ^ 0 = 0

            C√°lculo:

                6  = 110
                3  = 011
                ---------
                ^  = 101 ‚Üí 5

            Interpreta√ß√£o

                O bit √© 1 somente se forem diferentes.

        . 4) NOT (~):

            Regra l√≥gica:

                ~1 = 0
                ~0 = 1

            Mas em Python:

                ~x == -(x + 1)

            Exemplo:

                ~5   # -6

            Por qu√™?

                Python usa complemento de dois, com tamanho infinito de bits.

        . 5) SHIFT LEFT (<<)

            Desloca bits para a esquerda (multiplica por 2‚Åø).

            EX:

                3 = 011
                3 << 1 = 110 ‚Üí 6
                3 << 2 = 1100 ‚Üí 12

                3 << 1  # 6
                3 << 2  # 12

            Regra matem√°tica:

                x << n = x * (2‚Åø)

        . 6) SHIFT RIGHT (>>)

            Desloca bits para a direita (divide por 2‚Åø).

            EX:

                8 = 1000
                8 >> 1 = 0100 ‚Üí 4
                8 >> 2 = 0010 ‚Üí 2

                8 >> 1  # 4

            Regra matem√°tica:

                x >> n = x // (2‚Åø)

        BIT-WISE √ó OPERADORES L√ìGICOS:

            | Tipo     | Operador           | Atua sobre  |
            | -------- | ------------------ | ----------- |
            | L√≥gico   | `and`, `or`, `not` | valores     |
            | Bit-wise | `&`, `|`, `^`, `~` | bits        |

            Erro comum:

                if x & y:   # bit-wise
                if x and y: # l√≥gico

            S√£o coisas diferentes.

        USO COM CONDICIONAIS (FLAGS):

            READ  = 0b001
            WRITE = 0b010
            EXEC  = 0b100

            permissao = READ | WRITE

        Verificar permiss√£o:

            if permissao & READ:
                print("Pode ler")

        Isso √© bit-masking.

        USO COM match:

            match permissao:
                case p if p & READ and p & WRITE:
                    print("Leitura e escrita")
                case p if p & READ:
                    print("Somente leitura")

        match + bit-wise = leitura expressiva.

        USO COM LOOPS:

            - Iterar bits de um n√∫mero

                n = 13  # 1101
                while n:
                    print(n & 1)
                    n >>= 1

        USO COM FUN√á√ïES:

            Verificar se n√∫mero √© par:

                def eh_par(n):
                    return (n & 1) == 0

            Mais baixo n√≠vel que:

                n % 2 == 0

        EXEMPLOS LEGAIS (CL√ÅSSICOS):

            1. Testar se √© pot√™ncia de 2

                def potencia_de_dois(n):
                    return n > 0 and (n & (n - 1)) == 0

            2. Contar bits 1

                def conta_bits(n):
                    count = 0
                    while n:
                        count += 1
                        n &= n - 1
                    return count

            3. Flags com enumera√ß√£o

                FLAG_A = 1 << 0
                FLAG_B = 1 << 1
                FLAG_C = 1 << 2

        O QUE S√ÉO ESSES BIN√ÅRIOS DE SA√çDA?

            - Eles s√£o novos estados compostos.

            Eles N√ÉO s√£o:

                n√∫meros m√°gicos

                valores arbitr√°rios

            Eles S√ÉO:

                representa√ß√µes compactas de m√∫ltiplas verdades independentes

        MODELO MENTAL CORRETO (MUITO IMPORTANTE):

            Pense assim:

                Cada bit = uma pergunta SIM / N√ÉO

            Exemplo:

                bit 0 ‚Üí pode ler?
                bit 1 ‚Üí pode escrever?
                bit 2 ‚Üí pode executar?

            Ent√£o:

                6 = 110 ‚Üí escrever + executar
                3 = 011 ‚Üí ler + escrever

                Bits n√£o t√™m significado natural.
                O significado √© voc√™ quem define.

                . OS BITS N√ÉO ‚ÄúSABEM‚Äù O QUE √â LER OU ESCREVER

                    O n√∫mero 6 = 110 significa apenas:

                        bit2  bit1  bit0
                        1     1     0

                    Isso √© tudo que o computador sabe.

                    ‚Äúler‚Äù, ‚Äúescrever‚Äù, ‚Äúexecutar‚Äù n√£o existem no n√∫mero.
                    Eles surgem quando voc√™ define uma conven√ß√£o.

                . A CONVEN√á√ÉO PRECISA SER FIXA

                    Quando eu escrevi:

                        bit 0 ‚Üí ler
                        bit 1 ‚Üí escrever
                        bit 2 ‚Üí executar

                    isso foi uma escolha arbitr√°ria, mas consistente.

                    Vamos escrever isso formalmente:

                        LER       = 1 << 0  # 001
                        ESCREVER  = 1 << 1  # 010
                        EXECUTAR  = 1 << 2  # 100

                    Agora sim temos um dicion√°rio de significado.

                . AGORA VAMOS REFAZER OS EXEMPLOS SEM AMBIGUIDADE

                    . N√∫mero 6

                        6 = 110

                    Bits ligados:

                        bit1 (010) ‚Üí ESCREVER

                        bit2 (100) ‚Üí EXECUTAR

                    6 = escrever + executar
                
                . N√∫mero 3

                    3 = 011

                Bits ligados:

                    bit0 (001) ‚Üí LER

                    bit1 (010) ‚Üí ESCREVER

                3 = ler + escrever

                . POR QUE 6 N√ÉO √â ‚ÄúLER + ESCREVER‚Äù?

                    Porque o bit de LER √© o bit 0, e no n√∫mero 6 ele est√° 
                    desligado:

                        6 = 110
                                ‚Üë
                              bit0 = 0  ‚Üí n√£o l√™

                    J√° no n√∫mero 3:

                        3 = 011
                                ‚Üë
                            bit0 = 1  ‚Üí l√™

                O ERRO MAIS COMUM (E FOI ESSE O SEU INC√îMODO):

                    Pensar que ‚Äúposi√ß√£o visual‚Äù do bit define significado.

                    ERRADO:

                        110 ‚Üí ‚Äúos dois primeiros‚Äù

                    CERTO:

                        cada posi√ß√£o = uma pot√™ncia de 2 fixa

                - Bit n√£o √© r√≥tulo.
                - Bit √© posi√ß√£o.
                - O significado vem da constante associada.

            Agora veja:

                AND (&):

                    comum aos dois ‚Üí escrever

                OR (|)

                    tudo que qualquer um pode ‚Üí ler + escrever + executar

                XOR (^)

                    o que s√≥ um deles pode ‚Üí ler + executar

            Isso √© l√≥gica de estados, n√£o matem√°tica comum.


        ERROS COMUNS

            . confundir & com and
            . usar bit-wise com floats
            . usar ~ sem entender complemento de dois
            . esquecer preced√™ncia (& < ==)
            . achar que bit-wise substitui l√≥gica comum

        DICAS:

            Pense em bits, n√£o em n√∫meros
            Use bit-wise quando:
                estados s√£o combin√°veis
                flags independentes
                performance importa
            Use m√°scaras para clareza
            Prefira nomes sem√¢nticos (READ, WRITE)
            Teste com bin√°rio (bin(x))

        FRASES-CHAVE PARA MEMORIZAR:

            Bit-wise √© l√≥gica por bit
            AND restringe
            OR ativa
            XOR alterna
            Shift multiplica/divide por 2
            Flags simplificam decis√µes
            Operadores bit-wise n√£o produzem n√∫meros.
            Eles produzem estados.

    =====================================================================

    Listas, Arrays e Vetores:

        - Estrutura de dados que armazena m√∫ltiplos valores em sequ√™ncia,
        acessados por √≠ndice.

        . Em Python

            . list √© a estrutura nativa

            . √â:

                ordenada

                mut√°vel

                heterog√™nea

                din√¢mica

        Python n√£o tem array fixo nativo como C.

        Para arrays num√©ricos reais: array, numpy (outro assunto).

        CRIA√á√ÉO DE LISTAS:

            lista = []
            lista = [1, 2, 3]
            lista = list(range(5))

        √çNDICES:

            √çndices come√ßam em 0

            √çndices negativos contam do final

                lista[0]    # primeiro
                lista[-1]   # √∫ltimo

            √çndice inv√°lido ‚Üí IndexError

        ACESSO A ELEMENTOS:

            leitura

            constante O(1)

        MODIFICANDO ELEMENTOS:

                lista[0] = 10

            Lista √© mut√°vel.

        SWAP COM LISTAS:

                lista[i], lista[j] = lista[j], lista[i]

            Swap nativo, sem vari√°vel auxiliar.

        TAMANHO DA LISTA:

            len(lista)

        SLICING:

                lista[inicio:fim:passo]

            Exemplos:

                lista[:3]
                lista[2:]
                lista[::-1]

            Slicing cria nova lista.

        C√ìPIA DE LISTA vs ENDERE√áAMENTO:

            Refer√™ncia (mesmo objeto):

                lista = [1, 2, 3]
                listab = lista

            C√≥pia rasa:

                lista = [1, 2, 3]
                listab = lista[:]
                listab = lista.copy()

            Modificar b n√£o afeta a.

        LISTA COM OPERADORES:

                [1, 2] + [3, 4]     # concatena
                [0] * 5             # repete

            - + cria nova lista

            - * replica refer√™ncias (cuidado com listas aninhadas)

        LISTA COM CONDICIONAIS:

                for x in lista:
                    if x > 0:
                        ...

            Muito comum em filtragem.

        LISTA COM LOOPS:

            FOR:

                    for x in lista:

                Com √≠ndice:

                    for i in range(len(lista)):

                Melhor:

                    for i, v in enumerate(lista):

            while:

                i = 0
                while i <= len(lista):

        LISTA COM N√öMEROS

            Usos comuns:

                soma

                m√©dia

                m√°ximo

                m√≠nimo

                contagem

        LISTA COM STRINGS

                nomes = ["Ana", "Jo√£o"]

            Comuns:

                normaliza√ß√£o

                busca

                compara√ß√£o

                parsing

        in / not in vs is / is not:

            . in: Verifica valor

                x in lista

            . is: Verifica objeto. Nunca use is para comparar valores de lista.

                x is y

        sort vs sorted:

            - Ordenam a lista

            . sort()

                    lista.sort()
                    lista.sort(reverse=True)

                . modifica a lista

                . retorna None

            . sorted()

                    nova = sorted(lista)
                    nova = sorted(lista, reverse=True)

                . cria nova lista

                . original intacta

        index:

                lista.index(valor)

            . retorna √≠ndice

            . erro se n√£o existir

        min e max:

            min(lista)  # Menor valor
            max(lista)  # Maior valor

        sum: Apenas para n√∫meros.

            sum(lista)  # Soma o conte√∫do da lista

        count:

            Faz contagem de um elemento na lista

            PS: √â usado com strings e outros iter√°veis tamb√©m

                lista.count(valor)

        reverse:

                lista.reverse()

            . In-place

            . Diferente de lista[::-1]

        zip:

                zip(lista1, lista2)

            . itera√ß√£o paralela

            . gera tuplas

        enumerate:

                enumerate(lista)

            . √≠ndice + valor

            . padr√£o profissional

        append, insert, extend, concatena√ß√£o:

            append: Adiciona no final daa lista

                lista.append(x)

            insert: Adiciona em uma posi√ß√£o espec√≠fica da lista.
            PS: Fica inificiente em rela√ß√£o a posi√ß√£o escolhidas e tamanho da
            lista, pois ele movimenta os dados para o pr√≥ximo ap√≥s a inser√ß√£o

                lista.insert(i, x)

            extend: Funde uma lista na outra

                lista.extend(outra)

            concatena√ß√£o: Junta uma lista na outra

                lista + outra

        REPETI√á√ÉO DE ELEMENTOS:

                [0] * 5

            PS: Cuidado com listas aninhadas:

                [[0]*3]*3  # errado

        REMO√á√ÉO: pop, remove, del:

            pop: Remove um valor por √≠ndice escolhido

                lista.pop()  # Padr√£o sempre o √∫ltimo
                lista.pop(i)

            remove: Remove por valor

                lista.remove(valor)

            del: Forma alternativa de remover um item. Mas cuidado,
            se voc√™ dar um del lista sem especificar o item, apagar√° a 
            refer√™ncia inteira da lista.

                del lista[i]

        EMPACOTAMENTO E DESEMPACOTAMENTO:

                a, b = [1, 2]

            Com estrela: Pega todo o resto

                a, *resto = [1, 2, 3, 4]

        OUTRAS PROPRIEDADES E T√âCNICAS:

            . Lista √© heterog√™nea

                [1, "a", True]

            . Lista √© din√¢mica

                cresce

                diminui

            . Lista pode conter listas

                matriz = [[1,2],[3,4]]

            . Percurso seguro:

                for x in lista[:]:

        ERROS COMUNS:

            . confundir c√≥pia com refer√™ncia
            . usar is em vez de ==
            . modificar lista enquanto itera
            . usar √≠ndice quando n√£o precisa
            . esquecer que sort() n√£o retorna lista

        DICAS:

            Precisa de ordem? ‚Üí lista
            Precisa mudar valores? ‚Üí lista
            Precisa percorrer? ‚Üí for ou while dependendo da situa√ß√£o
            Precisa √≠ndice? ‚Üí enumerate
            Precisa c√≥pia? ‚Üí copy()
            Muito if? ‚Üí refatorar

        FRASES-CHAVE PARA MEMORIZAR:

            Lista √© mut√°vel
            √çndice come√ßa em zero
            Slicing copia
            sort modifica
            sorted cria nova
            in verifica valor

    =====================================================================

    Indices:

    =====================================================================

    In place:

    =====================================================================

    Janelas:

    =====================================================================

    Slicing:

    =====================================================================

    Divis√£o e conquista:

    =====================================================================

    Rota√ß√£o:

    =====================================================================

    Listas, Arrays e Vetores circulares:

    =====================================================================

    Matrizes:

    =====================================================================

    Diagonais:

    =====================================================================

    Matriz circular:

    =====================================================================

    Tuplas:

    =====================================================================

    Dicion√°rios:

    =====================================================================

    Conjuntos:

    =====================================================================

    tecnica de ponteiros:

    =====================================================================

    Divis√£o e conquista:

    =====================================================================

    n√∫meros aleat√≥rios:

    =====================================================================

    regex:

    =====================================================================

    M√≥dulos, Bibliotecas e importa√ß√µes:

    =====================================================================

    Alias:

    =====================================================================

    Garbage:

    =====================================================================

    shuffle:

    =====================================================================

    Arquivos:

    =====================================================================

    Geradores:

    =====================================================================

    Programa√ß√£o funcional (map, any, sum, all):

    =====================================================================

    Fallback:

    =====================================================================

    Exce√ß√µes, assertations e testes de software:

    =====================================================================

    Assincronismo, fun√ß√µes e geradores ass√≠ncronos, threads e processos:

    =====================================================================


Um pouco sobre POO:

    Objetos e classes

    Vari√°veis de classe e Construtor

    M√©todos

    atributos e propriedades de classe

    atributos privados, protegidos e p√∫blicos

    m√©todos privados, protegidos e p√∫blicos

    Encapsulamento

    Composi√ß√£o, heran√ßa e delega√ß√£o

    Polimorfismo

    Sub-tipagem

    M√©todos de classe

    M√©todos abstratos

    M√©todos est√°ticos

    self e cls

    M√©todos m√°gicos

    DataClass

    Setups, interfaces e Managers

    SOLID

Um pouco sobre Estruturas de dados:

    listas / vetores e matrizes n√£o ordenadas

    listas / vetores e matrizes ordenadas

    matrizes

    Torre de Hanoi

    algoritmos de busca

    algoritmo de Ordena√ß√µes

    BFS √ó DFS

    pilhas

    filas

    fila de prioridade

    fila circular

    fila de extremidade dupla

    deques

    Lista encadeada

    √°vores

    hash tables

    grafos

    Busca em profundidade

    Busca em largura

    Busca gulosa

    Busca A*

    Algoritmo de Dijkstra
