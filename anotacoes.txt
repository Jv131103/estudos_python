- Um programa ou software, √© o que podemos chamar de intelig√™ncia do computador

- O hardware √© a m√°quina, a parte f√≠sica

- Em computa√ß√£o, dados s√£o a representa√ß√£o simb√≥lica de um fato ou acontecimento.
Os fatos podem ser, nomes, datas, valores num√©ricos, imagens, etc. Ou seja,
qualquer coisa que possa ser medido, comparado ou representados no computador.

- Os s√≠mbolos mais comuns s√£o as letras e os n√∫meros. (As imagens e os sons s√£o representados
no computador por uma sequencia de n√∫mero).

- Uma informa√ß√£o √© um dado, ou conjunto de dados, ou o o resultado da transforma√ß√£o de um
conjunto de dados que, dentro de determinado contexto, fa√ßa sentido para algu√©m. Poe exemplo,
uma ficha m√©dica, ou um formul√°rio de cadastro.

- Qualquer fato, pode ser representado simbolicamente? N√£o. Por que certos, fatos,
n√£o podem ser representados como s√£o na realidade, por conta de n√£o poderem ser interpretados
l√≥gico-matematicamente. Outros, por conta de n√£o serem duais, assim n√£o interpretados, como zeros
e uns. Emo√ß√µes, sabores e sentimentos s√£o exemplos de fatos que n√£o podem ser representados,
por serem complexas e por terem reprodu√ß√£o al√©m do l√≥gico.

SOBRE SISTEMA BIN√ÅRIO

- S√£o representados por 0s e 1s, embora, haja outros sistemas, como tern√°rios,
decimais, hexadecimais e octais.

- O computador atualmente, entende apenas 0s e 1s que representam ligado e desligado,
tal que seguem o princ√≠pio de ebtrada e sa√≠da de energia no hardware.

- Possui um sistema de numera√ß√£o onde cada d√≠gito, aqui chamado de bit, tem apenas dois valores
poss√≠veis, ou seja, 0 e 1

- No sistema decimal, podemos representar at√© 10 elementos com um √∫nico d√≠gito:

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9

- No sistema bin√°rio, podemos representar apenas 2 com um √∫nico bit.

    0, 1

- Para se poder rtepresentar mais elementos, √© necess√°rio acrescentar outros d√≠gitos e bits.

- O 11¬∞ elemento no sistema decimal e'representado por 10.

    IMPORTANTE: Na computa√ß√£o, o valor 0 √© super significativo quanto a identificar elementos

- No sistema bin√°rio, o 3¬∞ elemento, j√° que s√≥ podemos representar o 2 como um √∫nico bit, ser√°
o 10.

- Tabela de 0, 20

    Decimal | Bin√°rio
    0       | 0
    1       | 1
    2       | 10
    3       | 11
    4       | 100
    5       | 101
    6       | 110
    7       | 111
    8       | 1000
    9       | 1001
    10      | 1010
    11      | 1011
    12      | 1100
    13      | 1101
    14      | 1110
    15      | 1111
    16      | 10000
    17      | 10001
    18      | 10010
    19      | 10011
    20      | 10100

- No sistema decimal, cada d√≠gito adicional aumenta em 10 vezes a capacidade de contagem, ao passo
que no bin√°rio, cada bit adicional aumenta em 2 vezes.

- Qual a capacidade de contagem de um n√∫mero com 3 d√≠gitos?

    10**3 = 1000

    - Vai de 0 a 999

- Qual a capacidade de contagem de um n√∫mero com 3 bits?

    2**3 = 8

    - Vai de 0 a 7

- Como saber quanto um bin√°rio vale em decimal?

    EX:

        1       0       0       1       1       0       1       0       1       0       1       1       1       0
        2**13   2**12   2**11   2**10   2**9    2**8    2**7    2**6    2**5    2**4    2**3    2**2    2**1    2**0
        8192    4096    2048    1024    512     256     128     64      32      16      8       4       2       1
        8192    0       0       1024    512     0       128     0       32      0       8       4       2       0

        8192 + 0 + 0 + 1024 + 512 + 0 + 128 + 0 + 32 + 0 + 8 + 4 + 2 + 0 =  9902


        1¬∞ linha: S√≠mbolo bin√°rio
        2¬∞ linha: Resutado do valor 2**n
        3¬∞ linha: Resultado do valor de 2**n * s√≠mbolo bin√°rio

        10011011

        2**7 = 128 * 1 = 128
        2**6 = 64 * 0 = 0
        2**5 = 32 * 0 = 0
        2**4 = 16 * 1 = 16
        2**3 = 8 * 1 = 8
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 1 = 1

        128 + 16 + 8 + 2 + 1 = 155

- Como saber quanto um decimal vale em bin√°rio?

    EX: 100

    100 / 2 = 50, resto 0
    50 / 2 = 25, resto 0
    25 / 2 = 12, resto 1
    12 / 2 = 6, resto 0,
    6 / 2 = 3, resto 0
    3 / 2 = 1, resto 1,
    1 / 2 = resto 1, pois 1 n√£o divide 2

    resultado dos restos: 0010011

    inverte ficar√°: 1100100

- Pr√°tico:

    Exerc√≠cio 1 - Foi vista na videoaula a convers√£o do n√∫mero
    bin√°rio 10011010111001 para o seu equivalente decimal que
    resultou em 9913.

    Acrescente um bit 0 √† direita (o menos significativo) deste
    n√∫mero bin√°rio e veja que n√∫mero decimal obter√°.
    
    Divida este novo n√∫mero decimal obtido pelo decimal anterior e
    analise o resultado.

        100110101110010

        2**14 = 16384 * 1 = 16384
        2**13 = 8192 * 0 = 0
        2**12 = 4096 * 0 = 0
        2**11 = 2048 * 1 = 2048
        2**10 = 1024 * 1 = 1024
        2**9 = 512 * 0 = 0
        2**8 = 256 * 1 = 256
        2**7 = 128 * 0 = 0
        2**6 = 64 * 1 = 64
        2**5 = 32 * 1 = 32
        2**4 = 16 * 1 = 16
        2**3 = 8 * 0 = 0
        2**2 = 4 * 0 = 0
        2**1 = 2 * 1 = 2
        2**0 = 1 * 0 = 0

        16384 + 2048 + 1024 + 256 + 64 + 32 + 16 + 2 = 19826

        Divis√£o: 19826 // 9913 = 2


    Exerc√≠cio 2 - Com o resultado decimal obtido no exerc√≠cio 1, aplique a t√©cnica da divis√£o 
    sucessiva por 2 para obter seu equivalente bin√°rio. O resultado dever√° ser o n√∫mero original

        19826

        19826 // 2 = 9913, resto 0
        9913 // 2 = 4956, resto 1
        4956 // 2 = 2478, resto 0
        2478 // 2 = 1239, resto 0
        1239 // 2 = 619, resto 1
        619 // 2 = 309, resto 1
        309 // 2 = 154, resto 1
        154 // 2 = 77, resto 0
        77 // 2 = 38, resto 1
        38 // 2 = 19, resto 0
        19 // 2 = 9, resto 1
        9 // 2 = 4, resto 1
        4 // 2 = 2, resto 0
        2 // 2 = 1, resto 0
        1 // 2 = 1

        Resultado dos restos: 010011101011001

        Resultado final, invertido: 100110101110010

SOBRE O COMPUTADOR:

- A Mem√≥ria, √© onde se armazena e endere√ßa informa√ß√µes e dados. √â nela onde se permite
guardar informa√ß√µes e registr√°-las e mant√™-las enquanto o programa ou a m√°quina estiver ligada.
√â nela onde o processador se comunica retornando informa√ß√µes. Ela se divide em dois pontos:

    . Endere√ßo fixo: O local referente onde os dados est√£o armazenados

    . Conte√∫do varti√°vel: O conte√∫do que est√° armazenado no endere√ßo e pode ser mut√°vel

- 1 byte cont√©m 8 bits

- Os computadores tradicionais se comp√µem de uma grande sequencia de bytes de 8 bits

- A ideia original de que o byte deva ter 8 bits surgiu da necessidade de se ter um c√≥digo
para representar cada um dos caracteres vis√≠veis (letras, n√∫meros, sinais de pontua√ß√£o e
alguns s√≠mbolos mais utilizados como o $, %, @ e outros), al√©m de caracteres de controle
(invis√≠veis) tais como o comando de saltar linha na tela ou soar o beep do PC. Chegou na
conclus√£o que 8 bits era mais que o suficiente

- A tabela ASCII, √© um formato interpretador que serve de base para interpreta√ß√£o unicode
dos dados. Ela possui seus caracteres em 8 bits e foi uma das bases mais usadas e at√© hoje
√© bastante utilizada. Nela, a letra 'a' t√™m o valor de 01100001 (97 em decimal) e o caracter
num√©rico '1' tem o valor de 00110001 (49 em decimal).

- No caso dos n√∫meros, este valor √© meramente um identificador do s√≠mbolo do n√∫mero, porque
o seu valor matem√°tico est√° nos bits conforme vimos anteriormente. E como disse acima,
49 n√£o representa o valor matem√°tico 1 e sim representa o tipo de texto 1, ou seja,
o valor simb√≥lico, n√£o literal.

- O byte √© um agrupamento voltado aos conte√∫dos da mem√≥ria, sendo que a quantidade de bits
para fazer o endere√ßamento da mem√≥ria segue outra contagem. Os primiros Pcs pessoais tinham mem√≥ria
com endere√ßamento de 8 bits, o que permitia apenas 256 endere√ßos.

- A CPU (Central Processing Unit), √© o mecanismo principal do computador. √â nele onde as instru√ß√µes
s√£o processadas e ela √© respons√°vel por trabalhar com o conte√∫do das mem√≥ria, recebendo dados
e retornando-as / escrevendo para tal. Ela realiza um procedimento de coleta de cada item
endere√ßado na mem√≥ria, e faz um trabalho X nela dependendo do dado, procedimento pedido e 
comportamento do sistema com o hardware.

- Os conte√∫dos da CPU s√£o:

    . Instru√ß√µes:

        - Dizem a CPU o que fazer

        - Cada instru√ß√£o, possui um SET, que √© respons√°vel por dizer a CPU que coisas devem acontecer

            EX de um computador elementar de 4 bits a n√≠vel bin√°rio:

                x----------x--------------------------------------------------------------------x
                | Conte√∫do |                            A√ß√£o                                    |
                x----------x--------------------------------------------------------------------x
                |   0000   | Interrompe a execu√ß√£o do programa                                  |
                x----------x--------------------------------------------------------------------x
                |   0100   | L√™ o conte√∫do da mem√≥ria que est√° no endere√ßo logo a seguir a esta |
                |          | instru√ß√£o e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |   0110   | L√™ o conte√∫do da mem√≥ria que est√° no endere√ßo logo a seguir a esta |
                |          | instru√ß√£o e armazena no registrador 1.                             |
                x----------x--------------------------------------------------------------------x
                |          | Soma o conte√∫do do registrador 1 com o conte√∫do do registrador 2   |
                |   0111   | e armazena o resultado no endere√ßo de mem√≥ria cujo n√∫mero equivale |
                |          | ao conte√∫do do endere√ßo a seguir a esta instru√ß√£o                  |
                x----------x--------------------------------------------------------------------x

            PS: Cada c√≥digo bin√°rio representa uma a√ß√£o espec√≠fica, previamente definida pela 
            arquitetura da CPU.

    . Dados:

        - Manipulados pelas instru√ß√µes para que determinado pedido ou resultado seja obtido


- Linguagem bin√°ria ou de m√°quina: √â a linguagem do computador, respons√°vel por seguir
sequencias complexas de instru√ß√µes, tudo isso seguindo no princ√≠pio bin√°rio.

- Linguagem Assembly: rela√ß√£o direta entre as instru√ß√µes em linguagem bin√°ria e express√µes
mnem√¥nicas.

    Instru√ß√£o Bin√°ria       Correspondente eletr√¥nico
          0000                         stop
          0100                         read 1
          0110                         read 2
          0111                         add 1 2

- Esta "altitude" do n√≠vel de uma linguagem diz respeito, em linhas gerais, a facilidade e rapidez
com que se produz um programa. Ou seja, s√£o necess√°rias menos instru√ß√µes escritas pelo programador
para se obter um mesmo resultado. Em outras palavras uma instru√ß√£o escrita produz mais instru√ß√µes
bin√°rias. Por√©m, linguagens de alto n√≠vel, costumam produzir programas de desempenho inferior

- Os compiladores leem o programa fonte e produzem um programa execut√°vel independente de qualquer
outro software que n√£o seja o sistema operacional do computador.

            PROGRAMA -> COMPILADOR -> PROGRAMA.exe 
            
        ps: Em sistemas UNIX PROGRAMA.exe, retorna apenas PROGRAMA, mas no fundo √© um execut√°vel 
        tamb√©m

- Os interpretadores leem o programa fonte, criam este programa na mem√≥ria (bin√°rio) e o executam.
N√£o existe programa executavel gerado.Tudo √© realizado pelo interpretador.

    . Os interpretadores facilitam o trabalho de manuten√ß√£o principalmente em grandes sistemas
    compostos de muitos programas

    . Em ambientes de muitos programas rodando simultaneamente, os interpretadores consomem menos
    mem√≥ria

    . Considerando uma mesma linguagem, o seu computador produz programas mais r√°pidos do que
    o seu interpretador.

SOBRE PROGRAMAS

- Um programa √© um conjunto de passos e instru√ß√µes, organizadas de maneira l√≥gica, que realiza um ou mais servi√ßos
de processamento de dados.

- Processamento de dados √© o ato de tratar dados brutos e obter dados tranformados, seguindo especifica√ß√µes previamente
estabelecidas, ou obter infortma√ß√µes com esses dados contextualizados.


                    DADOS BRUTOS -> PROGRAMA -> DADOS TRABALHADOS

- Um programa pode ser simples ou composto por diversos outros programas

- Um algoritmo √© uma sequencia finita de passos, etapas ou instru√ß√µes que resolvem determinados
problemas. Um algoritmo √© dito determin√≠stico quando se obt√©m sempre o mesmo resultado a partir dos
mesmos dados. Um programa pode ter 1 ou N algor√≠tmos.

- Um exemplo de um algoritmo funcional:

    . Cada linguagem t√™m uma estrutura ou sintaxe

    . Cada programa possui uma linha de execu√ß√£o. Dependendo da linguagem, ela precisa ser fechada
    ou conclu√≠da, para referenciar outra linha ou se fecha automaticamente.

    . vari√°veis s√£o defini√ß√µes e referencias a objetos ou valores no programa. Eles s√£o escopos
    de mem√≥ria onde se realizar√° procedimentos e armazenazem temp√≥r√°ria de dados e informa√ß√µes.
    Elas n√£o podem come√ßar com n√∫meros e s√≠mbolos que n√£o sejam _ e tamb√©m com espa√ßos.

    EX: ISSO FOI CRIADO POR MIM, UMA FORMA INTERPRETATIVA MINHA DE MOLDAR ALGORITMO FORA DA M√ÅQUINA
    √â MERA INTERPRETA√á√ÉO, PODEMOS USAR FERRAMENTAS J√Å PRONTAS QUE LEIAM EM PORTUGU√äS OU PODE MONTAR DO
    SEU JEITO, CONTANTO, QUE SIGA NORMAS E PADR√ïES DA COMPUTA√á√ÉO E QUE FIQUE F√ÅCIL DE VOC√ä APLICAR,
    LER E IMPLEMENTAR EM OUTRAS LINGUAGENS.

        T√çTULO: "Soma"
        OBSERVACAO: "Vai realizar a soma de dois n√∫mero"

        INICIO

        num1: int = int(ler("N1: "))
        num2: int = int(ler("N2: "))

        soma: int = num1 + num2   # Realiza a soma

        exibir f"Resultado = {soma}"

        FIM

- Um outro exemplo no qual usamos fun√ß√µes. Fu√ß√µes s√£o blocos de c√≥digos, especializados
para executar fun√ß√µes espec√≠ficas de c√≥digo, ou seja, realizam procedimentos dentro de um escopo,
para que seja implementado no escopo principal. Ela facilita a leitura e entendimento do c√≥digo e 
traz mais efici√™ncia, legibilidade e pode ser usada e reaproveitada em outros programas.

    T√çTULO: "Fun√ß√£o"
    OBSERVACAO: "Vai realizar uma demonstra√ß√£o do que √© uma fun√ß√£o"

    INICIO

    REALIZAR M√âDIA DE DOIS N√öMEROS
    [fun√ßao] media
        params:
            n1: int
            n2: int
        a√ß√µes:
            retornar (n1 + n2) / 2
    [fimfuncao]


    num1: float = float(ler("N1: "))
    num2: float = float(ler("N2: "))

    media: float = media(num1, num2)

    exibir f"A m√©dia √© {media:.2f}"

    FIM

- Ide vs Editor de c√≥digo fonte:

    . Ide (Integrated Development Environment): Uma IDE √© um ambiente completo 
    de desenvolvimento. Ela integra v√°rias ferramentas em um s√≥ lugar.

        O que uma IDE j√° traz integrada:

            + Editor de c√≥digo

            + Compilador / interpretador

            + Debugger (passo a passo)

            + Gerenciador de projetos

            + Gerenciador de depend√™ncias
            
            + Build / Run com um clique
            
            + Testes integrados

        A IDE entende:

            o projeto

            a linguagem

            a estrutura

            as depend√™ncias

        Exemplos t√≠picos

            . PyCharm

            . IntelliJ IDEA

            . Eclipse

            . Visual Studio

            . NetBeans

        ‚Üí ‚ÄúEu desenvolvo software aqui‚Äù

    . Editor de c√≥digo fonte: Um editor de c√≥digo √© uma ferramenta focada em 
    escrever e editar texto/c√≥digo. Ele n√£o se preocupa com o projeto inteiro,
    s√≥ com o arquivo que voc√™ est√° editando. 
    
        Um editor oferece:

            + Destaque de sintaxe (cores)

            + Numera√ß√£o de linhas

            + Busca e substitui√ß√£o

            + Autocompletar b√°sico

            + Leve e r√°pido
        
        Exemplos t√≠picos

            . VS Code (editor avan√ßado)

            . Sublime Text

            . Notepad++

            . Vim / Nano

        ‚Üí ‚ÄúEu escrevo c√≥digo aqui‚Äù


TABELA ASCII (origem hist√≥rica):

- ASCII foi o primeiro padr√£o de caracteres.

- Caracter√≠sticas:

    . 7 bits (0 a 127)

    . Letras A‚ÄìZ, a‚Äìz

    . D√≠gitos 0‚Äì9

    . S√≠mbolos b√°sicos

    . Sem acentos

- ASCII n√£o suporta:

    . √ß

    . √°, √©, √≠

    . emojis
 
    . l√≠nguas n√£o latinas

UNICODE (padr√£o universal)

- Unicode √© um cat√°logo gigante de caracteres do mundo inteiro.

- Inclui:

    . Letras latinas com acento

    . Japon√™s, chin√™s, √°rabe

    . S√≠mbolos matem√°ticos

    . Emojis üòÑüî•

    . Alfabetos antigos

- Cada caractere tem um c√≥digo √∫nico

- Unicode √© abstrato (s√≥ define os c√≥digos).

UTF-8 (codifica√ß√£o)

- UTF-8 √© a forma de guardar Unicode em bytes.

- Caracter√≠sticas:

    . Compat√≠vel com ASCII

    . Usa 1 a 4 bytes por caractere

    . Padr√£o da internet

    . Padr√£o do Python

- Unicode = o que √©

- UTF-8 = como √© armazenado


UM POUCO SOBRE L√ìGICA DE PROGRAMA√á√ÉO:

    Vari√°veis:

        - Vari√°vel √© um nome que guarda um valor na mem√≥ria para ser usado depois.

        . Vari√°vel = caixa com nome

        . Valor = conte√∫do da caixa

        . O valor pode mudar ao longo do programa

        . Serve para guardar dados tempor√°rios

        Por que vari√°veis existem?

            . Evitam repetir valores

            . Facilitam c√°lculos

            . Permitem decis√µes (if)

            . Permitem repeti√ß√µes (while, for)

        Antes de criar qualquer vari√°vel, pergunte:

            1. Que informa√ß√£o eu preciso guardar?

            2. Essa informa√ß√£o muda ou √© fixa?

            3. Vou usar esse valor depois?

            4. Esse nome est√° claro para um humano?

        - Nome bom de vari√°vel explica o que ela guarda.

        TIPOS MAIS COMUNS DE VARI√ÅVEIS (conceito):

            | Tipo    | Guarda o qu√™?       | Exemplo         |
            | ------- | ------------------- | --------------- |
            | inteiro | n√∫meros sem v√≠rgula | idade = 20      |
            | real    | n√∫meros com v√≠rgula | altura = 1.75   |
            | texto   | palavras/frases     | nome = "Renato" |
            | l√≥gico  | verdadeiro ou falso | aprovado = True |

        EXEMPLOS SIMPLES:

            Exemplo 1 ‚Äî Guardar valor

                idade = 20

            Mental: ‚ÄúCriei uma caixa chamada idade e coloquei o valor 20 dentro.‚Äù

            Exemplo 2 ‚Äî Usar vari√°vel

                preco = 10
                total = preco + 5
            
            Mental: ‚ÄúUsei o valor guardado para calcular outro.‚Äù

            Exemplo 3 ‚Äî Valor muda

                contador = 0
                contador = contador + 1

            Mental: ‚ÄúA vari√°vel continua existindo, mas o valor mudou.‚Äù
        
        ERROS COMUNS:

            Usar nomes confusos:

                x = 10   # ruim

            Melhor:

                quantidade = 10

            Usar vari√°vel sem valor:

                print(total)  # erro se total n√£o existir

            Pensar que vari√°vel √© o valor:

                - N√£o √©

                Vari√°vel √© o nome, n√£o o conte√∫do.

        FRASE-CHAVE (decora essa)

            . Vari√°vel n√£o √© n√∫mero, nem texto.

            . Vari√°vel √© um nome que aponta para um valor.

        DICAS:

            . Pense no nome antes do valor
            . Vari√°vel deve ter sentido humano
            . Uma vari√°vel = uma informa√ß√£o
            . Se travar, pergunte: ‚ÄúO que eu preciso guardar?‚Äù
    
    =====================================================================

    Constantes:

        - Constante √© um valor que N√ÉO deve mudar durante o programa.

        . Constante = valor fixo

        . Serve para representar regras, limites ou padr√µes

        . Evita ‚Äún√∫meros m√°gicos‚Äù espalhados no c√≥digo

        . Deixa o programa mais claro e seguro

        Ideia-chave:

            - Se n√£o pode mudar, n√£o deve ser vari√°vel.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Perguntas obrigat√≥rias antes de decidir:

                1. Esse valor pode mudar durante a execu√ß√£o?

                2. Ele representa uma regra do problema?

                3. Se mudar no futuro, deveria mudar em um s√≥ lugar?

                4. Esse valor tem significado fixo no mundo real?

            Se a resposta for ‚Äún√£o muda‚Äù ‚Üí constante

        DIFEREN√áA CLARA: VARI√ÅVEL √ó CONSTANTE:

            | Conceito  | Pode mudar?  | Exemplo        |
            | --------- | ------------ | -------------- |
            | Vari√°vel  | ‚úÖ Sim       | idade, saldo   |
            | Constante | ‚ùå N√£o       | PI, taxa fixa  |

        - Constante n√£o depende do usu√°rio, nem do tempo.

        COMO REPRESENTAR CONSTANTES (boa pr√°tica):

            Em Python, usa-se:

                . Nome em MAI√öSCULO

                . Separa√ß√£o com _

                EX:

                    PI = 3.14
                    TAXA_JUROS = 0.05
                    IDADE_MINIMA = 18
        
            Mesmo que Python permita mudar, a regra √© l√≥gica, n√£o da linguagem.

        Exemplo 1 ‚Äî Regra matem√°tica

            PI = 3.14
            area = PI * 10 * 10

        Mental: ‚ÄúPI n√£o muda. O raio pode mudar.‚Äù

        Exemplo 2 ‚Äî Regra de neg√≥cio
            
            IDADE_MINIMA = 18
            idade = 20

        Mental: ‚ÄúA idade muda, a regra n√£o.‚Äù

        Exemplo 3 ‚Äî Evitando n√∫mero m√°gico

            Ruim:

                total = preco * 0.1

            Bom:

                DESCONTO = 0.1
                total = preco * DESCONTO
            
        ERROS COMUNS:

            . Usar valor fixo direto no c√≥digo

            . Espalhar o mesmo n√∫mero em v√°rios lugares

            . Tratar regra como vari√°vel

            . Nomear constante como vari√°vel comum

        Regra pr√°tica:

            - Se voc√™ precisar procurar o n√∫mero no c√≥digo para entender, ele 
            deveria ser uma constante.

        FRASE-CHAVE PARA MEMORIZAR:

            . Vari√°vel guarda estado.

            . Constante guarda regra.

        DICAS:

            . Regra ‚Üí constante
            . Dado do usu√°rio ‚Üí vari√°vel
            . Constante no topo do c√≥digo
            . Nome claro e em mai√∫sculo
            . Menos n√∫meros ‚Äúsoltos‚Äù = menos erro

    =====================================================================

    Tipos de dados:

        - Tipo de dado define o que uma informa√ß√£o √© e o que pode ser feito 
        com ela.

        Existem duas grandes vis√µes:

            . Primitivos √ó Compostos

            . Objeto √ó N√£o-objeto

            Essas vis√µes se complementam, n√£o competem.
        
        TIPOS PRIMITIVOS (ou simples):

            - Guardam um √∫nico valor simples.

            Caracter√≠sticas:

                Valor √∫nico

                N√£o possuem partes internas

                Representam dados b√°sicos

            Exemplos comuns:

                N√∫mero inteiro ‚Üí 10

                N√∫mero real ‚Üí 2.5

                Texto ‚Üí "Ol√°"

                L√≥gico ‚Üí True / False

            Ideia-chave:

                - Primitivo = uma informa√ß√£o s√≥.

        TIPOS COMPOSTOS:

            - Guardam v√°rios valores ou estruturas internas.

            Caracter√≠sticas:

                Podem conter v√°rios dados

                Organizam informa√ß√µes relacionadas

                Facilitam trabalhar com conjuntos

            Exemplos comuns:

                Lista

                Tupla

                Conjunto

                Dicion√°rio

            Ideia-chave:

                - Composto = v√°rias informa√ß√µes agrupadas.

        COMPARA√á√ÉO R√ÅPIDA:

            | Tipo      | Quantidade de dados |
            | --------- | ------------------- |
            | Primitivo | 1 valor             |
            | Composto  | V√°rios valores      |

        N√ÉO-OBJETO (vis√£o l√≥gica):

            - Dado sem comportamento pr√≥prio.

            . S√≥ representa um valor

            . N√£o ‚Äúfaz coisas‚Äù
            
            . Usado diretamente em c√°lculos e decis√µes

            Exemplos:

                N√∫mero

                Texto

                Booleano

            Pense assim:

                . √â s√≥ dado, n√£o √© coisa.

        OBJETO (vis√£o mais avan√ßada):

            - Objeto = dado + comportamento.

            Caracter√≠sticas:

                . Tem valor

                . Tem a√ß√µes

                . Possui estrutura interna

                . Pode ser manipulado por m√©todos

            Exemplo conceitual:

                . Uma lista guarda valores e sabe adicionar, remover, ordenar.

            Objeto √© algo que:

                - Guarda dados

                - Sabe operar sobre si mesmo

                - Referencia moldes espec√≠ficos para se realizar a√ß√µes

        OBJETO √ó N√ÉO-OBJETO (resumo mental):

            | Conceito   | O que √©      |
            | ---------- | ------------ |
            | N√£o-objeto | Dado puro    |
            | Objeto     | Dado + a√ß√µes |

        Em Python:
        
            Tudo √© objeto, mas conceitualmente essa separa√ß√£o ajuda muito a 
            entender POO.

        Exemplo 1 ‚Äî Primitivo

            idade = 20

        Mental: Um √∫nico valor.

        Exemplo 2 ‚Äî Composto

            notas = [7, 8, 9]

        Mental: V√°rios valores agrupados.

        Exemplo 3 ‚Äî Objeto em a√ß√£o

            notas.append(10)

        Mental: A lista faz algo.

        Exemplo 4 ‚Äî N√£o-objeto

            soma = 10 + 5

        Mental: Apenas valores sendo usados.

        ERROS COMUNS:

            - Achar que tudo √© s√≥ n√∫mero
            - Confundir tipo com valor
            - N√£o perceber quando precisa de estrutura
            - Tentar resolver tudo com primitivos

            Regra pr√°tica:

                . Muitos dados relacionados ‚Üí tipo composto.

        FRASES-CHAVE PARA MEMORIZAR:

            Primitivo = um valor
            Composto = v√°rios valores
            Objeto = dado que sabe agir
            N√£o-objeto = dado puro

    =====================================================================

    Verifica√ß√£o de tipo (type, issinstance, issubclass):

        - Verificar tipo √© perguntar: ‚Äúque tipo de coisa √© isso?‚Äù

        Em Python, usamos isso para:

            Evitar erros

            Tomar decis√µes

            Garantir que um dado √© do tipo esperado

            Trabalhar com objetos e heran√ßa

        VIS√ÉO L√ìGICA (ANTES DO C√ìDIGO):

            Sempre pense assim:

                1. Isso √© um valor ou um objeto?

                2. Preciso saber exatamente o tipo ou apenas se pertence a um 
                grupo?

                3. Estou lidando com classe ou inst√¢ncia?

            Essas perguntas definem qual ferramenta usar.

        type() ‚Äî qual √© o tipo exato:

            - Retorna o tipo exato do valor ou objeto.

            Ideia-chave:

                . type compara identidade de tipo, n√£o parentesco.

            Exemplo:
                
                x = 10
                type(x)

            Leitura humana:

                ‚ÄúO tipo exato de x √© inteiro.‚Äù

            Compara√ß√£o direta:

                type(x) == int

            S√≥ ser√° True se for exatamente int.

            Quando usar type?

                . Testes simples
                . Depura√ß√£o
                . Verifica√ß√£o r√≠gida

                . N√£o √© ideal para POO e heran√ßa

        isinstance() ‚Äî pertence a esse tipo?

            - Verifica se um valor √© inst√¢ncia de um tipo ou de seus subtipos.

            Ideia-chave:

                . isinstance respeita heran√ßa.

            Exemplo:

                x = 10
                isinstance(x, int)

            Leitura humana:

                ‚Äúx √© um inteiro ou algo derivado de inteiro?‚Äù

            M√∫ltiplos tipos:

                isinstance(x, (int, float))

            Mental: ‚Äú√â n√∫mero?‚Äù

            Quando usar isinstance?

                . C√≥digo real
                . Fun√ß√µes gen√©ricas
                . Valida√ß√£o de entrada
                . POO

            √â o mais usado na pr√°tica.

        issubclass() ‚Äî classe filha de outra?

            - Verifica se uma classe herda de outra classe.

            PS: N√£o funciona com valores, s√≥ com classes.

            Exemplo:

                issubclass(bool, int)

            Leitura humana:

                ‚Äúbool √© uma subclasse de int?‚Äù

            Sim (True)

            Outro exemplo:

                issubclass(list, object)

            Sim ‚Äî tudo herda de object.

        COMPARA√á√ÉO FINAL (anote isso):

            | Fun√ß√£o       | Pergunta que responde       |
            | ------------ | --------------------------- |
            | `type`       | Qual √© o tipo exato?        |
            | `isinstance` | √â desse tipo ou derivado?   |
            | `issubclass` | Essa classe herda de outra? |

        ERROS COMUNS:

            . Usar type quando deveria usar isinstance
            . Usar issubclass com objetos
            . Comparar tipos sem entender heran√ßa
            . Verificar tipo quando n√£o precisa

            Regra pr√°tica:

                - Prefira isinstance em c√≥digo de verdade.

        FRASES-CHAVE PARA MEMORIZAR

            type √© r√≠gido
            isinstance √© flex√≠vel
            issubclass √© estrutural

    ===================================================================== 

    Entrada e sa√≠da de dados (Input / Output ‚Äî I/O):

        - Entrada de dados √© quando o programa recebe informa√ß√£o de fora.
        
        - Sa√≠da de dados √© quando o programa mostra informa√ß√£o para fora.

        . Entrada ‚Üí usu√°rio, arquivo, sistema

        . Sa√≠da ‚Üí tela, arquivo, sistema

        . Todo programa √∫til recebe algo e entrega algo

        ENTRADA DE DADOS (conceito):

            Em Python, a entrada padr√£o vem do teclado:

                input()

            Importante:

                input() sempre retorna TEXTO (string).

            Exemplo simples:

                nome = input("Digite seu nome: ")
                print(nome)

        SA√çDA DE DADOS (conceito):

            Sa√≠da padr√£o √© feita com:

                print()

            Serve para:

                Mostrar resultados

                Informar erros

                Exibir mensagens

            Exemplo com texto:

                print("Ol√°, mundo!")
        
        CONVERS√ÉO DE TIPO (obrigat√≥rio entender):

            Como input() retorna texto, precisamos converter:

                idade = int(input("Digite sua idade: "))

            Se n√£o converter ‚Üí erro em c√°lculo.

            Exemplo 1 ‚Äî N√∫mero:

                numero = int(input("Digite um n√∫mero: "))
                print(numero)

            Exemplo 2 ‚Äî Soma:

                a = int(input("Digite o primeiro n√∫mero: "))
                b = int(input("Digite o segundo n√∫mero: "))
                soma = a + b
                print(soma)

            Exemplo 3 ‚Äî Texto formatado:

                nome = input("Nome: ")
                idade = int(input("Idade: "))
                print(f"{nome} tem {idade} anos")

        ERROS COMUNS:

            . Esquecer convers√£o de tipo
            . Fazer c√°lculo com string
            . Entrada confusa para o usu√°rio
            . N√£o guardar o valor em vari√°vel

            Regra de ouro:

                . Entrada ‚Üí vari√°vel ‚Üí processamento ‚Üí sa√≠da

        FRASE-CHAVE PARA MEMORIZAR:

            - Programa sem entrada e sa√≠da n√£o conversa com o mundo.

        DICAS:

            . Leia a entrada com calma
            . Converta logo ap√≥s o input
            . Guarde tudo em vari√°veis
            . S√≥ depois fa√ßa contas
            . Mostre sa√≠da clara para o usu√°rio

    =====================================================================

    Interpola√ß√£o e concatena√ß√£o e formata√ß√£o:

        - Concatena√ß√£o junta textos manualmente.
        
        - Interpola√ß√£o insere valores dentro do texto automaticamente.
        
        - Formata√ß√£o controla como o texto e os n√∫meros aparecem.

        Objetivo principal:

            - mostrar informa√ß√µes de forma clara para humanos.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Pergunte sempre:

                Vou juntar textos?

                Vou mostrar valores dentro do texto?

                Preciso controlar casas decimais, alinhamento ou formato?

                O usu√°rio entenderia essa sa√≠da facilmente?

        CONCATENA√á√ÉO (forma antiga):

            . Juntar textos usando +

            EX:

                nome = "Renato"
                idade = "20"
                print("Nome: " + nome + " | Idade: " + idade)

            Observa√ß√£o importante:

                . S√≥ funciona bem com texto

                . Fica confuso com n√∫meros

                . Pouco usado hoje

            Problema comum:

                print("Idade: " + 20)  # erro

        INTERPOLA√á√ÉO (forma moderna ‚Äî RECOMENDADA):

            - Inserir valores dentro do texto automaticamente

            Em Python, usamos f-strings:

                print(f"Nome: {nome} | Idade: {idade}")

            Vantagens:

                Mais leg√≠vel

                Aceita qualquer tipo

                Mais profissional

                Menos erro

            Use isso sempre que poss√≠vel.

        FORMATA√á√ÉO DE VALORES:

            - Controlar como o valor aparece

            + Casas decimais:

                preco = 10.56789
                print(f"Pre√ßo: {preco:.2f}")

            Mostra apenas 2 casas decimais.

            + Texto alinhado:

                print(f"{nome:<10} {idade:>3}")

            . < esquerda

            . > direita

            . n√∫mero = largura

            + Formata√ß√£o monet√°ria (simples):

                total = 1234.5
                print(f"Total: R$ {total:.2f}")

        Ruim (concatena√ß√£o excessiva):

            print("Total: R$ " + str(total))

        Bom (interpola√ß√£o):

            print(f"Total: R$ {total:.2f}")

        ERROS COMUNS:

            . Usar concatena√ß√£o com n√∫meros
            . Converter tudo para string sem necessidade
            . Sa√≠da confusa para o usu√°rio
            . N√£o formatar valores financeiros

        Regra pr√°tica:

            - Se tem vari√°vel no texto ‚Üí use f-string.

        FRASES-CHAVE PARA MEMORIZAR:

            Concatena√ß√£o √© manual
            
            Interpola√ß√£o √© autom√°tica
            
            Formata√ß√£o √© controle visual

        DICAS:

            . Use f"" sempre
            . Formate n√∫meros financeiros
            . Sa√≠da clara vale mais que c√≥digo curto
            . Pense no usu√°rio lendo

        Outras sa√≠das:

            Sa√≠da com v√≠rgula no print:

                Voc√™ pode passar v√°rios valores no print separados por v√≠rgula:

                    nome = "Renato"
                    idade = 20
                    print("Nome:", nome, "| Idade:", idade)

            Por padr√£o o print coloca um espa√ßo entre os itens.
            Voc√™ pode controlar com sep e end:

                print("A", "B", "C", sep="-")   # A-B-C
                print("Oi", end="!")           # Oi!

            Formata√ß√£o com % (antiga, mas cai em exerc√≠cios):

                Sintaxe:

                    %s texto

                    %d inteiro

                    %.2f float com 2 casas

                EX:

                    nome = "Renato"
                    idade = 20
                    print("Nome: %s | Idade: %d" % (nome, idade))

                    preco = 10.567
                    print("Pre√ßo: R$ %.2f" % preco)

            Formata√ß√£o com .format():

                Por posi√ß√£o:

                    nome = "Renato"
                    idade = 20
                    print("Nome: {} | Idade: {}".format(nome, idade))

                Por nome:

                    print("Nome: {n} | Idade: {i}".format(n=nome, i=idade))

                Casas decimais:

                    total = 1234.5
                    print("Total: R$ {:.2f}".format(total))

    =====================================================================

    Operadores aritm√©ticos:

        - Operadores aritm√©ticos servem para fazer c√°lculos matem√°ticos no 
        programa.

        Eles permitem:

            Somar

            Subtrair

            Multiplicar

            Dividir

            Divis√£o inteira

            Resto da divis√£o

            Pot√™ncia

        Sem operadores, o programa n√£o calcula nada.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO)

            Pergunte sempre:

                Que c√°lculo o problema pede?
                
                √â conta de escola (soma, divis√£o, m√©dia, etc.)?
                
                O resultado precisa ser inteiro ou decimal?
                
                Preciso do resto ou s√≥ do resultado?

            A l√≥gica vem antes do s√≠mbolo.

        OPERADORES ARITM√âTICOS EM PYTHON:

            | Operador | Nome            | Exemplo  |
            | -------- | --------------- | -------- |
            | `+`      | Soma            | `a + b`  |
            | `-`      | Subtra√ß√£o       | `a - b`  |
            | `*`      | Multiplica√ß√£o   | `a * b`  |
            | `/`      | Divis√£o         | `a / b`  |
            | `//`     | Divis√£o inteira | `a // b` |
            | `%`      | Resto (m√≥dulo)  | `a % b`  |
            | `**`     | Pot√™ncia        | `a ** b` |
        
        Soma:

            a = 10
            b = 3
            print(a + b)   # 13

        Divis√£o (sempre gera decimal):

            print(10 / 3)  # 3.3333...

        Divis√£o inteira:

            print(10 // 3) # 3

        . Quantas vezes cabe, sem quebrar.

        Resto da divis√£o:

            print(10 % 3)  # 1
        
        . Muito usado para:

            Par ou √≠mpar

            Ciclos

            Quebras de grupo

        Pot√™ncia:

            print(2 ** 3)  # 8

            print(pow(2, 3))  # 8

        Subtra√ß√£o:

            a = 10
            b = 3
            print(a - b)   # 7

        Multiplica√ß√£o:

            a = 10
            b = 3
            print(a * b)   # 30

        Adicional: Raizes

            indice = 2
            radicando = 4

            raiz = radicando**(1/indice)

            print(raiz)  # 2.0

        abs() ‚Äî valor absoluto:

            - Retorna o valor sem sinal (dist√¢ncia at√© o zero).

            Ex:

                print(abs(10))    # 10
                print(abs(-10))   # 10

                # tp√©cnica em caso de negativos, fazer convers√£o expl√≠cita
                print(-(-10)) # 10

        round() ‚Äî arredondamento:

            - Arredonda um n√∫mero.

            Ex:

                print(round(3.6))      # 4
                print(round(3.14159, 2))  # 3.14

            Pode receber:

                - 1 argumento ‚Üí arredonda inteiro

                - 2 argumentos ‚Üí casas decimais

        min() e max() ‚Äî menor e maior:

            print(min(3, 7, 2))  # 2
            print(max(3, 7, 2))  # 7
            
            # Com iteraveis de tipo num√©rico:
            valores = [10, 3, 8]
            print(min(valores))
            print(max(valores))

        divmod() ‚Äî divis√£o + resto:

            - Retorna quociente e resto juntos.

            q, r = divmod(10, 3)
            print(q, r)  # 3 1

        int(), float() ‚Äî convers√£o num√©rica:

            - PS: int() corta, n√£o arredonda.

                print(int(3.9))    # 3
                print(float(10))   # 10.0

        PRECED√äNCIA (ordem das contas):

            - Python segue a matem√°tica.

            Ordem:

                1. ()

                2. **

                3. * / // %

                4. + -

            Exemplo:

                resultado = 10 + 2 * 3

            Resultado: 16, n√£o 36.

            Use par√™nteses para deixar claro:

                resultado = (10 + 2) * 3

             Resultado: 36.

        ERROS COMUNS

            . Esquecer convers√£o do input()
            . Usar / achando que retorna inteiro
            . Confundir % com porcentagem
            . N√£o usar par√™nteses quando precisa
            . Achar que abs arredonda
            . Confundir int() com round()
            . N√£o usar fun√ß√µes prontas
            . Repetir c√°lculo manual desnecess√°rio

            % n√£o √© porcentagem, √© resto da divis√£o.

            Se parece ‚Äúb√°sico demais‚Äù, provavelmente j√° existe fun√ß√£o pronta.

        DICAS:

            . Converta o input imediatamente
            . Pense na matem√°tica antes do operador
            . Use par√™nteses sem medo
            . Teste com n√∫meros simples (2, 3, 10)

    =====================================================================

    Operadores de atribui√ß√£o:

        - Operadores de atribui√ß√£o servem para colocar ou atualizar valores em 
        vari√°veis.

        Eles fazem duas coisas ao mesmo tempo:

            1. Executam uma opera√ß√£o

            2. Guardam o resultado na vari√°vel

        N√£o √© matem√°tica pura, √© estado do programa mudando.

        COMO PENSAR COMO L√ìGICO:

            Sempre leia assim:

                ‚ÄúPegue o valor atual da vari√°vel, fa√ßa algo, e guarde de volta.‚Äù

            Se voc√™ n√£o entende isso, vai errar la√ßo, contador e soma acumulada.

        ATRIBUI√á√ÉO SIMPLES:

            . =
                
                x = 10

            Mental: ‚ÄúColoque 10 dentro de x.‚Äù / ‚Äúx recebe 10‚Äù /
            ‚Äúx atribui 10‚Äù / ‚Äúx referencia 10‚Äù

        ATRIBUI√á√ÉO COM OPERA√á√ÉO:

            | Operador | Significado             |
            | -------- | ----------------------- |
            | `+=`     | soma e guarda           |
            | `-=`     | subtrai e guarda        |
            | `*=`     | multiplica e guarda     |
            | `/=`     | divide e guarda         |
            | `//=`    | divide inteiro e guarda |
            | `%=`     | resto e guarda          |
            | `**=`    | pot√™ncia e guarda       |

        . +=

            total = 0
            total += 5

        Mesmo que:

            total = total + 5

        . -=

            saldo = 100
            saldo -= 30

        Mesmo que:

            saldo = saldo - 30

        . *=

            preco = 10
            preco *= 2

        Mesmo que:

            preco = preco * 2

        . /=

            media = 10
            media /= 2

        Mesmo que:

            media = media / 2

        . %= (muito usado em ciclos)

            x = 10
            x %= 3   # sobra 1

        Mesmo que:

            x = x % 3

        . **=

            n = 2
            n **= 3

        Mesmo que:

            n = n ** 3

        LEITURA HUMANA:

            Leia como:

                ‚Äúx recebe x mais 1‚Äù

            Nunca como:

                ‚Äúx mais igual 1‚Äù

        ERROS COMUNS

            . Usar sem entender o valor anterior
            . Confundir = com ==
            . Achar que cria vari√°vel nova
            . Usar antes de inicializar

            Regra de ouro:

                Nunca use += sem inicializar a vari√°vel antes.

        FRASE-CHAVE PARA MEMORIZAR

            - Operador de atribui√ß√£o muda o estado da vari√°vel.

        DICAS:

            . Inicialize sempre
            . Leia o operador como frase
            . Use muito em contadores
            . Use em la√ßos (em breve!)

    =====================================================================

    Operadores l√≥gicos:

        - Operadores l√≥gicos combinam condi√ß√µes e produzem verdadeiro ou falso.

        Eles trabalham com valores l√≥gicos:

            True (verdadeiro)

            False (falso)

        S√£o usados para:

            Decidir caminhos (if)

            Validar dados

            Criar regras compostas

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre pergunte:

                1. Quantas condi√ß√µes existem?

                2. Todas precisam ser verdadeiras ou s√≥ uma?

                3. Existe nega√ß√£o de alguma condi√ß√£o?

            Traduza a frase humana para l√≥gica.

        and ‚Äî E:

            - S√≥ √© True se todas forem verdadeiras.

            EX:

                idade = 20
                tem_documento = True

                print(idade >= 18 and tem_documento)

            Tabela verdade (and):

                |    A    |   B    | A and B |
                | ------- | ------ | ------- |
                | True    | True   | True    |
                | True    | False  | False   |
                | False   | True   | False   |
                | False   | False  | False   |

        or ‚Äî OU

            √â True se pelo menos uma condi√ß√£o for verdadeira.

            EX:

                dia = "s√°bado"
                print(dia == "s√°bado" or dia == "domingo")

            Leitura humana:

                ‚Äú√â s√°bado ou domingo?‚Äù

            Tabela verdade (or):

                |    A    |   B    | A or B |
                | ------- | ------ | ------ |
                | True    | True   | True   |
                | True    | False  | True   |
                | False   | True   | True   |
                | False   | False  | False  |

        not ‚Äî N√ÉO

            - Inverte o valor l√≥gico.

            Exemplo:

                chovendo = False
                print(not chovendo)

            Leitura humana:

                ‚ÄúN√£o est√° chovendo.‚Äù

            Tabela Verdade:

                |   A   |   not A   |
                | ----- | --------- |
                | True  |   False   |
                | False |   True    |

        COMBINA√á√ïES (muito comum):

            Ex1:

                idade = 17
                estudante = True

                print(idade < 18 and estudante)

            Ex2:

                senha_correta = False
                print(not senha_correta)

        PRECED√äNCIA L√ìGICA (importante):

            Ordem:

                1. not

                2. and

                3. or
            
            Use par√™nteses para clareza:

                (idade >= 18 and tem_documento) or autorizado

        ERROS COMUNS

            . Esquecer par√™nteses
            . Confundir and com or
            . Escrever frases mal traduzidas
            . Usar l√≥gica sem pensar na frase humana

            Regra de ouro:

                Se n√£o d√° pra ler em portugu√™s, a l√≥gica est√° errada.

        FRASES-CHAVE PARA MEMORIZAR

            and exige tudo
            or aceita um
            not inverte

        DICAS:

            . Traduza para frase humana
            . Use par√™nteses sem medo
            . Teste com valores verdadeiros e falsos
            . N√£o complique a l√≥gica cedo demais

        CONCEITO AVAN√áADO (MUITO IMPORTANTE):

            - and e or retornam operandos, n√£o booleanos

            - Eles usam short-circuit evaluation (avalia√ß√£o curta)

            Isso permite padr√µes como:

                valor = entrada or valor_padrao

            ou

                condicao and funcao()

        Opera√ß√£o de Curto Circuito:

            - Curto-circuito √© quando o Python para de avaliar uma express√£o
            l√≥gica assim que o resultado j√° est√° decidido.

            Ele acontece com:

                and
                or

            REGRAS SIMPLES:

                and

                    Para no primeiro falsy

                        0 and 5

                    . 0 j√° √© falsy

                    . Python nem olha o 5

                or

                    Para no primeiro truthy

                        0 or 5

                    . 0 √© falsy

                    . Vai para 5

                    . 5 √© truthy ‚Üí para aqui

                not

                    N√£o tem curto-circuito, s√≥ inverte o valor.

                        not 0   # True

            POR QUE ISSO √â IMPORTANTE?

                Evita erros

                        lista = []
                        lista and lista[0]

                    n√£o d√° erro, porque lista √© falsy

                Mais performance:

                    . Menos opera√ß√µes

                    . Menos avalia√ß√µes

            FRASE PARA MEMORIZAR:

                and para no falso
                or para no verdadeiro

    =====================================================================

    Operadores relacionais:

        - Operadores relacionais comparam valores e geram um resultado l√≥gico:
            
            True ou False.

        Eles respondem perguntas como:

            √â maior?

            √â menor?

            √â igual?

            √â diferente?

            Sem operadores relacionais, n√£o existe decis√£o no programa.

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre leia como pergunta humana:

                . ‚ÄúEsse valor √© maior que aquele?‚Äù

                . ‚ÄúS√£o iguais?‚Äù

                . ‚Äú√â diferente?‚Äù

            O resultado nunca √© n√∫mero, √© verdadeiro ou falso.

        OPERADORES RELACIONAIS EM PYTHON:

            | Operador | Significado    |
            | -------- | -------------- |
            |  >       | maior que      |
            |  <       | menor que      |
            |  >=      | maior ou igual |
            |  <=      | menor ou igual |
            |  ==      | igual          |
            |  !=      | diferente      |

        EXEMPLOS EXPLICADOS:

            . Maior / Menor

                print(10 > 5)    # True
                print(3 < 1)     # False

            . Maior ou igual / Menor ou igual

                print(18 >= 18)  # True
                print(5 <= 3)    # False

            . Igualdade (==)

                print(10 == 10)  # True
                print(10 == 5)   # False

            . Diferente (!=)

                print(10 != 5)   # True
                print(10 != 10)  # False

        Aten√ß√£o:

            x = 10   # atribui√ß√£o
            x == 10  # compara√ß√£o


        Rela√ß√µes com texto:

            - Strings tamb√©m podem ser comparadas com operadores relacionais.


            COMPARANDO TEXTO:

                nome = "Renato"
                print(nome == "Renato")   # True
                print(nome != "Ana")      # True

            Compara√ß√£o de texto √© exata (mai√∫scula ‚â† min√∫scula).

            Python compara strings:

                . caractere por caractere

                . seguindo a ordem alfab√©tica (tabela Unicode / ASCII)

                PS: N√£o √© ‚Äútamanho‚Äù, √© ordem lexical.

            COMO O PYTHON COMPARA STRINGS:

                A compara√ß√£o acontece:

                    1 - Do primeiro caractere

                    2 - Depois o segundo

                    3 - At√© encontrar diferen√ßa

                Exemplo mental:

                    "casa" vs "carro"
                    c  == c
                    a  == a
                    s  >  r   ‚Üí decis√£o aqui

            EXEMPLOS IMPORTANTES:

                . Ordem alfab√©tica

                    print("ana" < "bia")   # True
                    print("casa" > "carro")  # True

                . Mai√∫scula x min√∫scula (pegadinha!)

                    print("ana" < "Ana")  # False

                PS: Letras mai√∫sculas v√™m antes das min√∫sculas.

                . Comparando palavras:

                    palavra = "banana"
                    print(palavra >= "abacate")

            COMPARA√á√ÉO COM len():

                √Äs vezes o que voc√™ quer n√£o √© ordem, √© tamanho:

                    print(len("casa") > len("sol"))

                Comparar tamanho ‚â† comparar string diretamente.

        COMPARA√á√ïES COMBINADAS:

            idade = 20
            print(idade >= 18 and idade <= 65)

        Mental: ‚ÄúEst√° entre 18 e 65?‚Äù

        ERROS COMUNS

            . Usar = no lugar de ==
            . Comparar tipos diferentes sem querer
            . Esquecer que o resultado √© True/False
            . Fazer compara√ß√£o sem sentido l√≥gico

            . Achar que "z" > "ab" por tamanho
            . Ignorar mai√∫sculas e min√∫sculas
            . Comparar string quando queria comparar tamanho
            . N√£o normalizar entrada do usu√°rio

            Regra de ouro:

                Operador relacional sempre responde uma pergunta.

                Python compara texto como dicion√°rio, n√£o como humano.

        FRASES-CHAVE PARA MEMORIZAR

            . Relacional compara
            . L√≥gico combina
            . Aritm√©tico calcula
            . Atribui√ß√£o guarda

            . String √© comparada por ordem, n√£o por tamanho.
            . Mai√∫scula vem antes de min√∫scula.
            . Normalize antes de comparar.

        DICAS:

            . Leia cada compara√ß√£o em voz alta
            . Teste com valores simples
            . Use par√™nteses para clareza
            . Combine com operadores l√≥gicos

            . Normalize strings
            . Leia compara√ß√£o como dicion√°rio
            . Use len() quando quiser tamanho
            . Teste com mai√∫sculas e min√∫sculas

    =====================================================================

    in e is:

        - in pergunta se algo est√° dentro de outra coisa.
        
        - is pergunta se duas vari√°veis apontam para o MESMO objeto.

        Eles n√£o fazem a mesma coisa e n√£o s√£o intercambi√°veis.

        COMO PENSAR COMO L√ìGICO:

            Antes de escolher:

                Quero saber se pertence? ‚Üí in

                Quero saber se √© o mesmo objeto na mem√≥ria? ‚Üí is

            Valor igual ‚â† objeto igual.

        in ‚Äî pertin√™ncia:

            - Verifica se um elemento est√° contido em uma sequ√™ncia ou cole√ß√£o.

            Funciona com:

                str

                list

                tuple

                set

                dict (verifica chaves)
            
            . Exemplos com string:

                print("a" in "casa")     # True
                print("z" in "casa")     # False

            . Exemplos com lista

                numeros = [1, 2, 3]
                print(2 in numeros)      # True
                print(5 in numeros)      # False

            . Exemplo com dicion√°rio

                dados = {"nome": "Renato", "idade": 20}
                print("nome" in dados)   # True
                print("Renato" in dados) # False

            Em dicion√°rios, in verifica chaves, n√£o valores.

        is ‚Äî identidade

            - Verifica se duas vari√°veis apontam para o mesmo objeto na mem√≥ria.

            Exemplo simples:

                a = None
                print(a is None)   # True

            Uso correto cl√°ssico de is.

            Exemplo com n√∫meros (pegadinha)

                a = 256
                b = 256
                print(a is b)   # True (por otimiza√ß√£o interna)

                a = 1000
                b = 1000
                print(a is b)   # Pode ser False

            N√£o confie em is para comparar valores.

            Exemplo com listas:

                a = [1, 2, 3]
                b = [1, 2, 3]

                print(a == b)   # True (valores iguais)
                print(a is b)   # False (objetos diferentes)

        COMPARA√á√ÉO FINAL

            | Operador | Pergunta           |
            | -------- | ------------------ |
            | `in`     | Est√° dentro?       |
            | `is`     | √â o mesmo objeto?  |
            | `==`     | Tem o mesmo valor? |

        ERROS COMUNS

            . Usar is no lugar de ==
            . Comparar string com is
            . Usar in achando que compara igualdade
            . N√£o entender dicion√°rio com in

            Regra de ouro:

                Para valores ‚Üí ==
                Para identidade ‚Üí is

        FRASES-CHAVE PARA MEMORIZAR:

            in √© pertin√™ncia
            
            is √© identidade

            Igual n√£o √© o mesmo

        DICAS:

            . Leia o operador como pergunta
            . Nunca use is para comparar valor
            . Use is None sempre
            . Teste com listas para entender mem√≥ria

    =====================================================================

    Incremento / Decremento:

        - Incrementar √© aumentar um valor passo a passo.

        - Decrementar √© diminuir um valor passo a passo.

        Em Python n√£o existe ++ ou --.

            Tudo √© feito com operadores de atribui√ß√£o.

        COMO PENSAR COMO L√ìGICO:

            Leia sempre assim:

                ‚ÄúPegue o valor atual, altere um pouco, e guarde de volta.‚Äù

            Isso √© mudan√ßa de estado.

        FORMAS DE INCREMENTAR:

            . Forma cl√°ssica

                x = x + 1

            . Forma recomendada

                x += 1
            
            Ambas fazem a mesma coisa.

            . Incrementar por outro valor

                x += 5

        FORMAS DE DECREMENTAR:

            . Forma cl√°ssica

                x = x - 1

            . Forma recomendada

                x -= 1

            . Decrementar por outro valor

                x -= 3
        
        EXEMPLOS PR√ÅTICOS:

            . Contador

                contador = 0
                contador += 1
                contador += 1
                print(contador)  # 2

            . Contagem regressiva

                x = 5
                x -= 1
                x -= 1
                print(x)  # 3

            . Acumulador

                soma = 0
                soma += 10
                soma += 5
                print(soma)  # 15

        ERROS COMUNS

            . Tentar usar x++ ou x-- (isso n√£o existe em Python)
            . Usar incremento sem inicializar
            . Confundir incremento com atribui√ß√£o simples

            Regra de ouro:

                Sempre inicialize antes de incrementar.

        FRASES-CHAVE PARA MEMORIZAR

            
            Incrementar soma
            
            Decrementar subtrai
            
            Python n√£o tem ++

        DICAS:

            . Inicialize sempre
            . Leia o c√≥digo em voz alta
            . Use para contar, somar, iterar
            . Pense em estado, n√£o em f√≥rmula

    =====================================================================

    Preced√™ncia dos operadores e uso de um ou mais operadores:

        - Preced√™ncia define a ordem em que os operadores s√£o avaliados.

        Se voc√™ n√£o controlar a ordem, o Python controla por voc√™ ‚Äî e isso
        nem sempre √© o que voc√™ quer.

        Par√™nteses sempre vencem.

        COMO PENSAR COMO L√ìGICO:

            Pergunte sempre:

                Qual parte deve ser calculada primeiro?

                Essa conta √© clara para um humano?

                Preciso for√ßar a ordem com par√™nteses?
            
            C√≥digo claro > c√≥digo curto.

        ORDEM DE PRECED√äNCIA:

            Aritm√©ticos:

                1. ()
                2. **
                3. * / // %
                4. + -

            Relacionais:

                5. > < >= <=
                6. == !=

            L√≥gicos

                7. not
                8. and
                9. or

            Atribui√ß√£o

                10. = += -= *= /= ...

            Atribui√ß√£o sempre por √∫ltimo.
        
        Exemplo 1 ‚Äî Aritm√©tica simples:

            resultado = 10 + 2 * 3
            print(resultado)   # 16

        PS: Multiplica√ß√£o vem antes da soma.

        Exemplo 2 ‚Äî For√ßando ordem

            resultado = (10 + 2) * 3
            print(resultado)   # 36

        Exemplo 3 ‚Äî Relacional + aritm√©tico

            print(10 + 2 > 11)   # True

        PS: Soma primeiro, depois compara√ß√£o.

        Exemplo 4 ‚Äî L√≥gico + relacional

            idade = 17
            print(idade >= 18 or idade >= 16 and idade < 18)

        Avalia√ß√£o real:

            >= e <
            and
            or

        Exemplo 5 ‚Äî Com par√™nteses (melhor)

            print(idade >= 18 or (idade >= 16 and idade < 18))

        PS: Mesmo resultado, mais leg√≠vel.

        USO DE M√öLTIPLOS OPERADORES:

            Ruim

                if a > b and c < d or e == f:

            Bom:

                if (a > b and c < d) or e == f:

        ERROS COMUNS

            . Confiar s√≥ na preced√™ncia
            . Esquecer par√™nteses
            . C√≥digo imposs√≠vel de ler
            . Misturar tudo na mesma linha

            Regra de ouro:

                Se precisa pensar demais para entender, use par√™nteses.

        FRASES-CHAVE PARA MEMORIZAR:

            Par√™nteses mandam
            Pot√™ncia vem cedo
            and vence or
            Atribui√ß√£o √© a √∫ltima

        DICAS:

            . Sempre pense na ordem
            . Use par√™nteses por clareza
            . Misture operadores conscientemente
            . Leia a express√£o em voz alta

        Tabela completa de preced√™ncia (maior ‚Üí menor):

            | Prioridade | Operadores / forma                                                                | Observa√ß√µes r√°pidas                                |                                                                       |
            | ---------: | --------------------------------------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------- |
            |          1 | **Agrupamento / acesso**: `(...)`, `x[...]`, `x(...)`, `x.attr`                   | Par√™nteses, indexa√ß√£o, chamada de fun√ß√£o, atributo |                                                                       |
            |          2 | **Await**: `await x`                                                              | Em async                                           |                                                                       |
            |          3 | **Pot√™ncia**: `**`                                                                | **Associativa √† direita**: `2**3**2 = 2**(3**2)`   |                                                                       |
            |          4 | **Un√°rios**: `+x`, `-x`, `~x`                                                     | Ex.: `-n`, `+n`, bitwise NOT `~`                   |                                                                       |
            |          5 | **Multiplicativos**: `*`, `@`, `/`, `//`, `%`                                     | `@` √© multiplica√ß√£o matricial                      |                                                                       |
            |          6 | **Aditivos**: `+`, `-`                                                            | Soma/subtra√ß√£o                                     |                                                                       |
            |          7 | **Shifts**: `<<`, `>>`                                                            | Deslocamento de bits                               |                                                                       |
            |          8 | **Bitwise AND**: `&`                                                              |                                                    |                                                                       |
            |          9 | **Bitwise XOR**: `^`                                                              |                                                    |                                                                       |
            |         10 | **Bitwise OR**: `                                                                 | `                                                  |                                                                       |
            |         11 | **Compara√ß√µes**: `<`, `<=`, `>`, `>=`, `!=`, `==`, `in`, `not in`, `is`, `is not` | Compara√ß√µes podem ‚Äúencadear‚Äù: `a < b < c`          |                                                                       |
            |         12 | **NOT l√≥gico**: `not x`                                                           | `not` vem antes de `and/or`                        |                                                                       |
            |         13 | **AND l√≥gico**: `and`                                                             |                                                    |                                                                       |
            |         14 | **OR l√≥gico**: `or`                                                               |                                                    |                                                                       |
            |         15 | **Condicional (tern√°rio)**: `x if cond else y`                                    | Avalia `cond` e escolhe `x` ou `y`                 |                                                                       |
            |         16 | **Lambda**: `lambda`                                                              | √â o mais fraco entre ‚Äúexpress√µes normais‚Äù          |                                                                       |
            |         17 | **Walrus**: `:=`                                                                  | Atribui√ß√£o como express√£o (bem baixa)              |                                                                       |
            |         18 | **Atribui√ß√µes**: `=`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`, `&=`, `^=`, `   | =`, `<<=`, `>>=`, `@=`                             | **N√£o √© express√£o** comum (√© statement); fica ‚Äúpor √∫ltimo‚Äù na pr√°tica |

        Detalhes important√≠ssimos:

            ** (pot√™ncia) √© mais forte que un√°rio, e √© √† direita:

                -2**2 vira -(2**2) = -4

                (-2)**2 = 4

            Compara√ß√µes t√™m uma faixa √∫nica: tudo de < at√© is e in tem a mesma
            prioridade, e pode encadear:

                1 < x < 10 (equivale a 1 < x and x < 10, mas sem avaliar x duas 
                            vezes)
            
            L√≥gicos: not > and > or.

    =====================================================================

    Swap:

        - Swap √© a troca de valores entre duas vari√°veis.

        Ap√≥s um swap:

            . o valor de a vai para b

            . o valor de b vai para a

        As vari√°veis continuam as mesmas ‚Äî s√≥ os valores mudam.

        COMO PENSAR COMO L√ìGICO (ESSENCIAL):

            Antes do c√≥digo, pense assim:

                Tenho dois valores

                Quero trocar os valores

                N√£o posso perder nenhum no processo

            O problema central do swap √© n√£o sobrescrever um valor antes de 
            salv√°-lo.

        O ERRO CL√ÅSSICO (N√ÉO FUNCIONA):

                a = 5
                b = 10

                a = b
                b = a

            O que acontece de verdade:

                . a vira 10

                . b recebe a (que j√° √© 10)

                . o 5 se perde

            Esse erro mostra por que o swap existe.

        SWAP COM VARI√ÅVEL AUXILIAR (FORMA UNIVERSAL):

            - Funciona em qualquer linguagem.

                a = 5
                b = 10
                
                temp = a
                a = b
                b = temp
            
            Leitura humana:

                1. Guarde a em temp

                2. Coloque b em a

                3. Coloque temp em b

            . Seguro
            . Did√°tico
            . √ìtimo para aprender l√≥gica

        SWAP EM PYTHON (FORMA IDIOM√ÅTICA):

            - Python permite swap sem vari√°vel auxiliar, usando desempacotamento.

                a = 5
                b = 10

                a, b = b, a

            O que acontece internamente:

                . Python cria uma tupla tempor√°ria

                . Depois distribui os valores

            N√£o √© m√°gica, √© recurso da linguagem.

        SWAP COM EXPRESS√ïES (IMPORTANTE):

                x = 3
                y = x + 2

                x, y = y, x

            Primeiro o Python avalia tudo do lado direito, depois faz as 
            atribui√ß√µes.

            Isso evita conflito de valores.

        SWAP ‚â† COMPARA√á√ÉO:

            Errado:

                a == b

            Correto:

                a, b = b, a

            == compara, n√£o troca.

        SWAP E MEM√ìRIA (IDEIA IMPORTANTE):

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            . As refer√™ncias s√£o trocadas
            . As listas n√£o s√£o copiadas

        ERROS COMUNS

            . Fazer a = b; b = a
            . Confundir swap com compara√ß√£o
            . Achar que Python copia valores
            . N√£o entender avalia√ß√£o do lado direito

            Regra de ouro:

                Nunca sobrescreva um valor antes de salv√°-lo.

        FRASES-CHAVE PARA MEMORIZAR

            Swap troca valores, n√£o vari√°veis
            Swap exige preservar informa√ß√£o
            Python avalia antes de atribuir

        DICAS:

            . Pense em preservar valores
            . Lado direito √© avaliado primeiro
            . Use swap Python quando poss√≠vel
            . Use vari√°vel auxiliar para entender l√≥gica

        SWAP COM ITER√ÅVEIS:

            - Swap em iter√°veis √© a troca de elementos dentro de uma estrutura.

            . Iter√°vel = algo que tem v√°rios valores (lista, string, tupla, etc.)

            . Swap = trocar posi√ß√µes ou refer√™ncias

            . Base de ordenacÃßaÃÉo, invers√£o, reorganiza√ß√£o

            Quase todo algoritmo cl√°ssico usa swap em iter√°veis.

            COMO PENSAR COMO L√ìGICO:

                Antes de fazer swap em iter√°vel, pergunte:

                    Vou trocar valores ou posi√ß√µes?

                    O iter√°vel √© mut√°vel ou imut√°vel?

                    A troca √© local (√≠ndices) ou global (estrutura inteira)?

                Isso define a t√©cnica.

            1) SWAP DE ELEMENTOS EM LISTAS (FORMA B√ÅSICA)

                - Listas s√£o mut√°veis, ent√£o podemos trocar posi√ß√µes.

                    lista = [10, 20, 30]
                    lista[0], lista[2] = lista[2], lista[0]

                Resultado:

                    [30, 20, 10]

                Troca de elementos, n√£o da lista inteira.

            2) SWAP COM VARI√ÅVEL AUXILIAR (DID√ÅTICO)

                    lista = [1, 2, 3]

                    temp = lista[0]
                    lista[0] = lista[1]
                    lista[1] = temp

            3) SWAP EM ITER√ÅVEIS IMUT√ÅVEIS (STRING / TUPLA)

                - Strings e tuplas n√£o podem ser alteradas diretamente.

                Errado:

                    s = "abc"
                    s[0], s[2] = s[2], s[0]

                Correto (converter):

                    s = "abc"
                    lista = list(s)
                    lista[0], lista[2] = lista[2], lista[0]
                    s = "".join(lista)

                Imut√°vel ‚Üí cria novo objeto.

            4) SWAP DE FATIAS (SLICES)

                Inverter partes

                    lista = [1, 2, 3, 4, 5]
                    lista[:2], lista[2:] = lista[2:], lista[:2]

                Resultado:

                    [3, 4, 5, 1, 2]

                Muito usado em rota√ß√µes.

            5) SWAP PARA INVERS√ÉO DE LISTA (ALGOR√çTMICO)

                . Manual (com dois √≠ndices)

                    lista = [1, 2, 3, 4]
                    i = 0
                    j = len(lista) - 1

                    while i < j:
                        lista[i], lista[j] = lista[j], lista[i]
                        i += 1
                        j -= 1

            Aqui o swap √© o motor da invers√£o.

            6) SWAP EM ALGORITMOS DE ORDENA√á√ÉO

                . Bubble sort (exemplo cl√°ssico)

                    for i in range(len(lista)):
                        for j in range(len(lista) - 1):
                            if lista[j] > lista[j + 1]:
                                lista[j], lista[j + 1] = lista[j + 1], lista[j]

                Sem swap, n√£o existe ordena√ß√£o.

            7) SWAP DE REFER√äNCIAS (LISTAS INTEIRAS)

                a = [1, 2]
                b = [3, 4]

                a, b = b, a

            Aqui n√£o troca elementos ‚Äî troca quem aponta para quem.

            ERROS COMUNS

                . Tentar trocar string direto
                . Confundir troca de elemento com troca de refer√™ncia
                . Errar √≠ndice
                . Sobrescrever valor antes do swap

                Regra de ouro:

                    Swap em iter√°veis sempre depende de √≠ndice ou refer√™ncia.

            FRASES-CHAVE PARA MEMORIZAR:

                Lista troca elemento
                String cria outra
                Swap move posi√ß√£o
                Algoritmo vive de swap

            DICAS:

                . Identifique mutabilidade
                . Use √≠ndices conscientemente
                . Swap √© ferramenta, n√£o fim
                . Algoritmo = repeti√ß√£o + compara√ß√£o + swap

    =====================================================================

    Casting:

        - Casting √© a convers√£o expl√≠cita de um tipo de dado para outro.

        Em Python, usamos fun√ß√µes para isso:

            . int()

            . float()

            . str()

            . bool()

            . list(), tuple(), set()

        Casting n√£o muda o valor em si, muda como o Python interpreta esse valor.

        COMO PENSAR COMO L√ìGICO:

            Sempre se pergunte:

                Que tipo esse dado tem agora?

                Que tipo eu preciso para operar?

                A convers√£o √© segura ou pode gerar erro?

            Erros de casting s√£o erros de l√≥gica, n√£o de sintaxe.

        CASTING NUM√âRICO:

            . int()

                - Converte para inteiro (corta decimais).

                    print(int(3.9))     # 3
                    print(int("10"))    # 10

                Erro:

                    int("abc")

            . float()

                Converte para decimal.

                    print(float(10))       # 10.0
                    print(float("3.14"))   # 3.14

            . str()

                Converte para texto.

                    idade = 20
                    print("Idade: " + str(idade))

                Muito usado em sa√≠da de dados.

        CASTING L√ìGICO (bool()):

            - Converte valores para True ou False.

            . Regras importantes

                bool(0)        # False
                bool(1)        # True
                bool(-5)       # True
                bool("")       # False
                bool("abc")    # True
                bool([])       # False
                bool([1, 2])   # True

            Falsy:

                0
                0.0
                ""
                []
                {}
                None

            Todo o resto √© Truthy.

        CASTING COM ITER√ÅVEIS:

            . String ‚Üí lista

                list("abc")   # ['a', 'b', 'c']

            . Lista ‚Üí tupla

                tuple([1, 2, 3])

            . Lista ‚Üí conjunto

                set([1, 1, 2, 3])   # {1, 2, 3}

            Conjunto remove duplicados.

        CASTING AUTOM√ÅTICO (IMPL√çCITO):

            Python faz isso em alguns casos:

                print(10 + 2.5)   # 12.5

            O inteiro vira float automaticamente.

            Mas n√£o confie demais nisso.

        ERROS COMUNS:

            . Esquecer que input() retorna str
            . Converter string inv√°lida para n√∫mero
            . Achar que int() arredonda
            . Usar casting sem entender o dado

            Regra de ouro:

                Sempre valide antes de converter.

        FRASES-CHAVE PARA MEMORIZAR:

            Casting muda o tipo, n√£o o dado
            int() corta
            bool() segue truthy/falsy
            input() sempre retorna string

        DICAS:

            . Converta logo ap√≥s a entrada
            . Teste casos inv√°lidos
            . Use try/except quando avan√ßar
            . Entenda truthy/falsy profundamente

    =====================================================================

    Coer√ß√£o:

        - Coer√ß√£o √© quando o Python converte automaticamente um tipo em outro 
        durante uma opera√ß√£o.

        . N√£o √© voc√™ que manda converter

        . √â o Python tentando n√£o quebrar o programa

        . Acontece principalmente em opera√ß√µes mistas

        Coer√ß√£o ‚â† Casting

            Casting ‚Üí voc√™ manda

            Coer√ß√£o ‚Üí Python decide

        COMO PENSAR COMO L√ìGICO:

            Pergunte sempre:

                Estou misturando tipos diferentes?

                Existe um tipo ‚Äúmais abrangente‚Äù?

                O Python precisa escolher um tipo comum?

            O Python nunca perde informa√ß√£o na coer√ß√£o (sempre sobe o tipo).

        REGRA FUNDAMENTAL DA COER√á√ÉO:

            - O Python promove o tipo mais simples para o mais geral.

            Exemplo cl√°ssico:

                int  ‚Üí  float  ‚Üí  complex

            Nunca o contr√°rio.

        COER√á√ÉO NUM√âRICA:

            . int + float ‚Üí float

                    print(10 + 2.5)      # 12.5
                    print(type(10 + 2.5))  # float

                O 10 vira 10.0 automaticamente.

            . float + complex ‚Üí complex

                print(2.5 + 1j)

        COER√á√ÉO EM OPERA√á√ïES L√ìGICAS:

            . Booleano como n√∫mero

                    print(True + 1)    # 2
                    print(False * 10)  # 0
            
                Porque:

                    True ‚Üí 1
                    False ‚Üí 0

                Isso √© coer√ß√£o impl√≠cita.

        COER√á√ÉO EM EXPRESS√ïES CONDICIONAIS:

                if 10:
                    print("Executa")

            O 10 vira True automaticamente.

                if "":
                    print("N√£o executa")

            String vazia ‚Üí False.

            Aqui entra truthy e falsy (coer√ß√£o para bool).

        COER√á√ÉO QUE N√ÉO EXISTE (IMPORTANTE):

            Python n√£o faz coer√ß√£o perigosa.

            N√£o existe:

                "10" + 5

            N√£o existe:

                "3" * 2.5

            Aqui o Python exige casting expl√≠cito.

        COER√á√ÉO EM OPERADORES L√ìGICOS (and, or):

            Pegadinha importante:

                    print(0 or 10)    # 10
                    print(10 and 5)   # 5

                and e or:

                    . n√£o retornam True/False

                    . retornam um dos operandos

                Eles usam coer√ß√£o para decidir, mas retornam valores reais.

        COER√á√ÉO EM COMPARA√á√ïES:

                print(1 == True)   # True
                print(0 == False)  # True

            Booleano √© subclasse de int.

            Compara√ß√£o funciona, mas n√£o √© boa pr√°tica.

        COER√á√ÉO √ó CASTING (tabela mental)

            | Conceito | Quem decide | Exemplo     |
            | -------- | ----------- | ----------- |
            | Casting  | Voc√™        | `int("10")` |
            | Coer√ß√£o  | Python      | `10 + 2.5`  |

        ERROS COMUNS

            . Confiar demais na coer√ß√£o
            . Misturar tipos sem perceber
            . Achar que Python converte string para n√∫mero
            . Usar coer√ß√£o como ‚Äúatalho l√≥gico‚Äù

            Regra de ouro:

                Coer√ß√£o ajuda, mas n√£o substitui casting consciente.

        FRASES-CHAVE PARA MEMORIZAR:

            Coer√ß√£o √© autom√°tica
            Python sobe o tipo
            Nunca perde informa√ß√£o
            String n√£o vira n√∫mero sozinha

        DICAS:

            . N√£o confie em coer√ß√£o silenciosa
            . Prefira casting expl√≠cito
            . Teste tipos com type()
            . C√≥digo claro > c√≥digo esperto

    =====================================================================

    Caracteres de controle:

        - Caracteres de controle s√£o sequ√™ncias especiais que come√ßam com \ e 
        alteram a forma como o texto √© interpretado ou exibido.

        Eles servem para:

            . Quebra de linha

            . Tabula√ß√£o

            . Aspas dentro de texto

            . Sons, cursores e efeitos

            . Unicode e caracteres especiais

        N√£o aparecem ‚Äúvisualmente‚Äù, mas controlam o comportamento do texto.

        COMO PENSAR COMO L√ìGICO:

            Sempre pense assim:

                Texto normal ‚Üí aparece

                Caractere de controle ‚Üí controla o texto

            Eles n√£o s√£o letras, s√£o comandos embutidos.

        TABELA COMPLETA ‚Äî CARACTERES DE CONTROLE EM PYTHON:

            | Sequ√™ncia | Nome            | O que faz                    |
            | --------- | --------------- | ---------------------------- |
            | `\n`      | New line        | Quebra de linha              |
            | `\t`      | Tab             | Tabula√ß√£o horizontal         |
            | `\\`      | Backslash       | Mostra `\`                   |
            | `\'`      | Aspa simples    | Mostra `'`                   |
            | `\"`      | Aspa dupla      | Mostra `"`                   |
            | `\r`      | Carriage return | Retorna ao in√≠cio da linha   |
            | `\b`      | Backspace       | Apaga um caractere anterior  |
            | `\f`      | Form feed       | Avan√ßa p√°gina (legado)       |
            | `\v`      | Vertical tab    | Tabula√ß√£o vertical           |
            | `\a`      | Bell            | Alerta sonoro (se suportado) |
            | `\0`      | Null            | Caractere nulo               |

        CARACTERES NUM√âRICOS (ASCII / OCTAL / HEX):

            . Octal

                "\101"   # 'A'

            . Hexadecimal

                "\x41"   # 'A'
            
            Pouco usados hoje, mas existem.

        UNICODE (ESSENCIAL EM PYTHON):

            . Unicode de 16 bits

                "\u2764"   # ‚ù§

            . Unicode completo (32 bits)

                "\U0001F600"   # üòÄ

            Python √© totalmente Unicode.

        STRING RAW (IMPORTANTE):

            - String raw ignora caracteres de controle.

                print(r"C:\Users\Renato\Docs")

            Sem r, isso quebraria (\U, \D, etc.).

        EXEMPLOS PR√ÅTICOS:

            Quebra de linha:

                print("Linha 1\nLinha 2")

            Tabula√ß√£o:

                print("Nome\tIdade\tCidade")

            Aspas dentro de texto:

                print("Ele disse: \"Ol√°\"")

            \r sobrescrevendo linha

                print("Carregando...\rFeito!")

            Unicode

                print("Cora√ß√£o: \u2764")

        ERROS COMUNS

            . Esquecer que \n quebra linha
            . Caminhos do Windows sem string raw
            . Usar \ achando que √© caractere normal
            . Confundir \t com espa√ßos

            Regra de ouro:

                Se come√ßa com \, n√£o √© letra ‚Äî √© comando.

        FRASES-CHAVE PARA MEMORIZAR:

            \n quebra
            \t organiza
            \r retorna
            r"" protege
            Unicode manda

        DICAS:

            . Use \n para clareza
            . Use \t para alinhamento simples
            . Sempre use r"" em caminhos
            . Unicode funciona em tudo

    =====================================================================

    N√∫meros (inteiros e reais):

        - N√∫meros representam valores matem√°ticos usados em c√°lculos, 
        compara√ß√µes e decis√µes.

        Em Python, os principais tipos num√©ricos b√°sicos s√£o:

            Inteiros (int) ‚Üí n√∫meros sem parte decimal

            Reais (float) ‚Üí n√∫meros com parte decimal

        Python n√£o limita o tamanho de inteiros (diferente de C, Java).

        COMO PENSAR COMO L√ìGICO:

            Antes de usar n√∫meros, pergunte:

                Esse valor pode ter v√≠rgula?

                Preciso de exatid√£o absoluta ou aproxima√ß√£o?

                Esse n√∫mero vai crescer muito?

                Vou usar em compara√ß√µes, c√°lculos ou controle de fluxo?

            A escolha entre int e float √© l√≥gica, n√£o sint√°tica.

        1) N√öMEROS INTEIROS (int)

            O que s√£o?

                . Valores sem parte decimal

                . Positivos, negativos ou zero

                . Precisos (exatos)

                EX:

                    a = 10
                    b = -3
                    c = 0

            Caracter√≠sticas importantes:

                . Precis√£o exata

                . Sem limite de tamanho:

                    x = 10**100

            Ideais para:

                . contadores

                . √≠ndices

                . quantidades

                . idade, unidades, pe√ßas

            Opera√ß√µes comuns com int:

                10 + 3     # soma
                10 - 3     # subtra√ß√£o
                10 * 3     # multiplica√ß√£o
                10 // 3    # divis√£o inteira
                10 % 3     # resto
                10 ** 3    # pot√™ncia

            Divis√£o com inteiros:

                10 / 2     # 5.0 (float!)

            Toda divis√£o / gera float, mesmo entre inteiros.

        2) N√öMEROS REAIS (float)

            O que s√£o?

                . Valores com parte decimal

                . Representados internamente em ponto flutuante

                . Aproximados (n√£o exatos)

                EX:

                    x = 3.14
                    y = -0.5
                    z = 10.0

            Caracter√≠sticas importantes:

                . Possuem erro de precis√£o

                . N√£o s√£o ideais para dinheiro

                . Bons para:

                    m√©dias

                    medidas

                    c√°lculos cient√≠ficos

                    porcentagens

            PROBLEMA CL√ÅSSICO DE PRECIS√ÉO:

                print(0.1 + 0.2)  # 0.30000000000000004

            Isso n√£o √© bug, √© limita√ß√£o matem√°tica do float.

        3) CONVERS√ÉO ENTRE INT E FLOAT

            . int()

                    int(3.9)    # 3

                PS: Corta, n√£o arredonda.

            . float()

                    float(10)   # 10.0

            . round()

                round(3.6)      # 4
                round(3.14159, 2)  # 3.14

        4) OPERA√á√ïES MISTAS (COER√á√ÉO)

            EX:

                10 + 2.5   # 12.5

            O int √© convertido automaticamente para float.

            Python sempre sobe o tipo, nunca desce.

        5) COMPARA√á√ïES COM N√öMEROS

                10 > 5
                3.5 <= 4
                10 == 10.0   # True

            Cuidado com float:

                0.1 + 0.2 == 0.3   # False

            Melhor:

                abs((0.1 + 0.2) - 0.3) < 1e-9

        6) FUN√á√ïES NUM√âRICAS IMPORTANTES

            | Fun√ß√£o     | Uso             |
            | ---------- | --------------- |
            | `abs()`    | valor absoluto  |
            | `round()`  | arredondar      |
            | `pow()`    | pot√™ncia        |
            | `min()`    | menor           |
            | `max()`    | maior           |
            | `sum()`    | soma            |
            | `divmod()` | divis√£o + resto |

        ERROS COMUNS

            . Usar float para dinheiro
            . Comparar floats diretamente
            . Achar que int() arredonda
            . Esquecer que / gera float

            Regra de ouro:

                Contagem ‚Üí int
                Medida ‚Üí float

        FRASES-CHAVE PARA MEMORIZAR:

            Inteiro √© exato
            Float √© aproximado
            Divis√£o sempre flutua
            Precis√£o importa

        int, long e limites de 32/64 bits:

            Em Python moderno (3.x), n√£o existe mais long separado.
            
            Todo inteiro √© do tipo int e cresce automaticamente.

            Limites de 32 e 64 bits n√£o se aplicam da mesma forma em Python.

            1) int √ó long (hist√≥rico importante)

                . Python 2 (ANTIGO)

                    int ‚Üí limitado (32 ou 64 bits)

                    long ‚Üí inteiros grandes (ex: 1234567890123456789L)

                . Python 3 (ATUAL)

                    long n√£o existe

                    Tudo √© int

                    Inteiros t√™m precis√£o arbitr√°ria

                    O Python cuida do tamanho automaticamente.

            2) O MITO DOS 32 E 64 BITS EM PYTHON

                Python n√£o limita inteiros a 32 ou 64 bits como C/Java.

                Em linguagens como C:

                    int ‚Üí 32 bits

                    long ‚Üí 64 bits (depende da arquitetura)

                Em Python:

                    int cresce conforme necess√°rio

                    O limite √© mem√≥ria dispon√≠vel

                N√£o ocorre overflow aritm√©tico em int.

            3) ENT√ÉO O QUE SIGNIFICA 32 OU 64 BITS?

                Isso se refere √† arquitetura da m√°quina e ao ponteiro de mem√≥ria, 
                n√£o ao n√∫mero em si.

                . Python 32-bit:

                    - Ponteiros de 32 bits

                    - Menos mem√≥ria endere√ß√°vel

                . Python 64-bit:

                    - Ponteiros de 64 bits

                    - Mais mem√≥ria endere√ß√°vel

                O valor inteiro continua ilimitado, s√≥ o consumo de mem√≥ria muda.

            4) CUSTO DE MEM√ìRIA DE INTEIROS GRANDES

                Inteiros grandes:

                    Usam mais mem√≥ria

                    S√£o mais lentos que inteiros pequenos

                Python usa m√∫ltiplas ‚Äúpalavras‚Äù internas para representar
                o n√∫mero.

                Python √© mais seguro, por√©m menos previs√≠vel em performance 
                extrema.

            5) FLOAT AINDA TEM LIMITE (IMPORTANTE)

                Apesar do int ser ilimitado:

                    - float continua limitado (IEEE 754)

                    - Aproximadamente:

                        . ~1.8 √ó 10¬≥‚Å∞‚Å∏ (m√°ximo)

                        . ~15‚Äì17 d√≠gitos de precis√£o
                
                EX:

                    x = 1e308
                    x * 10   # inf

                Overflow ainda existe em float.

        CAMPO DE ESTUDO ‚Äî FUN√á√ïES ESPECIAIS DE int E float:

            - int e float n√£o s√£o apenas n√∫meros: s√£o objetos com m√©todos 
            pr√≥prios.

            Esses m√©todos servem para:

                Inspecionar o n√∫mero

                Converter formatos

                Trabalhar com bits

                Lidar com precis√£o

                Representa√ß√£o interna
            
            Isso diferencia Python de linguagens ‚Äúmais simples‚Äù.

            FUN√á√ïES ESPECIAIS DE int:

                1. bit_length():

                    Retorna quantos bits s√£o necess√°rios para representar o 
                    inteiro.

                    EX:

                        n = 10
                        print(n.bit_length())  # 4

                    10 em bin√°rio ‚Üí 1010 (4 bits)

                2. to_bytes() e from_bytes()

                    . to_bytes()

                        Converte inteiro para bytes.

                            n = 1024
                            b = n.to_bytes(2, byteorder="big")
                            print(b)
                    
                    . from_bytes()

                        Faz o caminho inverso.

                            n2 = int.from_bytes(b, byteorder="big")
                            print(n2)

                3. __int__() (conceitual)

                    Convers√£o interna para inteiro.

                        int(3.7)  # usa __int__

                    Raramente usado diretamente, mas fundamental para coer√ß√£o.

                4. Representa√ß√µes: bin(), oct(), hex()

                    n = 42
                    print(bin(n))  # 0b101010
                    print(oct(n))  # 0o52
                    print(hex(n))  # 0x2a

                5. int() com base (MUITO IMPORTANTE)

                    int("1010", 2)   # 10
                    int("FF", 16)    # 255
                    int("77", 8)     # 63

                Converte string em n√∫mero usando base num√©rica.
            
            FUN√á√ïES ESPECIAIS DE float:

                1. is_integer()

                    Verifica se o float representa um inteiro exato.

                        x = 10.0
                        y = 10.5

                        print(x.is_integer())  # True
                        print(y.is_integer())  # False

                    Muito √∫til para valida√ß√µes.
                
                2. as_integer_ratio()

                    Retorna o float como fra√ß√£o exata.

                        x = 0.75
                        print(x.as_integer_ratio())  # (3, 4)

                    Mostra como o float √© representado matematicamente.

                3. hex() (do float!)

                        x = 3.14
                        print(x.hex())

                    E o inverso:

                        float.fromhex(x.hex())

                    Representa√ß√£o exata do float em hexadecimal.

                4. __float__() (conceitual)

                    Usado quando Python for√ßa convers√£o para float:

                        float(10)

                    Importante para coer√ß√£o autom√°tica.

            QUANDO USAR ISSO NA VIDA REAL

                bit_length() ‚Üí seguran√ßa, criptografia

                to_bytes() ‚Üí arquivos, rede

                is_integer() ‚Üí valida√ß√£o de c√°lculo

                as_integer_ratio() ‚Üí precis√£o matem√°tica

                int(base) ‚Üí parsing de dados

                hex/bin ‚Üí debug de baixo n√≠vel

    =====================================================================

    strings e caracteres:

        - String √© uma sequ√™ncia de caracteres.

        - Em Python, string √© um objeto do tipo str, imut√°vel e Unicode.

        . Caractere ‚Üí unidade b√°sica (letra, n√∫mero, s√≠mbolo)

        . String ‚Üí v√°rios caracteres juntos

        . Python n√£o tem tipo char, s√≥ str

        . Cada caractere √© um Unicode code point

        CARACTERE vs STRING:

            . Em Python:

                letra = "a"
                palavra = "abc"

            Ambos s√£o str:

                type("a")      # str
                type("abc")    # str

            N√£o existe diferen√ßa de tipo entre caractere e string curta.

        EM PYTHON (codifica√ß√£o):

                texto = "cora√ß√£o üòÑ"

            . Isso √© str

            . J√° √© Unicode

            . N√£o precisa configurar nada

            Em Python 3, str √© Unicode por padr√£o.

        str COMO OBJETO:

            - str √© uma classe, e strings s√£o objetos.

                s = "Python"
            
                type(s)        # str
                isinstance(s, str)  # True

            - Por isso strings t√™m m√©todos.

        PROPRIEDADES IMPORTANTES DE str

            . Imutabilidade

                    s = "abc"
                    # s[0] = "x"  # erro

                . Strings n√£o podem ser alteradas
                . Qualquer ‚Äúmodifica√ß√£o‚Äù cria outra string

            . Index√°vel

                    s = "Python"
                    print(s[0])    # 'P'
                    print(s[-1])   # 'n'

            . Iter√°vel

                    for c in "abc":
                        print(c)

            . Comprimento

                    len("Python")  # 6

        M√âTODOS ESSENCIAIS DE str

            - Transforma√ß√£o

                . Converter tudo em min√∫scula:

                    s.lower()

                . Converter tudo em mai√∫scula:

                    s.upper()

                . Converter as primeiras letras em mai√∫sculas:

                    s.capitalize()

                . Converter apenas a primeira letra da string em mai√∫scula:

                    s.title()

            - Remo√ß√£o de espa√ßos:

                . Remover espa√ßos a direita e esquerda:

                    s.strip()

                . Remover espa√ßos esquerda apenas:

                    s.lstrip()

                . Remover espa√ßos a direita apenas:

                    s.rstrip()

            - Testes (retornam bool)

                s.isalpha()     # s√≥ letras
                s.isdigit()     # s√≥ n√∫meros
                s.isalnum()     # letras e n√∫meros
                s.isspace()     # s√≥ espa√ßos
                s.islower()     # se est√° em min√∫scula
                s.isupper()     # se est√° em mai√∫scula

            - Busca

                s.find("a")        # √≠ndice ou -1
                "a" in s           # True / False
                s.startswith("a")  # Se o in√≠cio cont√©m string 'a'. Se sim True sen√£o False
                s.endswith("a")    # Se o final cont√©m string 'a'. Se sim True sen√£o False

            - Substitui√ß√£o:

                s.replace("a", "x")

            - Quebra e jun√ß√£o:

                "1,2,3".split(",")  # Quebra
                "-".join(["a", "b", "c"])  # Une apenas listas do tipo string

        FUN√á√ïES RELACIONADAS A CARACTERES

            - C√≥digo Unicode:

                ord("a")   # 97
                ord("√ß")   # 231

            - Caractere pelo c√≥digo

                chr(97)    # 'a'
                chr(231)   # '√ß'

        SLICING (FATIAMENTO):

            - Slicing √© extrair partes de uma string usando √≠ndices.

            Sintaxe geral:

                texto[in√≠cio:fim:passo]

            . in√≠cio ‚Üí √≠ndice inicial (inclusivo)

            . fim ‚Üí √≠ndice final (exclusivo)

            . passo ‚Üí de quantos em quantos caracteres

            Todos s√£o opcionais.

            EXEMPLOS B√ÅSICOS:

                s = "Python"

                Primeiro caractere:

                    s[0]      # 'P'

                √öltimo caractere

                    s[-1]     # 'n'

                Do √≠ndice 1 ao 3

                    s[1:4]    # 'yth'

                Do come√ßo at√© o √≠ndice 3

                    s[:4]     # 'Pyth'

                Do √≠ndice 2 at√© o final

                    s[2:]     # 'thon'

            SLICING COM PASSO

                Pulando caracteres

                    s[::2]    # 'Pto'

                Invertendo string

                    s[::-1]   # 'nohtyP'

                Forma curta para invers√£o.

                - Slicing cria nova string

        CONCATENA√á√ÉO

            - Concatena√ß√£o √© juntar strings.

            . Com operador +

                a = "Py"
                b = "thon"

                c = a + b

            Resultado:

                Python

            - Isso cria uma nova string.

            . Com +=

                s = "Py"
                s += "thon"

            - Tamb√©m cria nova string (imut√°vel).

        CUIDADO COM CONCATENA√á√ÉO EM LOOP:

                texto = ""
                for c in "abc":
                    texto += c

            Ineficiente para strings grandes.

            Melhor:

                lista = []
                for c in "abc":
                    lista.append(c)

                texto = "".join(lista)

        CONCATENA√á√ÉO COM TIPOS DIFERENTES

            Erro:

                "Idade: " + 20

            Correto:

                "Idade: " + str(20)

            Melhor:

                f"Idade: {20}"

        CONCATENA√á√ÉO x INTERPOLA√á√ÉO

            | Forma      | Quando usar           |
            | ---------- | --------------------- |
            | `+`        | Strings simples       |
            | `+=`       | Acumular poucas vezes |
            | `f-string` | Formata√ß√£o            |
            | `.join()`  | Muitas strings        |

        EXEMPLOS CL√ÅSSICOS

            Extrair dom√≠nio de e-mail

                email = "user@gmail.com"
                dominio = email[email.index("@")+1:]

            Remover prefixo/sufixo

                texto = "###dados###"
                limpo = texto.strip("#")

        PEGADINHAS IMPORTANTES

            . Tamanho visual ‚â† tamanho real

                    len("üòÑ")  # 1

                Mas em bytes:

                    len("üòÑ".encode("utf-8"))  # 4
            
            . Compara√ß√£o depende de Unicode

                    "Z" < "a"   # True

                Mai√∫sculas v√™m antes no Unicode.

        FRASES-CHAVE PARA MEMORIZAR

            Python n√£o tem char
            Tudo √© Unicode
            UTF-8 √© codifica√ß√£o
            String √© objeto imut√°vel
            Caractere √© uma string de tamanho 1
            Slicing fatia
            Fim n√£o inclui
            Passo controla salto
            Concatena√ß√£o cria nova string

        Erros comuns:

            Achar que existe char em Python (n√£o existe). "a" ainda √© str.
            
            Confundir str com bytes (texto vs dados bin√°rios).
            
            Achar que string √© mut√°vel: tentar s[0] = "x" d√° erro.
            
            Esquecer que input() vem com texto, e n√£o n√∫mero.
            
            Esquecer de normalizar: comparar sem .lower() / .strip().
            
            Usar .strip() achando que remove ‚Äúno meio‚Äù (ele s√≥ remove nas pontas).
            
            Comparar texto com is em vez de ==.
            
            Achar que "Z" > "a" segue ‚Äúalfabeto humano‚Äù (√© ordem Unicode)
            
            Usar in achando que √© ‚Äúpalavra inteira‚Äù (√© substring).
            
            Usar .find() e esquecer que -1 significa ‚Äún√£o achou‚Äù.
            
            Usar .replace() achando que altera a string original (n√£o altera; 
            cria outra).

            Achar que o fim em s[inicio:fim] √© inclusivo (n√£o √©).

            Errar √≠ndice negativo (ex.: s[-0] √© igual a s[0]).
            
            Confundir s[::-1] (invers√£o) com ‚Äúordenar‚Äù.

        Dicas:

            - Normalize antes de comparar

            - Pense em √≠ndice, fatia, busca, separa√ß√£o (split) e jun√ß√£o (join).

            - Escolha a ferramenta certa

            - Slicing: fim n√£o entra

            - Teste com casos chatos

            - Sempre mostre com aspas no debug

    =====================================================================

    parsings:

        - Parsing √© o processo de analisar uma string e extrair partes com 
        significado.

        Ou seja:

            Entrada √© texto bruto

            Sa√≠da s√£o dados organizados (n√∫meros, campos, estruturas)

        - Parsing ‚â† valida√ß√£o
        - Parsing ‚â† formata√ß√£o
        - Parsing = interpretar

        COMO PENSAR COMO L√ìGICO (ANTES DO C√ìDIGO):

            Sempre responda:

                1. Qual √© o formato esperado do texto?

                2. Onde est√£o os delimitadores? (@, ,, ;, :‚Ä¶)

                3. O texto √© fixo ou vari√°vel?

                4. O que eu preciso extrair?

            Parsing come√ßa no formato, n√£o no c√≥digo.

        TIPOS COMUNS DE PARSING

            1. Parsing por delimitador

                Quando o texto tem separadores claros.

                Exemplo:

                    nome;idade;cidade

                C√≥digo:

                    linha = "Ana;20;SP"
                    nome, idade, cidade = linha.split(";")

            2. Parsing por posi√ß√£o fixa

                Quando cada campo tem posi√ß√£o conhecida.

                Exemplo:

                    20240115BRSP

                C√≥digo:

                    data = texto[0:8]
                    pais = texto[8:10]
                    estado = texto[10:12]

                Muito usado em arquivos antigos (mainframe).

            3. Parsing por busca (find, index)

                Quando o delimitador pode variar de posi√ß√£o.

                Exemplo:

                    email = "user.name+tag@gmail.com"
                    pos = email.find("@")

                    usuario = email[:pos]
                    dominio = email[pos+1:]

            4. Parsing progressivo (passo a passo)

                Quando voc√™ ‚Äúconsome‚Äù a string.

                    texto = "10:20:30"
                    partes = texto.split(":")
                    h, m, s = map(int, partes)

        FERRAMENTAS DE PARSING EM STRINGS

            + .split()

                "1,2,3".split(",")

            + .find() / .index

                s.find("@")   # -1 se n√£o achar
                s.index("@")  # erro se n√£o achar

            + .startswith() / .endswith()

                email.endswith(".com")

            + Slicing

                texto[a:b]

            + .replace() (pr√©-processamento)

                valor = "1.234,56".replace(".", "").replace(",", ".")

        PARSING + CONVERS√ÉO DE TIPO:

            Parsing geralmente vem antes de converter tipo.

            Exemplo:

                valor = "R$ 12,50"
                valor = valor.replace("R$", "").strip()
                valor = float(valor.replace(",", "."))

            Ordem correta:

                limpar ‚Üí extrair ‚Üí converter

        PARSING ‚â† REGEX (IMPORTANTE)

            . Parsing simples ‚Üí split, find, slicing

            . Parsing complexo/padr√µes ‚Üí regex (re)

            N√£o use regex quando split resolve.

        ERROS COMUNS EM PARSING

            Assumir que o formato sempre vem certo

            N√£o tratar caso de erro (find retornar -1)

            Fazer parsing e convers√£o tudo junto

            N√£o normalizar antes (strip, lower)

            Usar regex para tudo (overkill)

        FRASES-CHAVE PARA MEMORIZAR

            Parsing √© leitura estruturada
            Delimitador manda
            Limpa antes de converter
            Texto primeiro, n√∫mero depois

        DICAS

            Desenhe o formato

            Ache os delimitadores

            Extraia em partes

            S√≥ depois converta tipo

            Teste entradas ‚Äúfeias‚Äù

    =====================================================================

    Blocos e escopos:

        - Bloco √© um agrupamento de c√≥digo.

        - Escopo define onde uma vari√°vel √© vis√≠vel.

        Em Python:

            Blocos s√£o definidos por indenta√ß√£o

            Escopo n√£o depende de {} (como em C/Java)

            Nem todo bloco cria um novo escopo

        BLOCOS EM PYTHON

            - Um bloco come√ßa ap√≥s : e √© definido pela indenta√ß√£o.

            Exemplos de blocos:

                if condicao:
                    ...

                for x in lista:
                    ...

                while condicao:
                    ...

                def func():
                    ...

            Indenta√ß√£o errada = erro ou bug l√≥gico.

        ESCOPO (VISIBILIDADE)

            Escopo responde:

                ‚ÄúEssa vari√°vel existe aqui?‚Äù

            Python segue a regra LEGB:

                1. local
                2. Enclosing
                3. global
                4. Built-in

            . ESCOPO LOCAL:

                - Vari√°veis criadas dentro de fun√ß√µes.

                    def f():
                        x = 10

                    # x n√£o existe aqui
  
                S√≥ existem dentro da fun√ß√£o.

            . ESCOPO GLOBAL

                - Vari√°veis criadas fora de fun√ß√µes.

                    x = 5

                    def f():
                        print(x)

                . Pode ler

                . N√£o pode atribuir sem a palavra resrvada global

            . global (cuidado)

                    x = 10

                    def f():
                        global x
                        x = 20

                . Altera o valor global

                . Pode causar bugs dif√≠ceis

            . nonlocal

                - Usado em fun√ß√µes dentro de fun√ß√µes.

                    def externa():
                        x = 10
                        def interna():
                            nonlocal x
                            x = 20

        BLOCO ‚â† ESCOPO (PEGADINHA CL√ÅSSICA)

            if, for, while N√ÉO criam escopo:

                if True:
                    y = 10

                print(y)  # funciona

            Diferente de C/Java.

            Fun√ß√µes criam escopo:

                def f():
                    z = 5

                print(z)  # erro

        SOMBREAMENTO (SHADOWING)

            - Vari√°vel local com mesmo nome de uma global.

                x = 10

                def f():
                    x = 5   # sombra

            Global continua existindo, mas ‚Äúescondida‚Äù dentro da fun√ß√£o.

        ERROS COMUNS

            Achar que if cria escopo

            Esquecer indenta√ß√£o

            Usar global sem necessidade

            Modificar global dentro de fun√ß√£o sem perceber

            Criar vari√°veis dentro de loop achando que ‚Äúmorrem‚Äù

        DICAS DE ATAQUE

            Sempre leia a indenta√ß√£o

            Pergunte: ‚Äúonde essa vari√°vel nasceu?‚Äù

            Prefira retornar valores a usar global

            Evite nomes iguais em escopos diferentes

            Use fun√ß√µes para isolar l√≥gica

        FRASES-CHAVE PARA MEMORIZAR

            Indenta√ß√£o manda
            Fun√ß√£o cria escopo
            Loop n√£o cria
            global √© perigoso
            Escopo evita bugs

        UM POUCO MAIS SOBRE LEGB:

            Quando o Python encontra um nome (x, print, len‚Ä¶), ele procura 
            nesta ordem exata:

                1. Local
                2. Enclosing
                3. Global
                4. Built-in

            Ele para no primeiro que encontrar.

            LOCAL (L):

                - Vari√°veis criadas dentro da fun√ß√£o atual.

                    def f():
                        x = 10
                        print(x)

                    f()

                . x existe s√≥ dentro de f

                . √â o primeiro lugar que o Python procura

                Fora da fun√ß√£o:

                    print(x)  # erro

                Local √© o escopo mais forte.

            ENCLOSING (E):

                - Vari√°veis da fun√ß√£o externa que envolve a fun√ß√£o atual.

                    def externa():
                        y = 20
                        def interna():
                            print(y)
                        interna()

                    externa()

                . y n√£o √© local de interna

                . Tamb√©m n√£o √© global

                . √â enclosing

                + nonlocal (controla o enclosing):

                    def externa():
                        y = 20
                        def interna():
                            nonlocal y
                            y = 30
                        interna()
                        print(y)  # 30

                . Sem nonlocal, voc√™ n√£o pode atribuir ao enclosing.

            GLOBAL (G):

                - Vari√°veis criadas fora de qualquer fun√ß√£o.

                    x = 5

                    def f():
                        print(x)

                    f()

                . Pode ler vari√°vel global

                . N√£o pode atribuir sem global

                + global (cuidado!):

                    x = 5

                    def f():
                        global x
                        x = 10

                . Altera o valor global

                . Pode causar bugs dif√≠ceis de rastrear

            BUILT-IN (B):

                - Nomes que j√° v√™m com o Python.

                Exemplos:

                    print
                    len
                    int
                    str
                    range

                C√≥digo:

                    print(len("abc"))  # 3

                . √öltimo lugar onde o Python procura.

                Sombreamento perigoso (shadowing):

                        len = 10
                        print(len("abc"))  # ERRO

                    . Voc√™ escondeu o len built-in.

            ORDEM REAL DE BUSCA (PASSO A PASSO)

                Quando o Python v√™:

                    print(x)

                Ele faz:

                    1. x existe no local?

                    2. N√£o? existe no enclosing?

                    3. N√£o? existe no global?

                    4. N√£o? existe no built-in?

                    5. N√£o? ‚Üí NameError

            EXEMPLO COMPLETO LEGB:

                    x = "global"

                    def externa():
                        x = "enclosing"
                        def interna():
                            x = "local"
                            print(x)  # Built-in
                        interna()

                    externa()

                Sa√≠da:

                    local

                Se voc√™ remover x = "local":

                    enclosing

                Se remover tamb√©m:

                    global

                Se n√£o existir global:

                    NameError

            ERROS COMUNS COM LEGB:

                Achar que if cria escopo

                Usar global sem perceber

                N√£o entender nonlocal

                Sombrear print, list, str

                Pensar que Python ‚Äúadivinha‚Äù escopo

            DICAS:

                Sempre pergunte: onde esse nome nasceu?

                Fun√ß√£o ‚Üí cria escopo

                Loop ‚Üí n√£o cria

                Prefira retorno a global

                Evite nomes iguais aos built-ins

            FRASE FINAL PRA MEMORIZAR:

                . Python procura nomes como uma cebola:

                . local ‚Üí enclosing ‚Üí global ‚Üí built-in

    =====================================================================

    Estruturas condicionais / tern√°rios:

        - Estruturas condicionais controlam o fluxo de execu√ß√£o do programa com 
        base em express√µes l√≥gicas.

        Formalmente:

            Avaliam uma condi√ß√£o booleana

            Executam um bloco entre alternativas poss√≠veis

            S√£o a base de decis√£o, ramifica√ß√£o e l√≥gica de neg√≥cio

        Sem condicionais, um programa √© apenas sequencial.

        if:

            - Executa um bloco se a condi√ß√£o for verdadeira.

            Sintaxe:

                if condi√ß√£o:
                    bloco

            Exemplo:

                idade = 18

                if idade >= 18:
                    print("Maior de idade")

                if True:  # SE TROCAR POR False N√ÉO IR√Å ENTRAR NO BLOCO
                    print("Sempre vai passar aqui")

            Caracter√≠sticas:

                . Condi√ß√£o deve resultar em verdade l√≥gico (truthy)

                . Se for falsa, o bloco √© ignorado

                . Pode existir sozinho

            Uso t√≠pico:

                valida√ß√£o

                checagem simples

                guarda de execu√ß√£o

        if if if ... (ifs independentes):

            - M√∫ltiplos if n√£o s√£o ligados entre si.

            Sintaxe:

                if A:
                    bloco
                if B:
                    bloco
                if C:
                    bloco

            Exemplo:

                x = 10

                if x > 0:
                    print("x √© positivo")

                if x % 2 == 0:
                    print("x √© par")

                if x >= 10:
                    print("x √© maior ou igual a 10")

            . Cada condi√ß√£o √© avaliada sempre

            . Mais de um bloco pode executar

            . N√£o √© escolha exclusiva

            Use quando condi√ß√µes s√£o independentes.

        if / elif:

            - Estrutura de escolha exclusiva.

            Sintaxe:

                if A:
                    bloco
                elif B:
                    bloco
                elif C:
                    bloco

            Exemplo:

                nota = 7.5

                if nota >= 8:
                    print("Nota alta")
                elif nota > 6 and nota < 8:
                    print("Nota na m√©dia")

            Caracter√≠sticas:

                . Avalia√ß√£o sequencial

                . Apenas um bloco executa

                . Para no primeiro verdadeiro

                . elif √© um acr√¥nimo a else if

                . elif depende exclusivamente de um if, ou seja, n√£o consegue 
                rodar sozinho

            Modela decis√£o hier√°rquica.

        if / else:

            - Escolha bin√°ria: ou isso, ou aquilo.

            Sintaxe:
            
                if A:
                    bloco
                else:
                    bloco

            Exemplo:

                nome = "Carro"

                if nome == "Carro":
                    print("Automotor de 4 eixos")
                else:
                    print("Outro objeto")
                
            . Garante execu√ß√£o de um dos dois blocos

            . Muito usado para valida√ß√£o

            . Um else depende exclusivamente de if, ou seja, n√£o pode rodar
            sozinho

        if / elif / else:

            - Forma mais comum de decis√£o completa.

            Sintaxe:

                if A:
                    bloco
                elif B:
                    bloco
                elif C:
                    bloco
                else:
                    bloco

            Exemplo:

                permissao = 0

                if permissao == 0:
                    print("Sem permiss√£o")
                elif permissao == 1:
                    print("Permissao total")
                else:
                    print("Fora do limite de permiss√£o")

            . Todas as possibilidades s√£o cobertas

            . else √© o caso residual

            . Estrutura fechada e previs√≠vel

            Ideal quando h√° categorias mutuamente exclusivas.

        if ANINHADO (if dentro de if):

            - Condi√ß√µes dependentes de condi√ß√µes anteriores.

            Sintaxe:

                if A:
                    if B:
                        ...

            Exemplo:

                nome = "Jo√£o"
                idade = 22

                if nome == "Jo√£o":

                    if idade >= 18:
                        print("√â de maior")
                    elif 15 <= idade < 18:
                        print("√â adolescente")
                    else:
                        if idade == 14:
                            print("T√™m 14 anos")
                        print("√â menos de idade")

                else:
                    print("Nome inv√°lido")

            PS: Nota que podemos aninhar todas as vers√µes anteriores se
            necess√°rio.

            Caracter√≠sticas:

                . Cria √°rvore de decis√£o

                . Pode aumentar complexidade rapidamente

                . Pode ser reescrito como elif em muitos casos

            Aninhamento profundo = alerta de design.

        IF TERN√ÅRIO (express√£o condicional)

            - Condicional como express√£o, n√£o como bloco.

            Forma geral:

                valor = X if condi√ß√£o else Y

            Exemplo:

                acesso_a_entrada = True
                pode_passar = True if acesso_a_entrada else False

            Caracter√≠sticas:

                Retorna um valor

                Mais conciso

                N√£o cria bloco

            Use para atribui√ß√µes simples, n√£o para l√≥gica complexa.

        IF TERN√ÅRIO ANINHADO

            - V√°rios tern√°rios encadeados.

            Forma geral:

                valor = A if c1 else B if c2 else C

            Exemplo:

                x = -3

                resultado = (  # () Serve nesse caso para linhar e deixar mais leg√≠vel
                    "positivo" if x > 0
                    else "zero" if x == 0
                    else "negativo"
                )

                print(resultado)

            Caracter√≠sticas:

                . Funciona

                . Legibilidade cai r√°pido

                . Deve ser usado com extremo cuidado

                Em geral, prefira if / elif / else.

        match (Python 3.10+)

            - Estrutura de pattern matching (equivalente moderno ao switch).

            Sintaxe:

                match valor:
                    case X:
                    case Y:
                    case _:

            Exemplo:

                opcao = input("Escolha uma op√ß√£o (1, 2, 3, a, b): ")

                match opcao:
                    case "1":
                        print("Op√ß√£o 1 selecionada")

                    case "2" | "3":
                        print("Op√ß√£o 2 ou 3 selecionada")

                    case x if x in ("a", "b", "c"):
                        print("Op√ß√£o de letra v√°lida (a, b ou c)")

                    case _:
                        print("Op√ß√£o inv√°lida")

            Caracter√≠sticas:

                . Compara√ß√£o estrutural

                . Melhor que if/elif para muitos casos fixos

                . _ √© o caso padr√£o (else)

                . Match s√≥ aceita condi√ß√µes l√≥gicas bit-wise, exemplo acima: |

                . Pode fazer verifica√ß√µes com ifs tern√°rios

            Excelente para:

                enums

                comandos

                protocolos

                parsing

        IFs MAL PROJETADOS (M√ÅS PR√ÅTICAS)

            . Condi√ß√µes longas e ileg√≠veis:

                if a and b or c and not d and e:

            . Aninhamento profundo:

                if A:
                    if B:
                        if C:
                            if D:

            . Repeti√ß√£o de condi√ß√£o:

                if x > 10:
                    ...
                elif x > 10 and y > 5:
                    ...

            . Uso excessivo de else:

                - else escondendo erro

                - l√≥gica impl√≠cita perigosa

        BOAS PR√ÅTICAS COM CONDICIONAIS:

            . Prefira retornos antecipados
            . Use elif em vez de aninhar
            . Quebre condi√ß√µes complexas em vari√°veis
            . Use par√™nteses para clareza
            . Cada if deve ter uma responsabilidade

        if + return (PADR√ÉO PROFISSIONAL EM FUN√á√ïES E M√âTODOS DE CLASSE)

            - Retornar cedo simplifica l√≥gica.

            Ruim:

                if cond:
                    resultado = X
                else:
                    resultado = Y
                return resultado

            Bom:

                if cond:
                    return X
                return Y

            Benef√≠cios:

                Menos indenta√ß√£o

                Fluxo mais claro

                C√≥digo mais leg√≠vel

            Early return √© padr√£o profissional.
        
        FRASES-CHAVE PARA MEMORIZAR

            if decide
            elif organiza
            else cobre o resto
            Tern√°rio √© express√£o
            match √© escolha estrutural
            Muitos ifs = sinal de design ruim

        ERROS COMUNS EM ESTRUTURAS CONDICIONAIS

            1) Confundir if independentes com if/elif

                    if x > 0:
                        ...
                    if x > 10:
                        ...

                PS: Ambos podem executar.

                Use elif quando a decis√£o for exclusiva.

            2) Aninhamento excessivo

                    if A:
                        if B:
                            if C:
                                if D:

                - C√≥digo dif√≠cil de ler e manter

                Correto: Reescreva com elif, and ou early return

            3) Condi√ß√µes longas e ileg√≠veis

                    if a and b or c and not d and e:

                - Alto risco de bug

                Correto: Quebre em vari√°veis intermedi√°rias

            4) else gen√©rico escondendo erro

                    if valido:
                        processa()
                    else:
                        processa_outra_coisa()

                PS: O else pode engolir casos inesperados

                Correto: Trate casos expl√≠citos

            5) Comparar booleanos explicitamente

                    if cond == True:

                - Desnecess√°rio

                Use apenas:
                
                    if cond:

            6) Tern√°rio complexo demais

                    x = a if c1 else b if c2 else d if c3 else e

                Legibilidade p√©ssima

                Correto: Use if/elif/else

            7) Repeti√ß√£o de condi√ß√£o

                    if x > 10:
                        ...
                    elif x > 10 and y > 5:

                - Redund√¢ncia

                Correto: Reorganize a l√≥gica

            8) match usado como if comum

                - Usar match para poucas condi√ß√µes simples

                Correto: Use quando h√° m√∫ltiplos padr√µes claros

            9) Usar is para comparar valor

                    if x is 10:

                - Errado
                
                Correto: if x == 10:

            10) N√£o entender truthy/falsy

                    if valor:

                PS: "0" √© True

            11) Condi√ß√µes impl√≠citas demais

                    if a and b or c:

                - Amb√≠guo

                Correto: Use par√™nteses ou vari√°veis intermedi√°rias

            12) Usar in achando que √© igualdade

                    if "a" in "ana":

                PS: Isso √© substring, n√£o palavra inteira

        DICAS:

            - Decis√£o √© exclusiva ou independente?

            - Liste os casos poss√≠veis antes de codar

            - Use early return sempre que poss√≠vel

            - Prefira clareza a concis√£o

            - Se tem muitos elif, pense em match.

            - Se o if cresce demais, √© sinal de design ruim

            - Leia a condi√ß√£o em voz alta

            - Pergunte: que objeto est√° sendo avaliado?

            - Qual operador est√° sendo usado?

            - Esse operador retorna bool ou objeto?

            - Esse objeto √© truthy ou falsy?

            - Preciso comparar valor (==) ou identidade (is)?

            - Preciso normalizar antes (strip, lower)?

        OPERADORES E OBJETOS EM CONDI√á√ïES:

            - Em Python, condi√ß√µes avaliam objetos, n√£o apenas valores booleanos.

            Qualquer express√£o em um if passa por:

                bool(express√£o)

            Por isso, objetos t√™m comportamento condicional.

            1. Operadores Relacionais:

                - Usados para comparar valores.

                    if idade >= 18:
                    if nome == "Ana":

                Resultado: bool

            2. Operadores L√≥gicos:

                - Combinam condi√ß√µes.

                    if idade >= 18 and tem_doc:

                    if n1 * n2 == n1 + n2 or is_prime():

                    if not (valor_zerado):

                Retornam operandos, mas em if s√£o avaliados como booleanos.

            3. Operadores de Pertin√™ncia:

                - Verificam pertencimento.

                    if "@" in email:

                    if nome not in lista:

                Chamam internamente m√©todos como __contains__.

            4. Operadores de Identidade:

                - Verificam identidade de objeto, n√£o valor.

                    if x is None:

                Usado para sentinelas, n√£o para compara√ß√£o de valor.

            OBJETOS EM CONDI√á√ïES (TRUTHY / FALSY):

                Objetos Falsy (avaliam como False):

                    False
                    None
                    0, 0.0
                    ""
                    [], {}, set()

                    EX:

                        if lista:
                            ...

                    S√≥ entra se a lista n√£o estiver vazia.
            
                Objetos Truthy:

                    Todo objeto que n√£o √© falsy.

                    EX:

                        if "abc":
                        if [1]:
                        if 10:

                    Conte√∫do n√£o importa ‚Äî s√≥ o estado l√≥gico.

            M√âTODOS DE OBJETOS EM CONDI√á√ïES:

                Strings:

                    if nome.strip():
                    if texto.isdigit():

                Listas:

                    if lista:

                Dicion√°rios:

                    if "chave" in d:

                Condi√ß√µes frequentemente usam m√©todos do objeto, n√£o operadores 
                puros.

            OPERADORES CHAMAM M√âTODOS (IMPORTANTE)

                Quando voc√™ escreve:

                    a == b

                Python executa:

                    a.__eq__(b)

                Isso significa:

                    . Objetos controlam como s√£o comparados

                    . Classes podem redefinir comportamento condicional

                Isso √© base de polimorfismo.

            CONDI√á√ïES COM FUN√á√ïES (RETORNO)

                    if func():

                . A fun√ß√£o √© chamada

                . O retorno √© convertido com bool()

                . Decide o fluxo

                Fun√ß√µes devem retornar algo sem√¢ntico para condi√ß√µes.


    =====================================================================

    Estruturas de repeti√ß√£o:

        - Estruturas de repeti√ß√£o executam um bloco de c√≥digo m√∫ltiplas vezes 
        enquanto uma condi√ß√£o for satisfeita ou enquanto houver elementos a 
        percorrer.

        Formalmente:

            Reduzem repeti√ß√£o de c√≥digo

            Modelam processos iterativos

            S√£o base de algoritmos, busca, acumula√ß√£o e simula√ß√£o

        while:

            - Repeti√ß√£o controlada por condi√ß√£o

            - Executa o bloco enquanto a condi√ß√£o for verdadeira.

            EX:

                while condi√ß√£o:
                    bloco

            Exemplo classico:

                cont = 0

                while cont < 10:
                    print(cont)
                    cont += 1

            . Leia-se, enquanto a vari√°vel chamada cont for menor que 10
            . Mostre cont
            . Incremente + 1 em cont

            Caracter√≠sticas:

                Teste ocorre antes da execu√ß√£o

                Pode executar zero ou mais vezes

                Ideal quando n√£o se sabe o n√∫mero de itera√ß√µes

            Iter√°veis com while:

                Uso cl√°ssico com √≠ndice:

                        i = 0
                        while i < len(lista):
                            lista[i]
                            i += 1

                    Exige:

                        controle manual de √≠ndice

                        incremento expl√≠cito

                        maior chance de erro

                Uso de operadores com while:

                    Relacionais: controlam a condi√ß√£o

                    Aritm√©ticos: contadores

                    L√≥gicos: m√∫ltiplas condi√ß√µes

                        while i < 10 and ativo:

            while aninhado:

                - Um while dentro de outro.

                EX:
                    
                    while A:
                        while B:

                C√≥digo:

                    linha = 0

                    while linha < 3:
                        coluna = 0

                        while coluna < 4:
                            print(f"linha={linha}, coluna={coluna}")
                            coluna += 1

                        linha += 1


                    i = 1

                    while i <= 3:
                        j = 1

                        while j <= 5:
                            print(f"{i} x {j} = {i * j}")
                            j += 1

                        print("-----")
                        i += 1

                . Modela repeti√ß√µes bidimensionais

                . Usado em matrizes, tabelas, for√ßa bruta

                . Risco alto de complexidade O(n¬≤)

            while True:

                - Loop incondicional.

                EX:

                    while True:
                        if condicao_de_saida:
                            break   # Para o loop

                Usado quando:

                    . a condi√ß√£o de parada √© interna

                    . leitura cont√≠nua

                    . menus

                    . eventos

                Sempre deve existir break.

            Loop infinito:

                    while True:
                        pass

                . Pode travar o programa

                . √Äs vezes √© intencional (servidores, sistemas reativos)

                . Em scripts comuns ‚Üí bug

            Fun√ß√µes especiais no while:

                break ‚Üí sai do loop

                continue ‚Üí pula para pr√≥xima itera√ß√£o

                pass ‚Üí n√£o faz nada (placeholder)

            while else:

                Executa o else se o loop terminar sem break.

                EX:

                    while cond:
                        ...
                        if erro:
                            break
                    else:
                        # terminou normalmente

                Pouco usado, mas poderoso para:

                    . busca

                    . valida√ß√£o

                    . detec√ß√£o de falha

        for:

            - Repeti√ß√£o controlada por iter√°vel

            - Percorre cada elemento de um iter√°vel.

            Sintaxe:

                for elemento in iter√°vel:
                    bloco

            Caracter√≠sticas:

                Mais seguro que while

                N√£o exige √≠ndice manual

                Preferido em Python

            Iter√°veis com for:

                Exemplos:

                    string
                    lista
                    tupla
                    set
                    dict
                    range

                EX Sintaxe:

                    for c in "Python":

                . range:

                    - Gerador de sequ√™ncia num√©rica.

                        range(inicio, fim, passo)

                    . fim √© exclusivo

                    . Muito usado para contagem

                        for i in range(10):

                . Uso de operadores com for:

                        soma = 0
                        for x in range(10):
                            soma += x

                    Modelo cl√°ssico: acumulador

                . Aplica√ß√µes cl√°ssicas de for:

                    1. Contador

                            contador = 0
                            for _ in range(10):
                                contador += 1

                        . _: significa, n√£o chamar nada, apenas executar

                    2. Acumulador

                            total = 0
                            for n in lista:
                                total += n

                    3. Busca

                            for x in lista:
                                if x == alvo:
                                    break

                    4. Filtragem

                            for x in lista:
                                if x > 0:

                    5. Transforma√ß√£o

                            for x in lista:
                                novo = x * 2

            for aninhado:

                Sintaxe:

                    for i in range(n):
                        for j in range(m):

                EX:

                    for i in range(1, 5):
                        for j in range(1, 5):
                            if i != j:
                                print(f"({i}, {j})")


                    letras = ["A", "B", "C"]
                    for l1 in letras:
                        for l2 in letras:
                            if l1 != l2:
                                print(l1 + l2)

                . Matrizes

                . Tabelas

                . Combina√ß√µes

                . Complexidade cresce r√°pido

            Fun√ß√µes especiais no for

                break
                continue
                pass
                enumerate
                zip

                Exemplo:

                    for i, valor in enumerate(lista):

            for else:

                - Executa o else se o loop terminar sem break.

                Sintaxe:

                    for x in lista:
                        if x == alvo:
                            break
                    else:
                        # n√£o encontrou

                Muito usado em busca.

            ERROS COMUNS EM LOOPS:

                Esquecer incremento no while

                Loop infinito acidental

                Usar while quando for √© melhor

                Aninhamento excessivo

                Misturar l√≥gica demais dentro do loop

                N√£o usar break quando deveria

                Usar while sem atualizar estado

                Tentar controlar √≠ndice dentro de for

                Misturar responsabilidades (contador + condi√ß√£o confusa)

                Off-by-one (< vs <=)

                Incrementar fora do lugar correto

            DICAS:

                Sabe quantas vezes? ‚Üí for
                N√£o sabe quando para? ‚Üí while
                Percorre cole√ß√£o? ‚Üí for
                Menu / evento / leitura cont√≠nua? ‚Üí while True
                Busca? ‚Üí for + break + else
                Muito aninhamento? ‚Üí repense o algoritmo
                Pergunte: quem controla o passo? voc√™ ‚Üí while | Python ‚Üí for
                Se precisar decrementar, pense em range com passo negativo
                Se tem contador manual em for, talvez precise de enumerate
                Se o loop n√£o termina, procure o incremento
                Atualiza√ß√£o do estado deve ser √≥bvia ao ler o c√≥digo

            FRASES-CHAVE PARA MEMORIZAR:

                while depende de condi√ß√£o
                for depende de cole√ß√£o
                break encerra
                continue pula
                else s√≥ roda sem break
                loop ruim = design ruim
                while exige atualiza√ß√£o expl√≠cita
                for itera sozinho
                Incremento move o estado
                Sem incremento, n√£o h√° progresso


        INCREMENTO E DECREMENTO EM LOOPS:

            - Como o estado do loop evolui

            - Incrementar/decrementar √© alterar o estado que controla a repeti√ß√£o.
            
            - Sem isso, o loop n√£o progride ‚Üí loop infinito.

            Em termos formais:

                Loop = condi√ß√£o + estado + atualiza√ß√£o

                Incremento/decremento = atualiza√ß√£o do estado

            Papel no while:

                - No while, VOC√ä √© respons√°vel por atualizar a vari√°vel de 
                controle.

                Estrutura conceitual:

                    estado_inicial
                    while condi√ß√£o(estado):
                        bloco
                        atualiza√ß√£o_do_estado

                . Incremento cl√°ssico:

                        i = 0
                        while i < 5:
                            print(i)
                            i += 1

                    Leitura l√≥gica:

                        i come√ßa em 0
                        enquanto i < 5
                        imprime
                        incrementa i
                        volta para testar

                    Sem i += 1 ‚Üí loop infinito.

                . Decremento cl√°ssico:

                        i = 5
                        while i > 0:
                            print(i)
                            i -= 1

                    Leitura:

                        contador regressivo
                        usado em temporizadores, contagem reversa

                Incremento/decremento com operadores:

                        while x < 10:
                            x = x + 2      # incremento de 2

                        while saldo > 0:
                            saldo -= gasto
                    
                    Incremento n√£o precisa ser de 1.

                Exemplo cl√°ssico de bug:

                    i = 0
                    while i < 10:
                        print(i)
                    # i nunca muda

            while True + incremento

                    i = 0
                    while True:
                        print(i)
                        i += 1
                        if i == 5:
                            break

                Aqui o incremento controla a sa√≠da, n√£o a condi√ß√£o do while.

        INCREMENTO / DECREMENTO NO for:

            . Conceito fundamental

                No for, o incremento √© impl√≠cito.

            Voc√™ n√£o controla o √≠ndice manualmente.

                for i in range(5):
                    print(i)

            Internamente:

                . Python pega o pr√≥ximo valor do iter√°vel

                . N√£o existe i += 1 vis√≠vel

                N√£o tente controlar i manualmente dentro do for.

            Incremento com range:

                    for i in range(0, 10, 2):
                        print(i)

                Incremento de 2:

                    0 ‚Üí 2 ‚Üí 4 ‚Üí 6 ‚Üí 8

            Decremento com range:

                    for i in range(5, 0, -1):
                        print(i)

                . Passo negativo ‚Üí decremento.

            Acumuladores (incremento indireto)

                Muito comum em for:

                        soma = 0
                        for x in range(10):
                            soma += x

                    Aqui:

                        x muda automaticamente

                        soma √© incrementada manualmente

                    Dois tipos de ‚Äúincremento‚Äù coexistem:

                        do iterador

                        do acumulador

            N√ÉO FA√áA ISSO EM for

                    for i in range(10):
                        i += 1  # in√∫til

                . Isso n√£o altera o loop

                . S√≥ muda a vari√°vel local naquela itera√ß√£o

        QUANDO USAR CADA LOOP:

            Use for quando:

                Voc√™ tem uma cole√ß√£o
                Voc√™ sabe quantas vezes vai iterar
                Est√° percorrendo lista, string, dicion√°rio
                Est√° acumulando valores
                Est√° fazendo busca simples

                - Em Python, for √© a escolha padr√£o.

            Use while quando:

                A condi√ß√£o de parada √© din√¢mica
                Voc√™ n√£o sabe quantas itera√ß√µes haver√°
                O loop depende de eventos, entradas ou estados
                Menus interativos
                Leitura at√© erro/sentinela

                - while √© mais poderoso ‚Äî e mais perigoso.

        LOOPS COM CONDICIONAIS:

            - Loop sem if quase n√£o decide nada.

            - if fora de loop quase n√£o escala.

            O poder est√° na combina√ß√£o.

            1) Condicional controla perman√™ncia no loop

                while:
                
                        while x < 10:

                    Aqui:

                        Condi√ß√£o mant√©m ou encerra o loop

            2) Condicional controla sa√≠da antecipada (break)

                    for x in lista:
                        if x == alvo:
                            break

                Busca eficiente: para quando encontra.
            
            3) Condicional controla pulo (continue)

                    for x in lista:
                        if x < 0:
                            continue
                        processa(x)

                Filtragem elegante.

            4) Condicional controla processamento

                    for x in lista:
                        if x % 2 == 0:
                            pares += 1
    
                L√≥gica de neg√≥cio dentro do loop.

            5) Condicional decide acumula√ß√£o

                    total = 0
                    for x in lista:
                        if x > 0:
                            total += x

                S√≥ acumula quando faz sentido.

            6) Condicional controla finaliza√ß√£o (for/while else)

                for x in lista:
                    if x == alvo:
                        break
                else:
                    print("N√£o encontrado")

            ERROS CL√ÅSSICOS (LOOP + IF):

                1) Condi√ß√£o errada ‚Üí loop infinito

                        while i < 10:
                            if i == 5:
                                pass
                
                2) if no lugar errado

                        if x > 0:
                            for x in lista:

                    (geralmente o if deveria estar dentro)

                3) break fora do contexto correto

                    sai do loop errado
                    encerra cedo demais

                4) continue pulando atualiza√ß√£o

                        while i < 10:
                            if i == 5:
                                continue
                            i += 1

                    Loop infinito (i nunca muda quando i == 5)

                5) Misturar l√≥gica demais dentro do loop

                    loop vira ‚Äúbola de lama‚Äù
                    dif√≠cil de provar correto

            BOAS PR√ÅTICAS (LOOPS + IF)

                . Prefira for a while
                . Condi√ß√£o de parada clara
                . Atualiza√ß√£o do estado sempre vis√≠vel
                . Use break para encurtar busca
                . Use continue para filtrar
                . Use else para sucesso/falha
                . Se ficou complexo ‚Üí extraia fun√ß√£o

    =====================================================================

    Itera√ß√µes e Iter√°veis:

        - Itera√ß√£o √© o processo de percorrer elementos um a um.
        
        - Iter√°vel √© algo que pode ser percorrido.
        
        - Iterador √© quem faz a itera√ß√£o acontecer.

        Em Python:

            for n√£o percorre diretamente

            Ele usa iteradores

            Isso √© um modelo formal e poderoso

        ITERA√á√ÉO:

            Iterar significa executar um processo repetidamente, avan√ßando 
            passo a passo em uma sequ√™ncia de dados.

            Exemplos de itera√ß√£o:

                . Percorrer uma lista

                . Ler caracteres de uma string

                . Consumir valores de um gerador

                . Avan√ßar em um range
            
            Itera√ß√£o ‚â† repeti√ß√£o cega

            Itera√ß√£o envolve estado + avan√ßo + t√©rmino

        ITER√ÅVEL (Iterable):

            Um iter√°vel √© um objeto que pode fornecer um iterador.

            Formalmente:

                iter√°vel ‚Üí pode ser passado para iter()

            Exemplos de iter√°veis:

                str

                list

                tuple

                set

                dict

                range

                arquivos

                geradores

                    iter("abc")
                    iter([1, 2, 3])

                - Se iter(obj) funciona ‚Üí √© iter√°vel.

            Iter√°vel N√ÉO percorre sozinho:

                    lista = [1, 2, 3]

                . A lista n√£o anda

                . Ela apenas permite ser percorrida

                Quem anda √© o iterador.

        ITERADOR (Iterator):

            - Um iterador √© o objeto que mant√©m o estado da itera√ß√£o.

            Formalmente, um iterador:

                Possui m√©todo __next__()

                Lembra onde parou

                Lan√ßa StopIteration quando acaba

                EX:

                    it = iter([1, 2, 3])

                    next(it)  # 1
                    next(it)  # 2
                    next(it)  # 3
                    next(it)  # StopIteration

                Iterador √© consum√≠vel.

        Iterador ‚â† Iter√°vel (diferen√ßa crucial):

            | Caracter√≠stica      | Iter√°vel | Iterador |
            | ------------------- | -------- | -------- |
            | Pode gerar iterador | Sim      | N√£o      |
            | Mant√©m estado       | N√£o      | Sim      |
            | Pode ser reiniciado | Sim      | N√£o      |
            | Possui `__next__`   | N√£o      | Sim      |

            Um iterador geralmente n√£o pode ser reutilizado.
        
        COMO O for FUNCIONA (POR DENTRO):

            Quando voc√™ escreve:

                for x in lista:
                    ...

            O Python faz (conceitualmente):

                it = iter(lista)
                while True:
                    try:
                        x = next(it)
                    except StopIteration:
                        break
                    ...

            O for √© um while com iterador.

            Isso √© MUITO importante.

        ITERA√á√ÉO EM DIFERENTES TIPOS:

            . String

                    for c in "abc":

                Itera caractere por caractere.

            . Lista

                    for chave in d:

                Itera elemento por elemento.

            . Dicion√°rio

                    for chave in d:

                Itera chaves por padr√£o.

                    for k, v in d.items():

            . Range

                    for i in range(5):

                range √© iter√°vel pregui√ßoso, n√£o lista.

        ITERADORES S√ÉO ESTADO + PROGRESSO

            Exemplo de problema comum:

                it = iter([1, 2, 3])

                for x in it:
                    print(x)

                for x in it:
                    print(x)  # n√£o imprime nada

            O iterador foi consumido.

        FUN√á√ïES RELACIONADAS √Ä ITERA√á√ÉO

            . iter()

                Cria um iterador:

                    iter(obj)

            . next()

                Avan√ßa o iterador:

                    next(it)

            . enumerate()

                Itera com √≠ndice:

                    for i, v in enumerate(lista):

            . zip()

                Itera em paralelo:

                    for a, b in zip(lista1, lista2):

            . any() / all()

                Consomem iter√°veis:

                    any(x > 0 for x in lista)
                    all(x > 0 for x in lista)

        ERROS COMUNS

            . Confundir iter√°vel com iterador
            . Tentar reutilizar iterador consumido
            . Converter tudo para lista sem necessidade
            . Usar √≠ndice quando o for j√° resolve
            . Alterar cole√ß√£o enquanto itera

        DICAS:

            . Pergunte: isso √© iter√°vel ou iterador?
            . Preciso percorrer mais de uma vez? ‚Üí use iter√°vel
            . Quero economizar mem√≥ria? ‚Üí use iterador
            . Quero simplicidade? ‚Üí use for
            . Quero controle fino? ‚Üí use iter + next

        FRASES-CHAVE PARA MEMORIZAR

            Iter√°vel permite
            Iterador percorre
            for consome iterador
            Iterador tem estado
            StopIteration encerra

    =====================================================================

    Fun√ß√µes e lambdas:

        - Fun√ß√£o √© uma unidade de comportamento reutiliz√°vel, que recebe entrada, 
        processa e pode produzir sa√≠da.

        Formalmente:

            . Encapsula l√≥gica
            
            . Reduz repeti√ß√£o
            
            . Controla fluxo
            
            . Cria abstra√ß√£o

        Fun√ß√µes simples:

                def f():
                    bloco

            . N√£o recebe par√¢metros

            . Pode ou n√£o retornar valor

            . Executa uma tarefa espec√≠fica

        Fun√ß√µes com par√¢metros e sem par√¢metros:

            Sem par√¢metros

                def mostrar_menu():

            Com par√¢metros
            
                def soma(a, b):

            Par√¢metros s√£o entradas expl√≠citas do comportamento

        Fun√ß√µes com par√¢metros definidos (default):

                def saudacao(nome="Usu√°rio"):

            Permitem chamadas flex√≠veis

            Devem vir ap√≥s par√¢metros obrigat√≥rios

            Usar defaults reduz quantidade de par√¢metros.
        
        NORMA DE C√ìDIGO LIMPO:

            - Quanto menos par√¢metros, melhor.

            0‚Äì2 ‚Üí ideal

            3 ‚Üí aceit√°vel

            4+ ‚Üí sinal de design ruim

            Muitos par√¢metros indicam:

                . fun√ß√£o fazendo coisas demais

                . falta de encapsulamento

                . necessidade de objeto/dict

        Escopo em Python ‚Äî regra LEGB:

            - Python procura vari√°veis nesta ordem como vimos antes:

                L ‚Üí Local
                E ‚Üí Enclosing
                G ‚Üí Global
                B ‚Üí Built-in

                Isso se chama regra LEGB.

            1. Local (L) ‚Äî dentro da fun√ß√£o:

                    def f():
                        x = 10   # local
                        print(x)

                    f()

                - S√≥ existe dentro da fun√ß√£o

                - N√£o pode ser acessada fora

            2. Enclosing (E) ‚Äî fun√ß√£o dentro de fun√ß√£o:

                    def externa():
                        x = 20  # enclosing

                        def interna():
                            print(x)  # acessa enclosing

                        interna()

                    externa()

                - x n√£o √© local da interna, mas est√° no escopo envolvente 
                (enclosing).

            3. Global (G) ‚Äî topo do c√≥digo (arquivo)

                    x = 30  # global

                    def f():
                        print(x)  # l√™ global

                    f()

                - Fun√ß√µes podem ler vari√°veis globais
                
                - N√£o podem alterar sem global

            4. Built-in (B) ‚Äî nomes do Python

                    print(len([1, 2, 3]))

                . len, print, sum, int etc.

                PS: N√£o sobrescreva isso (p√©ssima ideia). Cuidado com
                sombreamento.

            Como usar vari√°vel do topo (global) dentro de fun√ß√£o:

                Apenas ler ‚Üí funciona direto:

                    x = 5

                    def f():
                        print(x)

                    f()

                Alterar sem global ‚Üí erro

                    x = 5

                    def f():
                        x = x + 1  # UnboundLocalError

            Alterar usando global:

                    x = 5

                    def f():
                        global x
                        x += 1

                    f()
                    print(x)  # 6

                global diz:

                    ‚Äúessa vari√°vel n√£o √© local, use a global‚Äù

            nonlocal ‚Äî quando existe fun√ß√£o dentro de fun√ß√£o:

                Situa√ß√£o:

                    vari√°vel n√£o √© local

                    n√£o √© global

                    est√° na fun√ß√£o externa

                C√≥digo:

                    def externa():
                        x = 10

                        def interna():
                            nonlocal x
                            x += 1

                        interna()
                        print(x)

                    externa()

                Sem nonlocal, isso daria erro.

            - global ‚Üí arquivo inteiro

            - nonlocal ‚Üí fun√ß√£o imediatamente externa

            Fun√ß√£o deve receber dados por par√¢metro e devolver por retorno.
            global e nonlocal s√£o exce√ß√µes, n√£o regra.

        COMPORTAMENTO E FLUXO:

            Fun√ß√µes:

                Criam fronteira de execu√ß√£o

                Controlam in√≠cio, meio e fim

                Facilitam racioc√≠nio local

            O fluxo entra, executa, retorna.

        return:

            - return encerra a fun√ß√£o e devolve um valor.

            Sintaxe:

                return valor

            . Pode haver v√°rios return

            . Usado para controle de fluxo

        return vs print (CRUCIAL):

            | `return`      | `print`          |
            | ------------- | ---------------- |
            | devolve valor | mostra na tela   |
            | afeta fluxo   | efeito colateral |
            | test√°vel      | n√£o test√°vel     |
            | reutiliz√°vel  | n√£o reutiliz√°vel |

            - Fun√ß√µes devem retornar, n√£o imprimir.

        Fun√ß√µes com loops e condicionais:

                def soma_positivos(lista):
                    total = 0
                    for x in lista:
                        if x > 0:
                            total += x
                    return total

            - Fun√ß√£o = comportamento

            - Loop = repeti√ß√£o

            - If = decis√£o

        Fun√ß√µes compostas:

            - Fun√ß√µes que chamam outras fun√ß√µes.

            Ex:

                    def processar():
                        validar()
                        calcular()
                        salvar()

                - Base da arquitetura de software.

        Fun√ß√µes aninhadas:

                def externa():
                    def interna():
                        ...

            . Escopo enclosing

            . Usadas para encapsular l√≥gica auxiliar

        FUN√á√ïES COMO OBJETO:

            - Em Python, fun√ß√µes s√£o objetos de primeira classe.

            Isso significa:

                podem ser atribu√≠das a vari√°veis

                passadas como argumento

                retornadas por outras fun√ß√µes

            Ex:

                f = soma

        CLOSURES:

            Closure = fun√ß√£o + ambiente capturado.

            EX:

                def externa(x):
                    def interna():
                        return x
                    return interna

            - x permanece vivo mesmo ap√≥s externa terminar.

            Usos:

                configura√ß√£o

                encapsulamento

                estado privado

        CURRYING:

            - Transformar fun√ß√£o de m√∫ltiplos par√¢metros em fun√ß√µes parciais.

            EX:

                def soma(a):
                    def soma_b(b):
                        return a + b
                    return soma_b

            Muito usado em programa√ß√£o funcional.

        DECORADORES:

            - Fun√ß√£o que envolve outra fun√ß√£o para modificar comportamento.

            EX:

                @decorador
                def f():

            Conceito:

                fun√ß√£o recebe fun√ß√£o
                retorna nova fun√ß√£o

            Usos:

                logging
                autentica√ß√£o
                cache
                valida√ß√£o

            Decoradores = aplica√ß√£o pr√°tica de closures.

        FUN√á√ïES COMO CALLBACKS:

            - Callback √© uma fun√ß√£o passada como argumento para ser chamada 
            depois.

            Ou seja:

                Voc√™ n√£o executa a fun√ß√£o agora

                Voc√™ entrega o comportamento

                Quem chama decide quando executar

            Invers√£o de controle.

            Pensamento: ‚ÄúN√£o me diga como fazer, diga o que fazer quando algo 
            acontecer.‚Äù

            Exemplo conceitual:

                def processar(valor, acao):
                    return acao(valor)

                def dobrar(x):
                    return x * 2

                processar(10, dobrar)

            dobrar √© callback.

        FUN√á√ïES COMO ESTRAT√âGIAS (Strategy Pattern):

            - Estrat√©gia √© trocar o comportamento sem mudar o c√≥digo que usa.

            Voc√™ tem:

                uma interface de comportamento

                v√°rias implementa√ß√µes

            √â um padr√£o cl√°ssico de design.

            Pensamento: ‚ÄúO algoritmo √© o mesmo, o comportamento muda.‚Äù

            Exemplo conceitual:

                def ordenar(lista, estrategia):
                    return estrategia(lista)

                def crescente(l):
                    return sorted(l)

                def decrescente(l):
                    return sorted(l, reverse=True)

            A estrat√©gia define como ordenar.

            Quando usar:

                regras de neg√≥cio vari√°veis

                c√°lculos diferentes

                pol√≠ticas (pre√ßo, desconto, imposto)

                valida√ß√µes alternativas

        DISPATCH POR FUN√á√ÉO:

            - Dispatch √© escolher qual fun√ß√£o executar com base em uma chave.

            Em vez de:

                if cmd == "add":
                elif cmd == "remove":
                elif cmd == "list":

            Voc√™ usa:

                fun√ß√µes

                mapeamento direto

            Remove condicionais desnecess√°rios.

            Pensamento: ‚ÄúDados escolhem comportamento.‚Äù

            Exemplo conceitual:

                def add():
                    ...

                def remove():
                    ...

                def listar():
                    ...

                acoes = {
                    "add": add,
                    "remove": remove,
                    "list": listar
                }

                acoes[cmd]()

            Isso √© dispatch por fun√ß√£o.

        FUN√á√ïES GERADORAS (yield):

            - Produzem valores sob demanda.

            EX:

                def gerador():
                    yield valor

            . Retornam iterador

            . Mant√™m estado interno

            . Muito eficientes em mem√≥ria

            yield pausa a fun√ß√£o.

        *args e **kwargs:

            . *args

                - argumentos posicionais vari√°veis

                    def f(*args):

            . **kwargs

                - argumentos nomeados vari√°veis

                    def f(**kwargs):

            Use com modera√ß√£o.

        LAMBDAS (lambda):

            - Lambda √© uma fun√ß√£o an√¥nima de express√£o √∫nica.

            - Lambda n√£o substitui fun√ß√£o.

            - Lambda remove ru√≠do quando o comportamento √© simples.

            Sintaxe:

                lambda x: x + 1

            COMPORTAMENTO E FLUXO

                . Executa express√£o

                . Retorna valor automaticamente

                . N√£o tem return expl√≠cito

                . N√£o tem bloco

            Lambda com par√¢metros e sem par√¢metros:

                lambda: 10
                lambda x: x * 2
                lambda x, y: x + y

            NORMA DE C√ìDIGO LIMPO (LAMBDA)

                - Se n√£o cabe em uma linha clara, n√£o √© lambda.

                Lambdas complexas s√£o m√° pr√°tica.

            Lambda com par√¢metros definidos (default):

                lambda x=10: x * 2

            Lambda key (uso mais comum):

                    sorted(lista, key=lambda x: x.valor)

                - Essencial para ordena√ß√£o e agrupamento.

            Lambda com condicionais:

                    lambda x: x if x > 0 else 0

                - Forma tern√°ria apenas.

                - N√£o existe loop em lambda. Se precisar de loop ‚Üí use def.

            Lambda funcional:

                Usadas com:

                    map
                    filter
                    sorted
                    min, max

                EX:

                    map(lambda x: x*2, lista)

            FUN√á√ïES INLINE:

                - Fun√ß√£o inline √© um comportamento definido no ponto de uso,
                sem nome.

                EX:

                    sorted(lista, key=lambda x: x.idade)

                . N√£o merece um def

                . Usada uma √∫nica vez

                . Express√£o simples

                Lambda = fun√ß√£o inline por natureza.

                PS: Se voc√™ precisa pensar para ler ‚Üí n√£o √© inline.

            ESTRAT√âGIAS R√ÅPIDAS:

                - Estrat√©gia r√°pida √© trocar comportamento sem criar v√°rias 
                fun√ß√µes nomeadas.

                    EX:

                        operacao = lambda a, b: a + b

                    Depois:

                        operacao = lambda a, b: a * b

                Estrat√©gia definida no local.

            CALLBACKS SIMPLES:

                - Callback simples √© um comportamento pequeno passado para ser 
                executado depois.

                EX:

                    processar(lista, lambda x: x > 0)

                Mental: ‚ÄúQuando isso acontecer, fa√ßa isso.‚Äù

                Exemplo cl√°ssico:

                    filter(lambda x: x % 2 == 0, lista)

            ADAPTA√á√ÉO DE INTERFACE:

                - Adapter com lambda ajusta uma fun√ß√£o ao formato esperado por 
                outra.

                Voc√™ tem:

                    def soma(a, b):
                        return a + b

                Mas precisa de:

                    f(x)

                Solu√ß√£o:

                    f = lambda x: soma(x, 10)

                Lambda atua como adaptador.

        ERROS COMUNS

            Lambdas longas

            Lambdas com efeitos colaterais

            Usar lambda no lugar de def complexo

            Fun√ß√£o com muitos par√¢metros

            Confundir print com retorno

        FRASES-CHAVE PARA MEMORIZAR

            . Fun√ß√£o √© comportamento
            . return encerra
            . Fun√ß√£o √© objeto
            . Closure captura estado
            . Decorador envolve
            . Lambda √© express√£o

    =====================================================================

    Recurs√µes:

        Resolver um problema chamando o pr√≥prio problema

        - Recurs√£o √© uma t√©cnica em que uma fun√ß√£o chama a si mesma para 
        resolver um problema menor do mesmo tipo.

        Toda recurs√£o correta tem:

            1. Caso base ‚Üí quando parar

            2. Caso recursivo ‚Üí chamada para um problema menor

            3. Progresso ‚Üí cada chamada se aproxima do caso base

            Se faltar qualquer um ‚Üí bug.

        COMO A RECURS√ÉO FUNCIONA (POR DENTRO):

            Exemplo conceitual:

                f(3)
                ‚îî‚îÄ f(2)
                    ‚îî‚îÄ f(1)
                        ‚îî‚îÄ f(0)  ‚Üê caso base

            . Cada chamada cria um novo frame na pilha (stack)

            . Vari√°veis s√£o locais √†quela chamada

            . Quando o caso base retorna, a pilha desempilha

            Isso se chama call stack.
        
        CALL STACK (PILHA DE EXECU√á√ÉO):

            . Estrutura LIFO (Last In, First Out)

            . Cada chamada ocupa mem√≥ria

            . Python n√£o otimiza tail recursion

            Recurs√£o profunda ‚Üí risco real.

        STACK OVERFLOW:

            - Stack overflow ocorre quando a recurs√£o cria chamadas demais
            antes de retornar.

            Causas:

                . caso base inexistente
                . caso base errado
                . problema grande demais
                . recurs√£o infinita

            Exemplo cl√°ssico de erro:

                def f(n):
                    return f(n + 1)

            Em Python:

                RecursionError: maximum recursion depth exceeded

        QUANDO USAR RECURS√ÉO (E QUANDO N√ÉO):

            Use recurs√£o quando:

                problema √© naturalmente recursivo

                estrutura em √°rvore

                divis√£o em subproblemas claros

                clareza > performance

            Evite recurs√£o quando:

                h√° la√ßo simples equivalente

                profundidade pode ser grande

                performance e mem√≥ria s√£o cr√≠ticas

            Em Python, loops geralmente s√£o melhores.

        T√âCNICAS E ESTRAT√âGIAS DE RECURS√ÉO:

            1. Recurs√£o direta simples

                - A fun√ß√£o chama a si mesma.

                Exemplo conceitual:

                    f(n) = f(n-1)

                Usos:

                    fatorial

                    soma

                    contagem

            2. Recurs√£o linear

                - Uma chamada recursiva por execu√ß√£o.

                EX:

                    f(n) ‚Üí f(n-1)

                Profundidade = n

            3. Recurs√£o m√∫ltipla (ramificada)

                - Mais de uma chamada recursiva.

                Ex:

                    f(n) ‚Üí f(n-1) + f(n-2)

                . Crescimento exponencial

                . Cuidado com performance

            4. Recurs√£o em estruturas:

                Muito comum em:

                    listas aninhadas

                    √°rvores

                    dicion√°rios aninhados

                EX:

                    processa(no):
                        para cada filho:
                            processa(filho)

            5. Dividir para conquistar

                - Quebra o problema em partes.

                Exemplos:

                    busca bin√°ria

                    merge sort

                    quicksort

            6. Recurs√£o com acumulador (quase tail recursion)

                EX:

                    f(n, acc)

                . reduz trabalho p√≥s-retorno

                . Python n√£o otimiza, mas melhora clareza

        RECURS√ÉO ‚Äî COMPLEMENTOS ESSENCIAIS:

            - Toda recurs√£o √© um if disfar√ßado.

            A forma geral √©:

                if caso_base:
                    return valor
                else:
                    return chamada_recursiva(...)

            - Sem if ‚Üí n√£o existe parada ‚Üí loop infinito na stack.

            . Caso base √© uma condi√ß√£o:

                if n == 0:
                    return 1

            . Caso recursivo √© outra condi√ß√£o

                return n * f(n - 1)

            Recurs√£o √© controle de fluxo condicional, n√£o m√°gico.

            RECURS√ÉO √ó LOOPS (RELA√á√ÉO REAL):

                - Recurs√£o substitui loops, mas n√£o elimina repeti√ß√£o.

                . N√£o use loop para SIMULAR a recurs√£o

                . Use loop para ITERAR n√≠veis, e recurs√£o para ESTRUTURA

                Conceitualmente:

                    for / while ‚Üí repeti√ß√£o expl√≠cita

                    recurs√£o ‚Üí repeti√ß√£o impl√≠cita via chamadas

                    Exemplo mental:

                        for i in range(n):

                    ‚âà

                        f(n):
                            f(n-1)

                Cada chamada equivale a uma itera√ß√£o.

                N√ÉO misture loop e recurs√£o sem motivo:

                        def f(n):
                            for i in range(n):
                                f(i)

                    PS: Complexidade explode

                    - Use uma t√©cnica por vez, salvo casos espec√≠ficos.

            return EM RECURS√ÉO (PONTO CRUCIAL):

                - Em recurs√£o, return n√£o √© opcional.

                Erro comum:

                        def f(n):
                            if n == 0:
                                return
                            f(n - 1)

                    - Retorna None

                    - Resultado in√∫til

                Forma correta:

                        def f(n):
                            if n == 0:
                                return 0
                            return 1 + f(n - 1)

                    - Cada chamada deve retornar algo para a anterior.

            PAR√ÇMETRO AUXILIAR:

                - √© um par√¢metro acumulador ou par√¢metro de controle.

                Tamb√©m conhecido como:

                    . √≠ndice de progresso

                    . estado da recurs√£o

                    . contador recursivo

                    Ele representa onde a recurs√£o est√°.

                . EX Forma conceitual:

                        soma(lista, i):
                            se i chegou no fim:
                                retorna 0
                            sen√£o:
                                retorna lista[i] + soma(lista, i+1)

                    Esse padr√£o √© chamado de:

                        recurs√£o com estado expl√≠cito

            RECURS√ÉO COM ACUMULADOR:

                Outro padr√£o cl√°ssico:

                    def soma_lista(lista, i=0, total=0):

                . i ‚Üí controle
                . total ‚Üí acumulador

                Equivale a:

                    total = 0
                    for x in lista:
                        total += x

            T√âCNICA: DIVIDIR E CONQUISTAR:

                - Dividir e conquistar quebra o problema em partes 
                independentes, resolve cada parte e combina os resultados.

                Estrutura formal:

                    Dividir o problema

                    Resolver subproblemas

                    Combinar resultados

                . Exemplo conceitual (soma)

                    soma(lista):
                        divide em duas metades
                        soma_esq = soma(esq)
                        soma_dir = soma(dir)
                        retorna soma_esq + soma_dir

                Profundidade menor que recurs√£o linear.


        ERROS COMUNS EM RECURS√ÉO

            . esquecer o caso base
            . caso base nunca ser alcan√ßado
            . mudar vari√°vel errada
            . retornar antes da recurs√£o
            . achar que recurs√£o √© sempre melhor
            . confundir recurs√£o com loop

        DICAS:

            . Defina o caso base primeiro
            . Pergunte: qual √© a vers√£o menor do problema?
            . Cada chamada deve reduzir o problema
            . Teste manualmente com n = 0, 1, 2
            . Desenhe a √°rvore de chamadas
            . Se ficou confuso ‚Üí escreva vers√£o iterativa

        FRASES-CHAVE PARA MEMORIZAR

            Caso base manda
            Problema menor a cada passo
            Stack cresce
            Python n√£o otimiza tail recursion
            Recurs√£o √© modelo mental
            Loop percorre n√≠vel
            Recurs√£o percorre profundidade
            N√£o simule recurs√£o com loop
            Use loop dentro da recurs√£o, n√£o o contr√°rio

    =====================================================================

    tabelas de decis√£o:

        - Tabela de decis√£o √© uma estrutura que mapeia combina√ß√µes de 
        condi√ß√µes ‚Üí a√ß√µes.

        Em vez de:

            . muitos if / elif / else

            . l√≥gica espalhada

        Voc√™ tem:

            . regras expl√≠citas

            . decis√£o orientada a dados

            . baixo acoplamento

        √â uma t√©cnica de design, n√£o apenas de c√≥digo.

        O PROBLEMA QUE A TABELA DE DECIS√ÉO RESOLVE:

            Considere l√≥gica assim:

                if A and B:
                elif A and not B:
                elif not A and B:
                else:

            Isso gera:

                . explos√£o combinat√≥ria

                . c√≥digo dif√≠cil de manter

                . bugs silenciosos

                Tabela de decis√£o resolve isso.

        O QUE √â UMA TABELA DE DECIS√ÉO (FORMALMENTE):

            Uma tabela de decis√£o possui:

                1. Condi√ß√µes (entradas)

                2. Combina√ß√µes poss√≠veis

                3. A√ß√£o associada a cada combina√ß√£o

            Matematicamente:

                (condi√ß√£o1, condi√ß√£o2, ..., condi√ß√£oN) ‚Üí a√ß√£o

        MODELO MENTAL CORRETO:

            - Dados escolhem comportamento.

            Voc√™ n√£o pergunta:

                ‚ÄúQual if eu escrevo agora?‚Äù

            Voc√™ pergunta:

                ‚ÄúQuais estados existem e o que deve acontecer em cada um?‚Äù

        TABELA DE DECIS√ÉO EM PYTHON (FORMA NATURAL):

            Em Python, a forma mais comum √©:

                - dict

                - chaves compostas (tuple)

                - valores como fun√ß√µes ou resultados

            . Exemplo conceitual simples

                Regras:

                    usu√°rio vip?

                    possui cart√£o?

                | VIP | Cart√£o | A√ß√£o                |
                | --- | ------ | ------------------- |
                | Sim | Sim    | desconto_vip_cartao |
                | Sim | N√£o    | desconto_vip        |
                | N√£o | Sim    | desconto_cartao     |
                | N√£o | N√£o    | sem_desconto        |

            Representa√ß√£o:

                tabela = {
                    (True, True): acao1,
                    (True, False): acao2,
                    (False, True): acao3,
                    (False, False): acao4
                }

            Isso √© uma tabela de decis√£o expl√≠cita.

        TABELA DE DECIS√ÉO √ó IF/ELIF:

            | Crit√©rio       | `if/elif` | Tabela  |
            | -------------- | --------- | ------- |
            | Clareza        | M√©dia     | Alta    |
            | Escalabilidade | Baixa     | Alta    |
            | Manuten√ß√£o     | Dif√≠cil   | F√°cil   |
            | Testes         | Complexos | Simples |
            | Extens√£o       | Perigosa  | Segura  |

            Quanto mais regras ‚Üí mais a tabela vence.

        QUANDO USAR TABELA DE DECIS√ÉO:

            Use quando:

                . h√° muitas combina√ß√µes
                . regras s√£o est√°veis
                . l√≥gica √© determin√≠stica
                . regras s√£o parte do neg√≥cio

            Exemplos reais:

                . regras de desconto
                . permiss√µes
                . valida√ß√µes
                . impostos
                . workflows

        QUANDO N√ÉO USAR:

            N√£o use quando:

                . l√≥gica depende de sequ√™ncia temporal
                . decis√µes s√£o probabil√≠sticas
                . regras mudam durante execu√ß√£o
                . poucas condi√ß√µes simples

            N√£o √© bala de prata.
        
        TABELA DE DECIS√ÉO + FUN√á√ïES:

            A√ß√£o n√£o precisa ser valor ‚Äî pode ser fun√ß√£o.

                tabela[(True, False)]()

            Isso une:

                tabela de decis√£o

                dispatch por fun√ß√£o

                estrat√©gia

        TABELA DE DECIS√ÉO PARCIAL:

            - Nem todas as combina√ß√µes precisam existir.

                tabela.get(chave, acao_padrao)

            Isso substitui else.

        ERROS COMUNS:

            . chaves mal definidas
            . duplicar l√≥gica dentro das a√ß√µes
            . misturar regra com execu√ß√£o
            . usar tabela para l√≥gica sequencial
            . n√£o tratar caso padr√£o

        DICAS:

            . Liste todas as condi√ß√µes
            . Liste todos os estados poss√≠veis
            . Defina a a√ß√£o de cada estado
            . Crie chave composta (tuple)
            . Separe decis√£o de execu√ß√£o
            . Teste cada linha da tabela

        FRASES-CHAVE PARA MEMORIZAR:

            Regra vira dado
            Dado escolhe a√ß√£o
            Menos ifs, mais clareza
            Tabela escala melhor

    =====================================================================

    Operadores bit-wise:

        - Pensando como o computador

        - Operadores bit-wise operam diretamente nos bits (0 e 1) de um n√∫mero 
        inteiro.

        Eles n√£o trabalham com valores, mas com a representa√ß√£o bin√°ria do valor.

        BIN√ÅRIO, VERDADE E FALSO:

            No n√≠vel mais baixo:

                0 ‚Üí False

                1 ‚Üí True

            Mas aten√ß√£o:

                Em bit-wise, cada bit √© avaliado individualmente, n√£o o n√∫mero 
                inteiro.

            Exemplo:

                6  ‚Üí 110
                3  ‚Üí 011

            Cada coluna √© uma ‚Äúverdade‚Äù independente.

        OPERADORES BIT-WISE EM PYTHON:

            | Operador | Nome        | Leitura            |
            | -------- | ----------- | ------------------ |
            | `&`      | AND         | e                  |
            | `|`      | OR          | ou                 |
            | `^`      | XOR         | ou exclusivo       |
            | `~`      | NOT         | nega√ß√£o            |
            | `<<`     | SHIFT LEFT  | desloca √† esquerda |
            | `>>`     | SHIFT RIGHT | desloca √† direita  |

        . 1) AND (&)

            Regra l√≥gica

                1 & 1 = 1
                1 & 0 = 0
                0 & 1 = 0
                0 & 0 = 0

            C√°lculo bit a bit:

                6  = 110
                3  = 011
                ---------
                &  = 010  ‚Üí 2

            Interpreta√ß√£o:

                O bit s√≥ √© 1 se ambos forem 1.

        . 2) OR (|)

            Regra l√≥gica

                1 | 1 = 1
                1 | 0 = 1
                0 | 1 = 1
                0 | 0 = 0

            C√°lculo:

                6  = 110
                3  = 011
                ---------
                |  = 111 ‚Üí 7

            Interpreta√ß√£o

                O bit √© 1 se qualquer um for 1.

        . 3) XOR (^) ‚Äî OU EXCLUSIVO:

            Regra l√≥gica:

                1 ^ 1 = 0
                1 ^ 0 = 1
                0 ^ 1 = 1
                0 ^ 0 = 0

            C√°lculo:

                6  = 110
                3  = 011
                ---------
                ^  = 101 ‚Üí 5

            Interpreta√ß√£o

                O bit √© 1 somente se forem diferentes.

        . 4) NOT (~):

            Regra l√≥gica:

                ~1 = 0
                ~0 = 1

            Mas em Python:

                ~x == -(x + 1)

            Exemplo:

                ~5   # -6

            Por qu√™?

                Python usa complemento de dois, com tamanho infinito de bits.

        . 5) SHIFT LEFT (<<)

            Desloca bits para a esquerda (multiplica por 2‚Åø).

            EX:

                3 = 011
                3 << 1 = 110 ‚Üí 6
                3 << 2 = 1100 ‚Üí 12

                3 << 1  # 6
                3 << 2  # 12

            Regra matem√°tica:

                x << n = x * (2‚Åø)

        . 6) SHIFT RIGHT (>>)

            Desloca bits para a direita (divide por 2‚Åø).

            EX:

                8 = 1000
                8 >> 1 = 0100 ‚Üí 4
                8 >> 2 = 0010 ‚Üí 2

                8 >> 1  # 4

            Regra matem√°tica:

                x >> n = x // (2‚Åø)

        BIT-WISE √ó OPERADORES L√ìGICOS:

            | Tipo     | Operador           | Atua sobre  |
            | -------- | ------------------ | ----------- |
            | L√≥gico   | `and`, `or`, `not` | valores     |
            | Bit-wise | `&`, `|`, `^`, `~` | bits        |

            Erro comum:

                if x & y:   # bit-wise
                if x and y: # l√≥gico

            S√£o coisas diferentes.

        USO COM CONDICIONAIS (FLAGS):

            READ  = 0b001
            WRITE = 0b010
            EXEC  = 0b100

            permissao = READ | WRITE

        Verificar permiss√£o:

            if permissao & READ:
                print("Pode ler")

        Isso √© bit-masking.

        USO COM match:

            match permissao:
                case p if p & READ and p & WRITE:
                    print("Leitura e escrita")
                case p if p & READ:
                    print("Somente leitura")

        match + bit-wise = leitura expressiva.

        USO COM LOOPS:

            - Iterar bits de um n√∫mero

                n = 13  # 1101
                while n:
                    print(n & 1)
                    n >>= 1

        USO COM FUN√á√ïES:

            Verificar se n√∫mero √© par:

                def eh_par(n):
                    return (n & 1) == 0

            Mais baixo n√≠vel que:

                n % 2 == 0

        EXEMPLOS LEGAIS (CL√ÅSSICOS):

            1. Testar se √© pot√™ncia de 2

                def potencia_de_dois(n):
                    return n > 0 and (n & (n - 1)) == 0

            2. Contar bits 1

                def conta_bits(n):
                    count = 0
                    while n:
                        count += 1
                        n &= n - 1
                    return count

            3. Flags com enumera√ß√£o

                FLAG_A = 1 << 0
                FLAG_B = 1 << 1
                FLAG_C = 1 << 2

        O QUE S√ÉO ESSES BIN√ÅRIOS DE SA√çDA?

            - Eles s√£o novos estados compostos.

            Eles N√ÉO s√£o:

                n√∫meros m√°gicos

                valores arbitr√°rios

            Eles S√ÉO:

                representa√ß√µes compactas de m√∫ltiplas verdades independentes

        MODELO MENTAL CORRETO (MUITO IMPORTANTE):

            Pense assim:

                Cada bit = uma pergunta SIM / N√ÉO

            Exemplo:

                bit 0 ‚Üí pode ler?
                bit 1 ‚Üí pode escrever?
                bit 2 ‚Üí pode executar?

            Ent√£o:

                6 = 110 ‚Üí escrever + executar
                3 = 011 ‚Üí ler + escrever

                Bits n√£o t√™m significado natural.
                O significado √© voc√™ quem define.

                . OS BITS N√ÉO ‚ÄúSABEM‚Äù O QUE √â LER OU ESCREVER

                    O n√∫mero 6 = 110 significa apenas:

                        bit2  bit1  bit0
                        1     1     0

                    Isso √© tudo que o computador sabe.

                    ‚Äúler‚Äù, ‚Äúescrever‚Äù, ‚Äúexecutar‚Äù n√£o existem no n√∫mero.
                    Eles surgem quando voc√™ define uma conven√ß√£o.

                . A CONVEN√á√ÉO PRECISA SER FIXA

                    Quando eu escrevi:

                        bit 0 ‚Üí ler
                        bit 1 ‚Üí escrever
                        bit 2 ‚Üí executar

                    isso foi uma escolha arbitr√°ria, mas consistente.

                    Vamos escrever isso formalmente:

                        LER       = 1 << 0  # 001
                        ESCREVER  = 1 << 1  # 010
                        EXECUTAR  = 1 << 2  # 100

                    Agora sim temos um dicion√°rio de significado.

                . AGORA VAMOS REFAZER OS EXEMPLOS SEM AMBIGUIDADE

                    . N√∫mero 6

                        6 = 110

                    Bits ligados:

                        bit1 (010) ‚Üí ESCREVER

                        bit2 (100) ‚Üí EXECUTAR

                    6 = escrever + executar
                
                . N√∫mero 3

                    3 = 011

                Bits ligados:

                    bit0 (001) ‚Üí LER

                    bit1 (010) ‚Üí ESCREVER

                3 = ler + escrever

                . POR QUE 6 N√ÉO √â ‚ÄúLER + ESCREVER‚Äù?

                    Porque o bit de LER √© o bit 0, e no n√∫mero 6 ele est√° 
                    desligado:

                        6 = 110
                                ‚Üë
                              bit0 = 0  ‚Üí n√£o l√™

                    J√° no n√∫mero 3:

                        3 = 011
                                ‚Üë
                            bit0 = 1  ‚Üí l√™

                O ERRO MAIS COMUM (E FOI ESSE O SEU INC√îMODO):

                    Pensar que ‚Äúposi√ß√£o visual‚Äù do bit define significado.

                    ERRADO:

                        110 ‚Üí ‚Äúos dois primeiros‚Äù

                    CERTO:

                        cada posi√ß√£o = uma pot√™ncia de 2 fixa

                - Bit n√£o √© r√≥tulo.
                - Bit √© posi√ß√£o.
                - O significado vem da constante associada.

            Agora veja:

                AND (&):

                    comum aos dois ‚Üí escrever

                OR (|)

                    tudo que qualquer um pode ‚Üí ler + escrever + executar

                XOR (^)

                    o que s√≥ um deles pode ‚Üí ler + executar

            Isso √© l√≥gica de estados, n√£o matem√°tica comum.


        ERROS COMUNS

            . confundir & com and
            . usar bit-wise com floats
            . usar ~ sem entender complemento de dois
            . esquecer preced√™ncia (& < ==)
            . achar que bit-wise substitui l√≥gica comum

        DICAS:

            Pense em bits, n√£o em n√∫meros
            Use bit-wise quando:
                estados s√£o combin√°veis
                flags independentes
                performance importa
            Use m√°scaras para clareza
            Prefira nomes sem√¢nticos (READ, WRITE)
            Teste com bin√°rio (bin(x))

        FRASES-CHAVE PARA MEMORIZAR:

            Bit-wise √© l√≥gica por bit
            AND restringe
            OR ativa
            XOR alterna
            Shift multiplica/divide por 2
            Flags simplificam decis√µes
            Operadores bit-wise n√£o produzem n√∫meros.
            Eles produzem estados.

    =====================================================================

    Listas, Arrays e Vetores:

        - Estrutura de dados que armazena m√∫ltiplos valores em sequ√™ncia,
        acessados por √≠ndice.

        . Em Python

            . list √© a estrutura nativa

            . √â:

                ordenada

                mut√°vel

                heterog√™nea

                din√¢mica

        Python n√£o tem array fixo nativo como C.

        Para arrays num√©ricos reais: array, numpy (outro assunto).

        CRIA√á√ÉO DE LISTAS:

            lista = []
            lista = [1, 2, 3]
            lista = list(range(5))

        √çNDICES:

            √çndices come√ßam em 0

            √çndices negativos contam do final

                lista[0]    # primeiro
                lista[-1]   # √∫ltimo

            √çndice inv√°lido ‚Üí IndexError

        ACESSO A ELEMENTOS:

            leitura

            constante O(1)

        MODIFICANDO ELEMENTOS:

                lista[0] = 10

            Lista √© mut√°vel.

        SWAP COM LISTAS:

                lista[i], lista[j] = lista[j], lista[i]

            Swap nativo, sem vari√°vel auxiliar.

        TAMANHO DA LISTA:

            len(lista)

        SLICING:

                lista[inicio:fim:passo]

            Exemplos:

                lista[:3]
                lista[2:]
                lista[::-1]

            Slicing cria nova lista.

        C√ìPIA DE LISTA vs ENDERE√áAMENTO:

            Refer√™ncia (mesmo objeto):

                lista = [1, 2, 3]
                listab = lista

            C√≥pia rasa:

                lista = [1, 2, 3]
                listab = lista[:]
                listab = lista.copy()

            Modificar b n√£o afeta a.

        LISTA COM OPERADORES:

                [1, 2] + [3, 4]     # concatena
                [0] * 5             # repete

            - + cria nova lista

            - * replica refer√™ncias (cuidado com listas aninhadas)

        LISTA COM CONDICIONAIS:

                for x in lista:
                    if x > 0:
                        ...

            Muito comum em filtragem.

        LISTA COM LOOPS:

            FOR:

                    for x in lista:

                Com √≠ndice:

                    for i in range(len(lista)):

                Melhor:

                    for i, v in enumerate(lista):

            while:

                i = 0
                while i <= len(lista):

        LISTA COM N√öMEROS

            Usos comuns:

                soma

                m√©dia

                m√°ximo

                m√≠nimo

                contagem

        LISTA COM STRINGS

                nomes = ["Ana", "Jo√£o"]

            Comuns:

                normaliza√ß√£o

                busca

                compara√ß√£o

                parsing

        in / not in vs is / is not:

            . in: Verifica valor

                x in lista

            . is: Verifica objeto. Nunca use is para comparar valores de lista.

                x is y

        sort vs sorted:

            - Ordenam a lista

            . sort()

                    lista.sort()
                    lista.sort(reverse=True)

                . modifica a lista

                . retorna None

            . sorted()

                    nova = sorted(lista)
                    nova = sorted(lista, reverse=True)

                . cria nova lista

                . original intacta

        index:

                lista.index(valor)

            . retorna √≠ndice

            . erro se n√£o existir

        min e max:

            min(lista)  # Menor valor
            max(lista)  # Maior valor

        sum: Apenas para n√∫meros.

            sum(lista)  # Soma o conte√∫do da lista

        count:

            Faz contagem de um elemento na lista

            PS: √â usado com strings e outros iter√°veis tamb√©m

                lista.count(valor)

        reverse:

                lista.reverse()

            . In-place

            . Diferente de lista[::-1]

        zip:

                zip(lista1, lista2)

            . itera√ß√£o paralela

            . gera tuplas

        enumerate:

                enumerate(lista)

            . √≠ndice + valor

            . padr√£o profissional

        append, insert, extend, concatena√ß√£o:

            append: Adiciona no final daa lista

                lista.append(x)

            insert: Adiciona em uma posi√ß√£o espec√≠fica da lista.
            PS: Fica inificiente em rela√ß√£o a posi√ß√£o escolhidas e tamanho da
            lista, pois ele movimenta os dados para o pr√≥ximo ap√≥s a inser√ß√£o

                lista.insert(i, x)

            extend: Funde uma lista na outra

                lista.extend(outra)

            concatena√ß√£o: Junta uma lista na outra

                lista + outra

        REPETI√á√ÉO DE ELEMENTOS:

                [0] * 5

            PS: Cuidado com listas aninhadas:

                [[0]*3]*3  # errado

        REMO√á√ÉO: pop, remove, del:

            pop: Remove um valor por √≠ndice escolhido

                lista.pop()  # Padr√£o sempre o √∫ltimo
                lista.pop(i)

            remove: Remove por valor

                lista.remove(valor)

            del: Forma alternativa de remover um item. Mas cuidado,
            se voc√™ dar um del lista sem especificar o item, apagar√° a 
            refer√™ncia inteira da lista.

                del lista[i]

        EMPACOTAMENTO E DESEMPACOTAMENTO:

                a, b = [1, 2]

            Com estrela: Pega todo o resto

                a, *resto = [1, 2, 3, 4]

        OUTRAS PROPRIEDADES E T√âCNICAS:

            . Lista √© heterog√™nea

                [1, "a", True]

            . Lista √© din√¢mica

                cresce

                diminui

            . Lista pode conter listas

                matriz = [[1,2],[3,4]]

            . Percurso seguro:

                for x in lista[:]:

        ERROS COMUNS:

            . confundir c√≥pia com refer√™ncia
            . usar is em vez de ==
            . modificar lista enquanto itera
            . usar √≠ndice quando n√£o precisa
            . esquecer que sort() n√£o retorna lista

        DICAS:

            Precisa de ordem? ‚Üí lista
            Precisa mudar valores? ‚Üí lista
            Precisa percorrer? ‚Üí for ou while dependendo da situa√ß√£o
            Precisa √≠ndice? ‚Üí enumerate
            Precisa c√≥pia? ‚Üí copy()
            Muito if? ‚Üí refatorar

        FRASES-CHAVE PARA MEMORIZAR:

            Lista √© mut√°vel
            √çndice come√ßa em zero
            Slicing copia
            sort modifica
            sorted cria nova
            in verifica valor

    =====================================================================

    Indices:

        √çndice √© a posi√ß√£o num√©rica que identifica um elemento dentro de uma 
        estrutura sequencial.

        - √çndice = deslocamento (offset) a partir de um endere√ßo base

        - Permite acesso direto a elementos

        Sem √≠ndice, estruturas sequenciais n√£o seriam eficientes.

        USO DE √çNDICES:

            - Acesso direto (O(1))

                    lista[i]

                . O computador n√£o percorre a lista

                . Ele calcula o endere√ßo diretamente

                Isso √© acesso de tempo constante.

            . Escrita / modifica√ß√£o

                Motivo hist√≥rico e t√©cnico:

                    Em mem√≥ria:

                        endere√ßo = base + √≠ndice * tamanho_do_elemento

                    Se √≠ndice come√ßa em 0:

                        primeiro elemento ‚Üí deslocamento zero

                        c√°lculo mais simples

                        hardware agradece

                        Isso vem de C, assembly e arquitetura de CPU.

            . FUNCIONAMENTO NA MEM√ìRIA

                Suponha:

                    . lista come√ßa no endere√ßo 1000

                    . cada elemento ocupa 8 bytes

                    | √çndice | Endere√ßo |
                    | ------ | -------- |
                    | 0      | 1000     |
                    | 1      | 1008     |
                    | 2      | 1016     |
                    | 3      | 1024     |

                F√≥rmula:

                    endere√ßo = base + √≠ndice √ó tamanho

                √â por isso que lista[i] √© r√°pido.

        √çNDICE ‚â† CONTE√öDO:

            O √≠ndice n√£o √© o valor.

                lista = [10, 20, 30]

            . √≠ndice 1 ‚Üí valor 20

            . √≠ndice √© posi√ß√£o, n√£o dado

            Confundir isso gera bugs cl√°ssicos.

        √çNDICES NEGATIVOS (PYTHON):

                lista[-1]

            Significa:

                lista[len(lista) - 1]

            √â um atalho sem√¢ntico, n√£o algo m√°gico.

            Na mem√≥ria:

                . o Python ajusta o √≠ndice

                . converte para positivo

                . acessa normalmente

        √çNDICES E LIMITES:

            . Erro cl√°ssico

                lista[len(lista)]

            - √∫ltimo √≠ndice v√°lido √© len(lista) - 1

            - len(lista) √© fora do intervalo

            Gera IndexError.

        APLICA√á√ïES DE √çNDICES:

            . Percurso manual

                    i = 0
                    while i < len(lista):
                        ...
                        i += 1

                - √çndice atua como estado do loop.

            . Compara√ß√£o entre elementos

                    lista[i] > lista[i+1]

                - Base de algoritmos de ordena√ß√£o.

            . Sincroniza√ß√£o entre listas

                lista1[i], lista2[i]

        T√âCNICAS DE USO COM √çNDICES:

            . T√©cnica 1 ‚Äî Dois √≠ndices (two pointers)

                    i = 0
                    j = len(lista) - 1

                Usos:

                    . invers√£o

                    . verifica√ß√£o de pal√≠ndromo

                    . parti√ß√µes

                    Muito comum em entrevistas.

            . T√©cnica 2 ‚Äî √çndice como estado

                    def f(lista, i=0):

                . i indica progresso

                . comum em recurs√£o

                i = par√¢metro de controle.

            . T√©cnica 3 ‚Äî √çndice + condi√ß√£o

                    for i in range(len(lista)):
                        if i % 2 == 0:
                            ...

                Usos:

                    posi√ß√µes pares/√≠mpares

                    padr√µes

            . T√©cnica 4 ‚Äî √çndice com deslocamento

                    lista[i+k]

                Usos:

                    janelas deslizantes

                    an√°lise local

            . T√©cnica 5 ‚Äî enumerate (√≠ndice seguro)

                    for i, v in enumerate(lista):

                .  Mais leg√≠vel
                .  Menos erro
                .  Padr√£o profissional

            . T√©cnica 6 ‚Äî Swap por √≠ndice

                    lista[i], lista[j] = lista[j], lista[i]

                Base de:

                    ordena√ß√£o

                    rearranjos

        √çNDICES E PERFORMANCE:

            | Opera√ß√£o               | Complexidade |
            | ---------------------- | ------------ |
            | acesso `lista[i]`      | O(1)         |
            | modifica√ß√£o `lista[i]` | O(1)         |
            | inser√ß√£o no meio       | O(n)         |
            | remo√ß√£o no meio        | O(n)         |

            √çndices s√£o r√°pidos, movimenta√ß√£o n√£o.

        ERROS COMUNS COM √çNDICES:

            . off-by-one (+1 ou -1 errado)

            . usar √≠ndice quando n√£o precisa

            . modificar lista enquanto itera

            . confundir √≠ndice com valor

            . acessar fora do limite

        DICAS:

            Sempre pense: intervalo v√°lido √© [0, len-1]

            √öltimo elemento ‚Üí len - 1

            Prefira enumerate

            Use dois √≠ndices quando houver simetria

            Se ficou confuso ‚Üí desenhe os √≠ndices

            √çndice √© matem√°tica, n√£o tentativa

        FRASES-CHAVE PARA MEMORIZAR:

            √çndice √© deslocamento
            Come√ßa em zero por efici√™ncia
            Acesso √© constante
            Valor ‚â† posi√ß√£o
            enumerate √© seu amigo

    =====================================================================

    In place:

        - Um algoritmo ou opera√ß√£o √© in place quando modifica os dados 
        diretamente na estrutura original, usando pouca ou nenhuma mem√≥ria
        extra.

        . Espa√ßo extra ‚Üí O(1) (ou constante)

        . A estrutura original √© alterada

        EXEMPLO SIMPLES (LISTA):

            - N√ÉO in place

                    nova = lista[::-1]

                . cria nova lista
 
                . mem√≥ria extra O(n)

                . original permanece intacta

            - IN PLACE:

                    lista.reverse()

                . mesma lista

                . sem criar outra

                . mem√≥ria extra m√≠nima

                Resultado visual pode ser igual, mas o custo √© diferente.
        
        IN PLACE E MEM√ìRIA:

            Imagine uma lista na mem√≥ria:

                Endere√ßo 1000 ‚Üí [1, 2, 3, 4]

            . Opera√ß√£o in place

                - altera valores nos mesmos endere√ßos

                - n√£o realoca a estrutura inteira

            . Opera√ß√£o n√£o in place

                - cria outra √°rea de mem√≥ria

                - copia os valores

                - mant√©m a original intacta

            Isso impacta:

                desempenho

                consumo de mem√≥ria

                cache da CPU

        IN PLACE √ó N√ÉO IN PLACE (COMPARA√á√ÉO):

            | Crit√©rio            | In place     | N√£o in place  |
            | ------------------- | ------------ | ------------- |
            | Cria nova estrutura | ‚ùå           | ‚úî             |
            | Usa mem√≥ria extra   | O(1)         | O(n)          |
            | Modifica original   | ‚úî            | ‚ùå            |
            | Mais r√°pido         | geralmente ‚úî | geralmente ‚ùå |
            | Mais seguro         | ‚ùå           | ‚úî             |

            Seguran√ßa aqui = n√£o destruir dados originais.

        EXEMPLOS CL√ÅSSICOS EM PYTHON:

            . sort() vs sorted()

                lista.sort()      # IN PLACE
                sorted(lista)     # N√ÉO in place

            . reverse()

                lista.reverse()   # IN PLACE

            . Swap

                lista[i], lista[j] = lista[j], lista[i]  # IN PLACE

            . Modifica√ß√£o direta

                lista[0] = 10     # IN PLACE

        OPERADORES S√ÉO IN PLACE?

            . N√ÉO

                    lista = lista + outra

                . cria nova lista

            . SIM (conceitualmente)

                    lista += outra

                . += pode ser in place dependendo do tipo.

        IN PLACE E √çNDICES (CONEX√ÉO DIRETA)

            Opera√ß√µes in place:

                usam √≠ndices

                alteram posi√ß√µes existentes

                n√£o mudam a identidade do objeto

            EX:

                id(lista)  # permanece o mesmo

            Isso √© fundamental para entender refer√™ncias.

        IN PLACE E REFER√äNCIAS:

                a = [1, 2, 3]
                b = a

            Agora:

                a.sort()  # IN PLACE

            + b tamb√©m muda.

            Porque √© o mesmo objeto.

        QUANDO USAR IN PLACE:

            Use quando:

                mem√≥ria √© cr√≠tica

                lista √© grande

                voc√™ quer modificar o original

                n√£o precisa preservar vers√£o anterior

        QUANDO N√ÉO USAR:

            Evite quando:

                precisa preservar dados

                c√≥digo deve ser seguro

                m√∫ltiplas refer√™ncias existem

                clareza √© mais importante que performance

        T√âCNICAS COMUNS IN PLACE:

            . Dois √≠ndices

                i, j = 0, len(lista)-1

            . Swap progressivo

                while i < j:
                    lista[i], lista[j] = lista[j], lista[i]

            . Atualiza√ß√£o acumulada

                for i in range(len(lista)):
                    lista[i] += 1

        ERROS COMUNS

            esquecer que a lista original ser√° alterada

            modificar enquanto itera sem cuidado

            confundir retorno None com erro

            usar in place quando precisava de c√≥pia

        DICAS:

            Pergunte: preciso preservar o original?

            Se sim ‚Üí n√£o use in place

            Se n√£o ‚Üí prefira in place

            Verifique se o m√©todo retorna None

            Aten√ß√£o a refer√™ncias m√∫ltiplas

        FRASES-CHAVE PARA MEMORIZAR:

            . In place altera o original
            . Usa pouca mem√≥ria
            . N√£o cria c√≥pia
            . Mais r√°pido, menos seguro
            . Refer√™ncias importam

    =====================================================================

    Janelas:

        - Janela √© uma t√©cnica que analisa subconjuntos consecutivos de uma 
        estrutura sequencial (lista, string, array), deslocando um intervalo 
        ao longo dos dados.

        Em vez de:

            recalcular tudo do zero

            usar loops aninhados

        Voc√™:

            mant√©m uma janela

            move ela passo a passo

            atualiza o estado

        Isso reduz drasticamente o custo computacional.

        MODELO MENTAL FUNDAMENTAL:

            Imagine a lista:

                [2, 4, 1, 7, 3, 6]

            Janela de tamanho 3:

                [2, 4, 1]  ‚Üí janela 1
                    [4, 1, 7]  ‚Üí janela 2
                        [1, 7, 3]  ‚Üí janela 3
                            [7, 3, 6]  ‚Üí janela 4

            A janela desliza, mas os dados n√£o mudam.

        POR QUE JANELAS EXISTEM?

            Sem janela (ing√™nuo):

                    para cada posi√ß√£o:
                        recalcula tudo

                Complexidade:

                    O(n √ó k)

                Com janela:

                    remove o que sai
                    adiciona o que entra

                Complexidade:

                    O(n)

                Isso √© otimiza√ß√£o algor√≠tmica pura.

        TIPOS DE JANELA:

            1) JANELA DE TAMANHO FIXO

                - O tamanho da janela √© constante.

                Exemplo:

                    . m√©dia m√≥vel
                    . soma de k elementos
                    . maior soma de k elementos consecutivos

                    Modelo:

                        in√≠cio = 0
                        fim = k - 1

            2) JANELA DE TAMANHO VARI√ÅVEL

                - O tamanho cresce ou diminui conforme uma condi√ß√£o.

                Exemplo:

                    . menor sublista com soma ‚â• X
                    . substring sem caracteres repetidos

                    Modelo:

                        expande ‚Üí contrai ‚Üí expande

        JANELA E √çNDICES (CONEX√ÉO DIRETA):

            Janela sempre usa:

                . dois √≠ndices

                    . left

                    . right

                Eles definem:

                    janela = dados[left:right+1]

                T√©cnica dos dois ponteiros.

        JANELA DE TAMANHO FIXO (EXPLICA√á√ÉO):

            Exemplo conceitual: soma de 3 elementos

                lista = [2, 4, 1, 7, 3, 6]
                k = 3

            Passos:

                1. soma inicial dos 3 primeiros

                2. move a janela:

                    . subtrai o elemento que saiu

                    . soma o elemento que entrou

                N√£o recalcula tudo.

        JANELA DE TAMANHO VARI√ÅVEL (EXPLICA√á√ÉO):

            Exemplo:

                menor sublista com soma ‚â• 10

            Processo:

                1. expande a janela (direita)

                2. quando atingir condi√ß√£o:

                    . tenta contrair (esquerda)

                3. mant√©m o melhor resultado

                Muito usada em problemas dif√≠ceis.
        
        JANELAS E MEM√ìRIA:

            . A janela n√£o cria c√≥pia

            . Trabalha in place sobre √≠ndices

            . Usa mem√≥ria O(1)

            Isso conecta diretamente com:

                √≠ndices

                in place

                performance

        JANELAS √ó SLICING:

            Ruim:

                lista[i:i+k]  # cria nova lista

            Bom:

                usa √≠ndices + acumulador

            Janelas n√£o copiam dados.

        USOS CL√ÅSSICOS DE JANELAS:

            m√©dia m√≥vel
            soma m√°xima
            an√°lise de s√©ries temporais
            detec√ß√£o de padr√µes
            strings (substrings)
            processamento de sinais
            logs e streams
        
        ERROS COMUNS

            usar slicing dentro do loop

            esquecer de remover o elemento que sai

            errar limites (right < len)

            confundir janela fixa com vari√°vel

            usar dois loops quando um basta

        DICAS:

            Pergunte:

                Estou analisando elementos consecutivos?

                Recalculo valores repetidamente?

                Existe um tamanho fixo ou condi√ß√£o din√¢mica?

                Posso atualizar o resultado incrementalmente?

            Se sim ‚Üí √© problema de janela.

        FRASES-CHAVE PARA MEMORIZAR

            . Janela analisa subconjuntos consecutivos
            . Dois √≠ndices definem a janela
            . Remove o que sai, adiciona o que entra
            . Evita loops aninhados
            . Janela √© otimiza√ß√£o

    =====================================================================

    Slicing:

        - Slicing √© a opera√ß√£o de extrair um subconjunto consecutivo de uma
        sequ√™ncia, usando √≠ndices.

        Funciona em:

            . listas
 
            . strings
 
            . tuplas

            . outras sequ√™ncias

            Sempre baseado em √≠ndices.

        FORMA PYTH√îNICA (OFICIAL):

            seq[inicio:fim:passo]

        Regras:

            inicio ‚Üí inclusivo

            fim ‚Üí exclusivo

            passo ‚Üí incremento

        Exemplos:

            lista[1:4]
            lista[:3]
            lista[2:]
            lista[::2]
            lista[::-1]

        POR QUE O FIM √â EXCLUSIVO?

            - Consist√™ncia matem√°tica:

                tamanho = fim - inicio

            Isso:

                . evita +1
                . simplifica c√°lculo
                . permite compor slices

                Mesma raz√£o dos loops range.

        FUNCIONAMENTO NA MEM√ìRIA:

            . Listas

                slicing cria nova lista

                c√≥pia rasa

                custo O(k)

            EX:

                nova = lista[2:5]

            N√£o √© in place.

            . Strings

                strings s√£o imut√°veis

                slicing cria nova string

        IMPLICA√á√ÉO IMPORTANTE:

            - Slicing n√£o √© barato.

            Dentro de loops:

                for i in range(n):
                    lista[i:i+k]

            Pode virar O(n¬≤).

        SLICING MANUAL (COM √çNDICES):

            Antes de slicing existir, far√≠amos:

                nova = []
                for i in range(inicio, fim):
                    nova.append(lista[i])

            Isso √© slicing manual.

            Quando usar slicing manual?

                quando precisa de controle

                quando quer evitar c√≥pias

                quando usa janelas

                quando filtra dinamicamente

        SLICING PYTH√îNICO (IDIOM√ÅTICO):

                lista[::-1]
                lista[:]
                lista[::2]

            . Leg√≠vel
            . Expressivo
            . Menos c√≥digo

            Mas pode esconder custo.

        SLICING COM PASSO:

                lista[::2]   # pares
                lista[1::2]  # √≠mpares

            Cria nova lista pulando elementos.

        SLICING NEGATIVO:

                lista[-3:]
                lista[:-1]
            
            Python ajusta √≠ndices automaticamente.

        SLICING COMO C√ìPIA:

                copia = lista[:]

            . C√≥pia rasa.

            . Para listas aninhadas, cuidado.

        SLICING IN PLACE?

            Slicing n√£o √© in place, exceto em atribui√ß√£o.

            . Atribui√ß√£o por slice

                    lista[1:3] = [9, 9]

                . In place
                . Modifica estrutura

                T√©cnica avan√ßada.

        SLICING vs JANELAS:

            | Slicing          | Janela           |
            | ---------------- | ---------------- |
            | cria c√≥pia       | n√£o cria         |
            | simples          | eficiente        |
            | custo O(k)       | custo O(1)       |
            | bom para leitura | bom para an√°lise |

            Use slicing para extrair, janelas para analisar.

        T√âCNICAS E ESTRAT√âGIAS COM SLICING:

            T√©cnica 1 ‚Äî C√≥pia segura

                nova = lista[:]

            T√©cnica 2 ‚Äî Revers√£o r√°pida

                    lista[::-1]

                Para leitura ou c√≥pia.

            T√©cnica 3 ‚Äî Substitui√ß√£o parcial

                    lista[:2] = [0, 0]

                . In place.

            T√©cnica 4 ‚Äî Quebra em partes

                    meio = len(lista)//2
                    esq = lista[:meio]
                    dir = lista[meio:]

                . Base de divide and conquer.

            T√©cnica 5 ‚Äî Fatiamento por padr√£o

                pares = lista[::2]

            T√©cnica 6 ‚Äî Sliding via slicing (cuidado)

                    for i in range(len(lista)-k+1):
                        janela = lista[i:i+k]

                Simples, mas custoso.

        ERROS COMUNS

            achar que slicing √© in place

            usar slicing pesado em loops

            confundir slice vazio com erro

            esquecer que fim √© exclusivo

            usar slicing quando √≠ndice basta

        DICAS:

            . Precisa extrair ‚Üí slicing
            . Precisa analisar repetidamente ‚Üí janela
            . Precisa copiar ‚Üí slicing
            . Precisa performance ‚Üí √≠ndices
            . Use slicing com inten√ß√£o

        FRASES-CHAVE PARA MEMORIZAR:

            Slicing copia
            Fim √© exclusivo
            Passo controla salto
            N√£o √© in place
            Janela √© melhor para an√°lise

    =====================================================================

    Divis√£o e conquista:

        - Resolver o grande resolvendo muitos pequenos

        - Divis√£o e conquista √© um paradigma algor√≠tmico que resolve um problema
        dividindo-o em subproblemas menores, resolvendo cada um de forma 
        independente e combinando os resultados.

        Ele tem 3 etapas obrigat√≥rias:

            1. Dividir o problema

            2. Conquistar (resolver os subproblemas)

            3. Combinar os resultados

            Se faltar uma delas ‚Üí n√£o √© divis√£o e conquista.

        - ‚ÄúSe eu sei resolver o problema pequeno, sei resolver o grande.‚Äù

        √â o mesmo racioc√≠nio da indu√ß√£o matem√°tica.

        ESTRUTURA PADR√ÉO (FORMA GERAL):

            Em pseudoc√≥digo:

                resolver(problema):
                    se problema √© pequeno:
                        resolve diretamente
                    divide o problema em partes
                    resolve cada parte recursivamente
                    combina os resultados

            Note: recurs√£o quase sempre aparece, mas recurs√£o sozinha n√£o √© 
            divis√£o e conquista.

        DIFEREN√áA CRUCIAL: RECURS√ÉO √ó DIVIS√ÉO E CONQUISTA:

            | Recurs√£o           | Divis√£o e Conquista |
            | ------------------ | ------------------- |
            | T√©cnica            | Paradigma           |
            | Pode ter 1 chamada | Tem 2+ subproblemas |
            | Pode ser linear    | √â estrutural        |
            | Nem sempre divide  | Sempre divide       |

            Todo divide & conquer usa recurs√£o,

            mas nem toda recurs√£o √© divide & conquer.

        EXEMPLO CONCEITUAL SIMPLES (SOMA):

            Problema:

                Somar uma lista grande

            Forma linear: ineficiente nesse caso

                soma = soma(lista inteira)

            Divis√£o e conquista: Mais eficiente nesse caso

                soma(lista):
                    divide em duas metades
                    soma esquerda
                    soma direita
                    retorna soma_esq + soma_dir

            O problema fica menor em cada n√≠vel.

        POR QUE ISSO FUNCIONA T√ÉO BEM?

            1) Reduz complexidade

                . profundidade ‚âà log n

                . n√£o cresce linearmente

            2) Explora paralelismo

                . subproblemas independentes

                . ideal para m√∫ltiplos n√∫cleos

            3) Estrutura clara

                . l√≥gica local

                . menos estados confusos

        COMPARA√á√ÉO COM FOR√áA BRUTA:

            | Abordagem        | Complexidade  |
            | ---------------- | ------------- |
            | For√ßa bruta      | O(n¬≤) ou pior |
            | Divide & conquer | O(n log n)    |

            Isso muda completamente a escala.

        FUNCIONAMENTO NA MEM√ìRIA

            . Cada divis√£o cria chamadas recursivas
            . Usa stack
            . Aloca subestruturas (√†s vezes com slicing)

            Implementa√ß√µes boas evitam c√≥pias desnecess√°rias.

        ERROS COMUNS (MUITO IMPORTANTES)

            . ‚ÄúUsar recurs√£o = dividir e conquistar‚Äù
            . N√£o definir caso base 
            . Dividir mal (subproblemas desbalanceados) 
            . N√£o combinar corretamente
            . Usar quando um loop simples basta

        QUANDO USAR DIVIS√ÉO E CONQUISTA

            Use quando:

                o problema √© grande

                pode ser quebrado naturalmente

                subproblemas s√£o independentes

                h√° ganho claro de performance

        QUANDO N√ÉO USAR

            Evite quando:

                problema √© linear simples

                custo de divis√£o √© alto

                h√° depend√™ncia sequencial forte

                solu√ß√£o iterativa √© mais clara

        Dividir s√≥ por ‚Äúestilo‚Äù √© erro.

        COMO IDENTIFICAR UM PROBLEMA DE DIVIS√ÉO E CONQUISTA:

            Pergunte:

                1. Posso quebrar o problema em partes iguais?
                2. Resolver uma parte ajuda a resolver o todo?
                3. Subproblemas s√£o independentes?
                4. Combinar resultados √© simples?

                Se sim ‚Üí √© candidato.

        FRASES-CHAVE PARA MEMORIZAR

            Divide o problema
            Resolve partes menores
            Combina resultados
            Cresce em log n
            Paradigma, n√£o t√©cnica

    =====================================================================

    Rota√ß√£o:

        - Reorganizando elementos sem perder a ordem relativa

        - Rota√ß√£o √© a opera√ß√£o que desloca os elementos de uma sequ√™ncia 
        circularmente, preservando a ordem relativa.

        Ou seja:

            nada √© perdido

            nada √© criado

            apenas muda de posi√ß√£o

        Diferente de:

            ordena√ß√£o

            revers√£o

            embaralhamento

        MODELO MENTAL CORRETO:

            - Imagine uma lista como um anel, n√£o como uma linha.

                [1, 2, 3, 4, 5]

            Se voc√™ ‚Äúgira‚Äù esse anel, os elementos continuam na mesma ordem,
            s√≥ come√ßam em outro ponto.

        TIPOS DE ROTA√á√ÉO:

            1) ROTA√á√ÉO √Ä ESQUERDA (LEFT ROTATION)

                Cada elemento anda para a esquerda
                
                O primeiro vai para o final

                Exemplo:

                    [1, 2, 3, 4, 5]  ‚Üí rotacionar 2 √† esquerda
                    [3, 4, 5, 1, 2]

            2) ROTA√á√ÉO √Ä DIREITA (RIGHT ROTATION)

                Cada elemento anda para a direita
                
                O √∫ltimo vai para o in√≠cio

                Exemplo:

                    [1, 2, 3, 4, 5] ‚Üí rotacionar 2 √† direita
                    [4, 5, 1, 2, 3]

                Rota√ß√£o √† direita = rota√ß√£o √† esquerda de n - k.

            ROTA√á√ÉO ‚â† SHIFT:

                | Opera√ß√£o | O que acontece       |
                | -------- | -------------------- |
                | Shift    | elementos caem fora  |
                | Rota√ß√£o  | elementos reaparecem |

                Rota√ß√£o √© circular.

                √â um padr√£o estrutural, n√£o cosm√©tico.

        FORMAS DE IMPLEMENTAR ROTA√á√ÉO:

            1) ROTA√á√ÉO COM SLICING (N√ÉO IN PLACE)

                    rot = lista[k:] + lista[:k]

                . simples
                . cria nova lista
                . usa mem√≥ria O(n)

                Bom para leitura, n√£o para performance.

            2) ROTA√á√ÉO IN PLACE COM C√ìPIA AUXILIAR

                    temp = lista[:k]
                    lista[:len(lista)-k] = lista[k:]
                    lista[len(lista)-k:] = temp

                Parcialmente in place (usa buffer pequeno).

            3) ROTA√á√ÉO IN PLACE (T√âCNICA DAS REVERS√ïES)

                M√©todo cl√°ssico de CS

                Rota√ß√£o √† esquerda por k:

                    1. reverta os primeiros k

                    2. reverta o restante

                    3. reverta tudo

                    Exemplo:

                        [1,2,3,4,5], k=2
                        ‚Üí [2,1,3,4,5]
                        ‚Üí [2,1,5,4,3]
                        ‚Üí [3,4,5,1,2]

                . O(n)
                . O(1) mem√≥ria
                . Algoritmo cl√°ssico

        ROTA√á√ÉO E √çNDICES (BASE MATEM√ÅTICA):

            Para √≠ndice i:

                novo_indice = (i + k) % n

            Essa f√≥rmula aparece em:

                . hashing
                . criptografia
                . buffers
                . jogos
                . matrizes

        ROTA√á√ÉO E JANELAS:

            Rota√ß√£o cria:

                janelas circulares

                padr√µes repetitivos

            Exemplo:

                [1,2,3] ‚Üí janelas circulares
                [1,2], [2,3], [3,1]

            Muito usado em processamento de sinais.

        ROTA√á√ÉO EM STRINGS

            Strings s√£o imut√°veis:

                . rota√ß√£o sempre cria nova string

                    s = s[k:] + s[:k]

        ERROS COMUNS

            . confundir rota√ß√£o com invers√£o
            . esquecer de usar k % n
            . usar slicing pesado em loops
            . achar que rota√ß√£o √© sempre in place
            . errar esquerda √ó direita

        DICAS:

            Defina dire√ß√£o (esquerda ou direita)

            Normalize k (k %= n)

            Escolha:

                clareza ‚Üí slicing

                performance ‚Üí in place

            Pense circular, n√£o linear

            Desenhe a lista como um anel

        FRASES-CHAVE PARA MEMORIZAR

            Rota√ß√£o √© circular
            Ordem relativa √© preservada
            N√£o perde elementos
            √çndice usa m√≥dulo
            Revers√µes resolvem in place

    =====================================================================

    particionamento:

        Separar dados por crit√©rio, sem necessariamente ordenar

        - Particionamento √© a t√©cnica de dividir uma estrutura sequencial em
        partes, com base em um crit√©rio, mantendo os elementos relacionados
        juntos.

        Ou seja:

            voc√™ n√£o ordena

            voc√™ n√£o perde dados

            voc√™ apenas separa por condi√ß√£o

        √â uma reorganiza√ß√£o estrutural, n√£o est√©tica.

        MODELO MENTAL FUNDAMENTAL:

            Pense assim:

                ‚ÄúQuero que todos os elementos que satisfazem uma condi√ß√£o fiquem 
                de um lado, e os que n√£o satisfazem, do outro.‚Äù

            Exemplo:

                    [3, 8, 5, 2, 7, 4]

                Crit√©rio: < 5

            Resultado poss√≠vel:

                    [3, 2, 4 | 8, 5, 7]

                A ordem interna n√£o importa (a menos que voc√™ exija).

        PARTICIONAMENTO ‚â† ORDENA√á√ÉO:

            | Particionamento     | Ordena√ß√£o          |
            | ------------------- | ------------------ |
            | separa por crit√©rio | organiza por ordem |
            | O(n)                | O(n log n)         |
            | local               | global             |
            | base de algoritmos  | objetivo final     |

            Particionar √© mais barato que ordenar.

        POR QUE PARTICIONAMENTO EXISTE?

            Usos reais:

                QuickSort

                filtros in place

                dois ponteiros

                janelas

                sele√ß√£o do k-√©simo menor elemento

                separa√ß√£o de dados (positivos/negativos, v√°lidos/inv√°lidos)

            Ele resolve classes inteiras de problemas.

        FORMAS DE PARTICIONAR:

            1) PARTICIONAMENTO SIMPLES (COM LISTAS NOVAS)

                    menores = []
                    maiores = []

                . simples
                . usa mem√≥ria extra
                . n√£o √© in place

                Bom para clareza, ruim para performance.

            2) PARTICIONAMENTO IN PLACE (DOIS √çNDICES)

                T√©cnica cl√°ssica

                Modelo:

                    i ‚Üí avan√ßa procurando erro
                    j ‚Üí recua procurando erro
                    swap quando necess√°rio

                Muito usada em QuickSort.

        PARTICIONAMENTO COM PIV√î:

            Um elemento especial define a divis√£o.

            Exemplo:

                piv√¥ = 5

            Objetivo:

                ‚â§ piv√¥ | > piv√¥

            O piv√¥ n√£o precisa ficar no lugar final (dependendo da varia√ß√£o).

        ALGORITMO MENTAL DO PARTICIONAMENTO IN PLACE:

            1. Escolha um crit√©rio (ou piv√¥)

            2. Mantenha um √≠ndice de ‚Äúfronteira‚Äù

            3. Percorra a lista

            4. Quando encontrar um elemento v√°lido:

                . troque com a fronteira

                . avance a fronteira

            Isso garante separa√ß√£o correta.

        EXEMPLO CONCEITUAL (SEM C√ìDIGO):

            Lista:

                [7, 3, 5, 2, 8]

            Crit√©rio: < 5

            Processo:

                [3 | 7, 5, 2, 8]
                [3, 2 | 5, 7, 8]

            N√£o ordena, apenas agrupa.

        PARTICIONAMENTO E √çNDICES:

            Particionamento:

                depende fortemente de √≠ndices

                geralmente usa:

                    √≠ndice de varredura

                    √≠ndice de fronteira

                Conecta diretamente com:

                    swap

                    in place

                    mem√≥ria

        PARTICIONAMENTO E JANELAS:

            . janelas ‚Üí analisam subconjuntos

            . particionamento ‚Üí reorganiza o conjunto

            T√©cnicas complementares.

        PARTICIONAMENTO E DIVIS√ÉO E CONQUISTA:

            QuickSort funciona assim:

                1. particiona a lista

                2. resolve cada lado recursivamente

                Particionamento √© o passo central.

        VARIA√á√ïES IMPORTANTES:

            est√°vel √ó inst√°vel

            com piv√¥ fixo

            com piv√¥ aleat√≥rio

            particionamento por m√∫ltiplos crit√©rios

            particionamento l√≥gico (sem mover dados)

        ERROS COMUNS

            achar que particionamento ordena

            esquecer que a ordem interna pode mudar

            errar limites dos √≠ndices

            confundir fronteira com posi√ß√£o final

            tentar usar quando filtro simples bastaria

        DICAS:

            Pergunte:

                Preciso separar por condi√ß√£o?

                A ordem interna importa?

                Preciso ser in place?

                Isso √© pr√©-processamento para outro algoritmo?

            Se sim ‚Üí particionamento.

        FRASES-CHAVE PARA MEMORIZAR:

            Particionar √© separar
            N√£o ordena
            √â O(n)
            Base do QuickSort
            Usa √≠ndices e swaps

    ======================================================================

    Shift:

        ‚ÄúEmpurrar‚Äù itens para a esquerda/direita

        - Shift = deslocar elementos k posi√ß√µes para a esquerda ou direita.

        . Shift √† esquerda (n√£o circular): itens ‚Äúsaem‚Äù pelo come√ßo, e entram 
        ‚Äúburacos‚Äù no fim (preenchidos por algo).

        . Shift √† direita (n√£o circular): itens ‚Äúsaem‚Äù pelo fim, e entram 
        ‚Äúburacos‚Äù no come√ßo.

        Isso √© diferente de rota√ß√£o:

            . Shift: perde itens (ou voc√™ descarta) e preenche buracos.

            . Rota√ß√£o: ningu√©m some; √© circular.

        Exemplo (shift √† esquerda, k=2, preenchendo com 0):

            [1,2,3,4,5]  ->  [3,4,5,0,0]

        Exemplo (rota√ß√£o √† esquerda, k=2):

            [1,2,3,4,5]  ->  [3,4,5,1,2]

        Tipos de shift (estrat√©gias):

            A) Shift ‚Äúl√≥gico‚Äù (sem mexer na lista):

                Voc√™ n√£o move nada, s√≥ muda a forma de acessar:

                    . Para ler como se estivesse deslocado, use um √≠ndice 
                    convertido:

                        . esquerda: elemento ‚Äúvirtual‚Äù i vem de i+k

                        . direita: elemento ‚Äúvirtual‚Äù i vem de i-k

                    Isso √© √≥timo quando:

                        voc√™ s√≥ precisa ler

                        quer performance

                        quer evitar c√≥pias

            B) Shift f√≠sico criando nova lista

                Simples e leg√≠vel, mas usa mem√≥ria extra O(n).

            C) Shift f√≠sico in place

                Voc√™ realmente move elementos na mesma lista. √ötil quando:

                . precisa preservar o objeto (mesmo id)

                . quer economizar mem√≥ria

                . est√° implementando estruturas (buffer, fila, etc.)

        SHIFT IN PLACE (o ‚Äúcl√°ssico‚Äù com √≠ndices):

            Shift √† direita (k posi√ß√µes) preenchendo com fill

                Ideia: copiar de tr√°s pra frente para n√£o sobrescrever dados.

                Para i de n-1 at√© 0:
                    se i-k >= 0, a[i] = a[i-k]
                    sen√£o a[i] = fill

            Shift √† esquerda (k posi√ß√µes) preenchendo com fill

                Ideia: copiar da frente pra tr√°s.

                Para i de 0 at√© n-1:
                    se i+k < n, a[i] = a[i+k]
                    sen√£o a[i] = fill

                Essa l√≥gica √© exatamente ‚Äúmemmove‚Äù mental: escolher o sentido 
                para evitar sobrescrita.

        O custo (por que isso importa):

            Shift f√≠sico in place: O(n) tempo, O(1) mem√≥ria extra

            Shift criando nova lista: O(n) tempo, O(n) mem√≥ria

            Shift l√≥gico (s√≥ √≠ndice): O(1) mem√≥ria, O(1) por acesso

        Uso com loops e condicionais (padr√µes reais)

            A) ‚ÄúRemover‚Äù elementos do come√ßo sem pop(0) (que √© caro)

                Em listas, pop(0) √© O(n) porque desloca tudo.

                Um padr√£o melhor:

                    . manter um ponteiro start (shift l√≥gico)

                    . quando precisar ‚Äúcompactar‚Äù, a√≠ sim copia/recorta

            B) Buffer deslizante (janela fixa)

                Voc√™ mant√©m uma lista de tamanho k e ‚Äúshift‚Äù para inserir o
                novo no fim:

                    . shift √† esquerda 1

                    . coloca novo elemento no final

        Shift em outros iter√°veis:

            Strings/tuplas (imut√°veis)

                Voc√™ n√£o faz in place. S√≥:

                    . cria nova (slicing/concatena√ß√£o)

                    . ou faz acesso l√≥gico via √≠ndice

        Armadilhas comuns:

            . confundir shift com rota√ß√£o

            . mover no sentido errado e sobrescrever dados

            . esquecer o k maior que n (normalizar: k = min(k, n) para shift 
            ‚Äún√£o circular‚Äù)

            . usar pop(0) repetidamente em listas

    ======================================================================

    embaralhamento:

        - Embaralhamento √© a opera√ß√£o de reorganizar os elementos de uma 
        sequ√™ncia de forma aleat√≥ria, sem perder nem repetir elementos.

        Ou seja:

            todos os elementos continuam existindo

            apenas a ordem muda

            o objetivo √© aleatoriedade justa

        Embaralhar n√£o √©:

            ordenar

            rotacionar

            inverter

            particionar

        MODELO MENTAL CORRETO:

            Imagine cartas de baralho:

                voc√™ n√£o cria cartas novas

                n√£o remove cartas

                apenas muda a ordem

            Um bom embaralhamento faz todas as ordens poss√≠veis terem a mesma 
            chance.

        EMBARALHAMENTO ‚ÄúRUIM‚Äù √ó ‚ÄúCORRETO‚Äù:

            . Embaralhamento ing√™nuo (errado)

                    import random
                    random.shuffle(lista)

                . Isso funciona, mas n√£o explica o algoritmo.

                . E pior: muita gente tenta fazer assim:

                    for i in range(len(lista)):
                        j = random.randint(0, len(lista)-1)
                        lista[i], lista[j] = lista[j], lista[i]

                - Esse m√©todo N√ÉO √© uniforme

                - Algumas permuta√ß√µes t√™m mais chance que outras

                Isso √© um erro cl√°ssico.

        EMBARALHAMENTO CORRETO (FISHER‚ÄìYATES):

            - O √∫nico algoritmo simples e correto para embaralhar listas √© o 
            Fisher‚ÄìYates (ou Knuth shuffle).

            IDEIA CENTRAL DO FISHER‚ÄìYATES:

                Para cada posi√ß√£o:

                    escolha aleatoriamente um elemento ainda n√£o fixado

                    troque com a posi√ß√£o atual

                Cada elemento √© escolhido uma √∫nica vez.

            MODELO PASSO A PASSO (CONCEITUAL)

                Lista:

                    [1, 2, 3, 4]

                Passos:

                    1. escolha √≠ndice entre [0..3], troque com posi√ß√£o 3

                    2. escolha √≠ndice entre [0..2], troque com posi√ß√£o 2

                    3. escolha √≠ndice entre [0..1], troque com posi√ß√£o 1

                    A parte ‚Äúfinal‚Äù vai ficando fixa.

            POR QUE FUNCIONA?

                No passo i, existem exatamente i+1 escolhas v√°lidas

                Cada permuta√ß√£o poss√≠vel ocorre com probabilidade igual

                Prova matem√°tica simples (mas profunda)

            Isso garante aleatoriedade uniforme.

        EMBARALHAMENTO IN PLACE:

            Fisher‚ÄìYates:

                √© in place

                usa O(1) mem√≥ria extra

                roda em O(n)

            Perfeito para listas grandes.

        EMBARALHAMENTO E √çNDICES

            Tudo √© baseado em:

                √≠ndice atual

                √≠ndice aleat√≥rio dentro de um intervalo

                swap in place

            Sem √≠ndices, n√£o existe shuffle eficiente.

        EMBARALHAMENTO E PROBABILIDADE

            Um embaralhamento correto deve:

                gerar n! permuta√ß√µes poss√≠veis

                cada uma com probabilidade 1 / n!

            Se isso n√£o acontece ‚Üí algoritmo errado.

        ERROS COMUNS

            trocar com √≠ndice aleat√≥rio completo sempre

            usar sorted(..., key=random.random)

            achar que ‚Äúparece aleat√≥rio‚Äù √© suficiente

            usar shuffle sem entender impacto

        DICAS:

            Sempre fixe uma posi√ß√£o por vez

            Reduza o intervalo de escolha
            
            Use swap in place
            
            Pense: ‚Äúessa posi√ß√£o j√° est√° decidida?‚Äù

            Se n√£o conseguir explicar a probabilidade ‚Üí revise

        FRASES-CHAVE PARA MEMORIZAR:

            . Embaralhar √© permutar
            . Aleatoriedade precisa ser justa
            . Fisher‚ÄìYates √© o padr√£o
            . Swap + √≠ndice aleat√≥rio
            . In place e O(n)

    ======================================================================

    Listas, Arrays e Vetores circulares:

        LISTA / ARRAY / VETOR ‚Äî ALINHANDO OS TERMOS:

            | Termo     | O que significa                        |
            | --------- | -------------------------------------- |
            | **Vetor** | Estrutura sequencial indexada          |
            | **Array** | Vetor alocado contiguamente na mem√≥ria |
            | **Lista** | Estrutura sequencial de alto n√≠vel     |

        Em Python:

            list ‚âà array din√¢mico (cont√≠guo, redimension√°vel)

            mas com sem√¢ntica de lista de alto n√≠vel

        MODELO LINEAR (O PADR√ÉO):

            Modelo tradicional:

                √≠ndices:  0   1   2   3   4
                valores: [A | B | C | D | E]

            . tem come√ßo

            . tem fim

            . acessar fora ‚Üí erro

            Esse modelo n√£o √© circular.

        PROBLEMA DO MODELO LINEAR:

            Em muitas situa√ß√µes reais:

                dados chegam continuamente

                dados antigos saem

                voc√™ n√£o quer mover tudo

            Surge o modelo circular.

        VETOR / ARRAY CIRCULAR (ESS√äNCIA):

            - Um vetor circular √© uma estrutura que reaproveita o espa√ßo, 
            tratando o final como ligado ao in√≠cio.

            Visualmente:

                [A] ‚Üí [B] ‚Üí [C] ‚Üí [D]
                ‚Üë                 ‚Üì
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

            N√£o existe ‚Äúfim‚Äù l√≥gico ‚Äî s√≥ posi√ß√£o atual.

        A CHAVE DO CIRCULAR: M√ìDULO (%)

            Tudo se baseia em:

                √≠ndice_real = √≠ndice_l√≥gico % tamanho

            Exemplo:

                i = 6
                n = 5
                i % n = 1

            Esse % √© o que transforma linear em circular.

        ACESSO EM VETOR CIRCULAR

            Lista:

                lista = ['A','B','C','D','E']

            Acesso circular:

                lista[i % len(lista)]

            Exemplo:

                i = 5 ‚Üí A
                i = 6 ‚Üí B
                i = 7 ‚Üí C

            Nenhum erro, tudo reaproveitado.

        CIRCULAR ‚â† ROTA√á√ÉO:

            | Circular       | Rota√ß√£o           |
            | -------------- | ----------------- |
            | muda o acesso  | muda a estrutura  |
            | l√≥gico         | f√≠sico            |
            | n√£o move dados | move dados        |
            | usa `%`        | usa swap/revers√£o |

            Vetor circular n√£o rotaciona a lista, s√≥ muda o ponto de vista.

        FILA CIRCULAR (USO CL√ÅSSICO):

            Voc√™ mant√©m:

                head (in√≠cio)

                tail (fim)

            Inser√ß√£o:

                tail = (tail + 1) % n

            Remo√ß√£o:

                head = (head + 1) % n

            Nenhum elemento √© deslocado.

        VANTAGENS DO MODELO CIRCULAR:

            . O(1) para inserir/remover
            . Nenhum shift f√≠sico
            . Reuso de mem√≥ria
            . Ideal para streams

            Muito usado em sistemas operacionais e redes.

        CIRCULAR E JANELAS DESLIZANTES:

            Janela fixa:

                . voc√™ avan√ßa o √≠ndice

                . reaproveita posi√ß√µes antigas

                . mant√©m tamanho constante

                Buffer circular + janela = efici√™ncia m√°xima.

        CIRCULAR E SHIFT (CONEX√ÉO)

            Shift f√≠sico ‚Üí caro

            Circular ‚Üí s√≥ muda √≠ndice

            Exemplo:

                shift l√≥gico = start += 1

            Essa √© a ideia de shift l√≥gico circular.

        CIRCULAR E STRINGS

            Strings s√£o imut√°veis:

                circular s√≥ pode ser l√≥gico

                acesso via %

                    s[(i + k) % len(s)]

        ERROS COMUNS

            confundir circular com rota√ß√£o

            esquecer %

            misturar √≠ndice l√≥gico com real

            tentar usar circular sem ponteiros (head, tail)

            fazer shift f√≠sico desnecess√°rio

        QUANDO USAR CIRCULAR

            Use quando:

                dados s√£o cont√≠nuos

                tamanho √© fixo

                voc√™ descarta os mais antigos

                desempenho importa

            N√£o use quando:

                precisa de ordem linear fixa

                precisa de slicing frequente

                dados s√£o pequenos e simples

        FRASES-CHAVE PARA MEMORIZAR

            . Circular reaproveita mem√≥ria
            . Final liga ao come√ßo
            . M√≥dulo √© a chave
            . N√£o move dados
            . Troca estrutura por l√≥gica

    =====================================================================

    Matrizes:

        - Estrutura bidimensional, matem√°tica + computa√ß√£o

        O QUE √â UMA MATRIZ (CONCEITO FORMAL):

            - Uma matriz √© uma tabela bidimensional de elementos organizada em 
            linhas e colunas.
    
            Exemplo:

                A=[
                    1 2 3
                    4 5 6
                ]

            . Dimens√£o: 2 √ó 3

            . Elemento: ai,j
	
        - Em computa√ß√£o, uma matriz √© uma estrutura de dados indexada em duas 
        dimens√µes, usada para representar rela√ß√µes, grades, grafos, imagens, 
        estados e transforma√ß√µes.

        Em computa√ß√£o, matriz n√£o √© s√≥ matem√°tica, √© modelo de dados.

            Representa√ß√£o ex:

                matriz = [
                    [1, 2, 3],
                    [4, 5, 6]
                ]
        
        MATRIZ EM PYTHON (REPRESENTA√á√ÉO):

            Em Python:

                matriz = [
                    [1, 2, 3],
                    [4, 5, 6]
                ]

            . matriz = lista de listas

            . cada linha √© um objeto independente

            Nunca confundir com:

                mat = [[0]*3]*2  # ERRO CL√ÅSSICO

            (gera refer√™ncias duplicadas)

        √çNDICES EM MATRIZES:

            . mat[i][j]
            . i ‚Üí linha
            . j ‚Üí coluna

            Exemplo:

                mat[0][2]  # linha 0, coluna 2

            √çndices come√ßam em 0.

        MATRIZ ‚â† ARRAY MULTIDIMENSIONAL REAL:

            Conceito importante:

                Python: lista de listas (ponteiros)

                C / NumPy: mem√≥ria cont√≠gua

            Em Python:

                mat
                 ‚îú‚îÄ‚îÄ linha0 ‚Üí [1,2,3]
                 ‚îî‚îÄ‚îÄ linha1 ‚Üí [4,5,6]

            Cada linha pode ter tamanho diferente (matriz ‚Äúirregular‚Äù).

        MATRIZES NA MEM√ìRIA:

            Duas formas cl√°ssicas:

                - Row-major

                    . linhas consecutivas na mem√≥ria

                    . usado em C, Python, NumPy

                - Column-major

                    . colunas consecutivas

                    . usado em Fortran, MATLAB

            Impacta cache, desempenho e loops.

        PERCORRENDO MATRIZES (FORMA CORRETA):

            . Dois loops

                    for i in range(linhas):
                        for j in range(colunas):
                            processa(matriz[i][j])

                - Ordem importa para desempenho.

        OPERA√á√ïES FUNDAMENTAIS:

            - Leitura

                acesso O(1)

            - Escrita

                acesso O(1)

            - Inser√ß√£o/remo√ß√£o

                cara (O(n))

            Matrizes s√£o √≥timas para acesso direto, ruins para reestrutura√ß√£o.

        MATRIZ E PROGRAMA√á√ÉO DIN√ÇMICA:

            Exemplo mental:

                dp[i][j] = melhor resultado at√© (i,j)

            Quase todo DP 2D √© matriz.

        MATRIZ E GRAFOS:

            . Matriz de adjac√™ncia

                mat[i][j] = 1 se existe aresta

            acesso r√°pido

            mem√≥ria O(n¬≤)

        MATRIZ E IMAGENS:

            Imagem = matriz:

                . linhas ‚Üí altura

                . colunas ‚Üí largura

                . valor ‚Üí intensidade/cor

            Processamento de imagem = algoritmo em matriz.

        MATRIZES ESPARSAS:

            Muitas posi√ß√µes s√£o zero.

            Problema:

                desperdi√ßa mem√≥ria

            Solu√ß√µes:

                listas de coordenadas

                dicion√°rios

                formatos CSR/CSC

            Muito usadas em ML e grafos grandes.

        MATRIZES E IN PLACE:

            Opera√ß√µes poss√≠veis:

                altera√ß√£o de valores

                swap

                rota√ß√£o 90¬∞

                espelhamento

            Cuidado:

                opera√ß√µes in place exigem controle de √≠ndices

                erros s√£o comuns

        ROTA√á√ïES E TRANSFORMA√á√ïES:

            Exemplo:

                rota√ß√£o 90¬∞

                espelhamento horizontal/vertical

            Muito usado em jogos e imagens.

        MATRIZES IRREGULARES:

                [
                    [1, 2],
                    [3, 4, 5],
                    [6]
                ]

            . Permitidas em Python

            . N√£o existem em matem√°tica tradicional

        ERROS CL√ÅSSICOS (PROVA E VIDA REAL):

            . [[0]*n]*m
            . inverter i e j
            . estourar √≠ndice
            . esquecer limites
            . confundir linha/coluna
            . usar matriz quando vetor basta

        QUANDO USAR MATRIZ:

            Use quando:

                . dados s√£o bidimensionais
                . acesso r√°pido importa
                . rela√ß√µes cruzadas existem

            N√£o use quando:

                . dados s√£o lineares
                . estrutura √© esparsa
                . crescimento din√¢mico √© frequente

        FRASES-CHAVE PARA MEMORIZAR:

            . Matriz √© estrutura + matem√°tica
            . √çndice √© (linha, coluna)
            . Acesso √© O(1)
            . Mem√≥ria importa
            . Base de jogos, grafos e DP

    =====================================================================

    Swaps com Matrizes, formas poss√≠veis:

        Trocas estruturais em dados bidimensionais

        - Swap em matriz √© a troca controlada de posi√ß√µes, linhas, colunas ou 
        regi√µes inteiras, preservando a estrutura bidimensional.

        . Tudo √© feito com √≠ndices.

        . Pode ser local (elementos) ou estrutural (linhas/colunas).

        . Pode ser in place ou n√£o.

    SWAP DE ELEMENTOS:

        . Troca simples

                mat[i1][j1], mat[i2][j2] = mat[i2][j2], mat[i1][j1]

            Base de:

                . rota√ß√µes
                . espelhamentos
                . algoritmos em imagem
                . transforma√ß√µes geom√©tricas

        SWAP DE LINHAS:

            - Trocar duas linhas inteiras da matriz.

            Exemplo:

                Linha 0 ‚Üî Linha 2

            Forma direta (Python)

                mat[i], mat[j] = mat[j], mat[i]

            . O(1)
            . Muito r√°pido
            . Troca refer√™ncias das linhas

        SWAP DE COLUNAS:

            Colunas n√£o s√£o objetos separados em Python.

            Forma correta:

                for i in range(linhas):
                    mat[i][c1], mat[i][c2] = mat[i][c2], mat[i][c1]

            . O(n)
            . Exige loop
            . Muito comum em processamento de dados

        SWAP DE DIAGONAIS:

            . Diagonal principal ‚Üî secund√°ria (matriz quadrada)

            √çndices:

                principal: (i, i)

                secund√°ria: (i, n-1-i)

                for i in range(n):
                    mat[i][i], mat[i][n-1-i] = mat[i][n-1-i], mat[i][i]

            Usado em:

                . simetria
                . jogos
                . transforma√ß√µes visuais

        SWAP DE LINHA COM COLUNA:

            Trocar:

                linha i

                com coluna j

            PS: S√≥ faz sentido em matriz quadrada.

            . L√≥gica

                for k in range(n):
                    mat[i][k], mat[k][j] = mat[k][j], mat[i][k]

            Opera√ß√£o estrutural

            Exige cuidado extremo com sobrescrita

        SWAP DE COLUNA COM LINHA:

            (varia√ß√£o sem√¢ntica)

            √â o mesmo conceito acima, mas invertendo a inten√ß√£o:

                coluna vira linha

                linha vira coluna

            Muito pr√≥ximo de transposi√ß√£o parcial.

        SWAP DE √çNDICES (PERMUTA√á√ÉO DE LINHAS/COLUNAS):

            . Usando vetor de permuta√ß√£o

                ordem = [2, 0, 1]

            Aplica√ß√£o:

                nova_mat = [mat[i] for i in ordem]

            Muito usado em:

                . reorganiza√ß√£o de dados

                . machine learning

                . matrizes esparsas

        SWAP DE SUBMATRIZES:

            . Trocar blocos

            Exemplo:

                . quadrante superior esquerdo ‚Üî inferior direito

                    mat[i][j], mat[i+n][j+n] = mat[i+n][j+n], mat[i][j]

                Base de:

                    rota√ß√£o 90¬∞

                    espelhamentos

                    convolu√ß√µes

        SWAP PARA ROTA√á√ÉO DE MATRIZ

            . Rota√ß√£o 90¬∞ in place

            Etapas:

                1. Transpor

                2. Swap de colunas

            Todo algoritmo de rota√ß√£o usa swaps.

        SWAP EM MATRIZES IRREGULARES:

            S√≥ √© poss√≠vel:

                . swap de linhas

                . swap de elementos existentes

            Colunas podem n√£o existir em todas as linhas.

        SWAP L√ìGICO (SEM MOVER DADOS):

            Troca de acesso:

                def get(i, j):
                    return mat[j][i]

            Muito usado para:

                . simular transposi√ß√£o

                . evitar custo O(n¬≤)

        ERROS CL√ÅSSICOS:

            . confundir linha com coluna
            . tentar trocar colunas sem loop
            . sobrescrever dados
            . esquecer que Python troca refer√™ncias
            . usar swap onde bastava acesso l√≥gico

        DICAS:

            Pergunte sempre:

                Estou trocando valores ou estrutura?
                Isso √© quadrado ou retangular?
                Preciso ser in place?
                Trocar refer√™ncia resolve?
                Existe risco de sobrescrita?

        FRASES-CHAVE PARA MEMORIZAR:

            Linha √© objeto
            Coluna √© √≠ndice
            Swap pode ser estrutural
            Quadrada permite mais opera√ß√µes
            Swap √© base de rota√ß√£o

    =====================================================================

    Diagonais:

        - Diagonal √© uma sequ√™ncia de elementos que atravessa a matriz ligando 
        posi√ß√µes de mesmo ‚Äúdeslocamento‚Äù.

        - Diagonal √© um conjunto de posi√ß√µes definido por uma rela√ß√£o entre 
        √≠ndices (i, j).

        diagonal n√£o √© desenho, √© condi√ß√£o sobre √≠ndices.

        MATRIZ QUADRADA √ó N√ÉO QUADRADA:

            Importante:

                . Diagonal principal e secund√°ria s√≥ existem formalmente em 
                matrizes quadradas

                . Em matrizes retangulares, falamos em diagonais parciais

        DIAGONAL PRINCIPAL:

            Elementos onde:

                i == j

            Exemplo (3√ó3):

                [ X . . ]
                [ . X . ]
                [ . . X ]

            C√≥digo:

                mat[i][i]

            . Tamanho = N

        DIAGONAL SECUND√ÅRIA:

            Elementos onde:

                i + j == N - 1

            Exemplo:

                [ . . X ]
                [ . X . ]
                [ X . . ]

            C√≥digo:

                mat[i][N-1-i]

            S√≥ existe em matriz quadrada.

        OUTRAS DIAGONAIS:

            - Aqui entra o que muita gente nunca aprende direito.

            . Diagonais paralelas √† principal:

                Condi√ß√£o:

                    j - i = constante

                Exemplos:

                    . j - i = 0 ‚Üí diagonal principal
                    . j - i = 1 ‚Üí acima
                    . j - i = -1 ‚Üí abaixo

            . Diagonais paralelas √† secund√°ria

                Condi√ß√£o:

                    i + j = constante

                Exemplo:

                    . i + j = N - 1 ‚Üí diagonal secund√°ria
                    . i + j = N - 2, N, etc.

                    Base de v√°rios algoritmos de grade.
            
        PERCORRENDO DIAGONAIS (PADR√ïES):

            Diagonal principal:

                for i in range(n):
                    mat[i][i]

            Diagonal secund√°ria:

                for i in range(n):
                    mat[i][n-1-i]

            Diagonal geral (j - i = k):

                for i in range(n):
                    j = i + k
                    if 0 <= j < m:
                        mat[i][j]

        DIAGONAIS E MEM√ìRIA:

            . Diagonais n√£o s√£o cont√≠guas na mem√≥ria
            . Acesso salta linhas
            . Pode causar cache misses

            Em sistemas de alto desempenho, isso importa.

        OPERA√á√ïES COM DIAGONAIS:

            . Soma

                soma += mat[i][i]

            . Swap

                mat[i][i], mat[i][n-1-i] = mat[i][n-1-i], mat[i][i]

            . Zeragem

                mat[i][i] = 0

        DIAGONAIS E TRANSFORMA√á√ïES:

            . Transposi√ß√£o

                - diagonal principal vira eixo

                - A[i][j] = A[j][i]

                A diagonal principal √© fixa na transposi√ß√£o.

            . Simetria

                - matriz sim√©trica ‚Üí A[i][j] == A[j][i]

                Conceito central em √°lgebra linear.

        DIAGONAIS L√ìGICAS:

            Voc√™ pode:

                . n√£o percorrer a diagonal fisicamente

                . apenas testar condi√ß√£o

                    if i == j:
                        ...

                Isso evita custo extra.

        ERROS CL√ÅSSICOS:

            . confundir diagonal com linha
            . errar N-1-i
            . esquecer que s√≥ existe em quadradas
            . usar diagonal quando n√£o faz sentido
            . inverter i e j

        DICAS:

            Sempre pergunte:

                Essa matriz √© quadrada?
                Estou falando de qual diagonal?
                A condi√ß√£o √© i==j, i+j, ou j-i?
                Preciso percorrer ou s√≥ testar?
                Ordem de acesso importa?

        FRASES-CHAVE PARA MEMORIZAR:

            Diagonal √© rela√ß√£o de √≠ndices
            Principal: i == j
            Secund√°ria: i + j = N - 1
            Outras diagonais existem
            Muito usadas em DP

    =====================================================================

    Transposi√ß√£o de matriz:

        - Trocar linhas por colunas

        - A transposta de uma matriz A √© a matriz A**T obtida trocando linhas 
        por colunas.

        Se:

            A
             i,j
            
        Ent√£o:
             T
            A‚Äã      ‚Äã=      A
             i,j           i,j

        Exemplo:

            A =
            1 2 3
            4 5 6

            A·µÄ =
            1 4
            2 5
            3 6

        E em computa√ß√£o?

            - Transpor √©:

                trocar eixos

                mudar o significado do acesso

                reorganizar dados 2D

            Em termos de √≠ndices:

                (i, j) ‚Üí (j, i)

        TRANSPOSI√á√ÉO ‚â† ROTA√á√ÉO:

            | Opera√ß√£o        | O que faz                     |
            | --------------- | ----------------------------- |
            | Transposi√ß√£o    | espelha na diagonal principal |
            | Rota√ß√£o         | muda orienta√ß√£o               |
            | Swap de linhas  | troca linhas                  |
            | Swap de colunas | troca colunas                 |

            Muitas pessoas confundem isso.

        FORMAS DE IMPLEMENTAR TRANSPOSI√á√ÉO:

            1) TRANSPOSI√á√ÉO CRIANDO NOVA MATRIZ (CL√ÅSSICA)

                - Funciona para qualquer matriz (retangular ou quadrada).

                Ideia:

                    T[j][i] = A[i][j]

                Em Python puro:

                    T = []
                    for j in range(colunas):
                        linha = []
                        for i in range(linhas):
                            linha.append(A[i][j])
                        T.append(linha)

                . O(n √ó m)

                . Usa mem√≥ria extra

            2) TRANSPOSI√á√ÉO IN PLACE (S√ì MATRIZ QUADRADA)

                - Muito importante para CS/SE.

                S√≥ funciona se:

                    N x N

                Porque:

                    n√∫mero de linhas = n√∫mero de colunas

                Ideia central:

                    mat[i][j] ‚Üî mat[j][i]

                Mas:

                    s√≥ para metade da matriz

                    sen√£o voc√™ desfaz a troca

                Forma correta:

                    for i in range(n):
                        for j in range(i + 1, n):
                            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]

                . Diagonal principal √© eixo

                . N√£o mexe nela

        TRANSPOSI√á√ÉO E DIAGONAIS:

            . diagonal principal fica fixa

            . tudo √© espelhado em rela√ß√£o a ela

            Por isso:

                for j in range(i+1, n)

        TRANSPOSI√á√ÉO E MEM√ìRIA (PONTO DE SE):

            . Python (lista de listas)

                - cada linha √© um objeto
                - acesso mat[j][i] pula refer√™ncias

            . C / NumPy:

                - mem√≥ria cont√≠gua
                - ordem de acesso impacta cache

            . Em sistemas grandes, transposi√ß√£o √© cara.

        TRANSPOSI√á√ÉO COMO OPERA√á√ÉO L√ìGICA:

            - √Äs vezes voc√™ n√£o precisa transpor fisicamente.

            Exemplo:

                def get(i, j):
                    return mat[j][i]

            Isso simula transposi√ß√£o sem custo O(n¬≤).
        
        TRANSPOSI√á√ÉO + SWAP:

            Seu exerc√≠cio de swap:

                mat[i][i] ‚Üî mat[i][c]

            Na transposi√ß√£o:

                mat[i][j] ‚Üî mat[j][i]

            √â o mesmo padr√£o mental:

                trocar posi√ß√µes sim√©tricas

                controlar √≠ndices

                evitar sobrescrita

        ERROS CL√ÅSSICOS:

            tentar in place em matriz n√£o quadrada

            esquecer j > i

            trocar diagonal duas vezes

            confundir transposi√ß√£o com rota√ß√£o

            usar libs sem entender
        
        DICAS:

            Pergunte sempre:

                A matriz √© quadrada?
                Quero in place ou c√≥pia?
                Posso simular transposi√ß√£o?
                A diagonal √© eixo ou alvo?
                O custo importa?

            FRASES-CHAVE PARA MEMORIZAR:

                . Transpor √© trocar eixos
                . (i,j) vira (j,i)
                . In place s√≥ em quadradas
                . Diagonal √© o eixo
                . Swap √© a base

    =====================================================================

    Matriz sim√©trica e assim√©trica:

        Espelhamento estrutural em dados bidimensionais

        Uma matriz A √© sim√©trica se:

                 t
            A = A
        
        Ou seja:

            A       =       A
             i,j             j,i

        A matriz precisa ser quadrada.

        Exemplo:

            2  3  5
            3  7  9
            5  9  1

        Observe:

            (0,1) = (1,0)

            (0,2) = (2,0)

        O QUE √â UMA MATRIZ ASSIM√âTRICA?

            - Aqui existem dois sentidos (muito importante).

            2.1 Assim√©trica (sentido geral / informal)

                . A matriz n√£o √© sim√©trica.

                Basta:

                    A[i][j] ‚â† A[j][i] para algum par

                √â o uso mais comum em programa√ß√£o.

            2.2 Anti-sim√©trica (sentido matem√°tico rigoroso):

                - Uma matriz A √© anti-sim√©trica se:

                     T
                    A = ‚àíA

                Ou seja:

                    A ‚Äã     =   ‚àíA
                     i,j         j,i

                E:

                    . todos os elementos da diagonal principal s√£o zero

                    Tamb√©m exige matriz quadrada.

                Exemplo anti-sim√©trico

                    0   2  -1
                    -2   0   4
                    1  -4   0

        DIAGONAL PRINCIPAL (PONTO-CHAVE):

            | Tipo           | Diagonal       |
            | -------------- | -------------- |
            | Sim√©trica      | qualquer valor |
            | Anti-sim√©trica | sempre zero    |

            Isso √© um teste r√°pido.

        COMO VERIFICAR SE UMA MATRIZ √â SIM√âTRICA:

            L√≥gica:

                Voc√™ n√£o precisa comparar tudo.

                Basta verificar:

                    i < j

                Porque:

                    . o outro lado √© espelho
            
                Pseudoc√≥digo:

                    para i de 0 at√© n-1:
                        para j de i+1 at√© n-1:
                            se A[i][j] != A[j][i]:
                                n√£o √© sim√©trica

                Complexidade: O(n¬≤ / 2).
        
        COMO VERIFICAR MATRIZ ANTI-SIM√âTRICA:

            Condi√ß√µes:

                A[i][i] == 0

                A[i][j] == -A[j][i]

        SIMETRIA E MEM√ìRIA:

            Em matriz sim√©trica:

                - metade dos dados √© redundante

            Voc√™ pode armazenar:

                . apenas tri√¢ngulo superior

                . ou inferior

            Isso reduz mem√≥ria quase pela metade.

        SIMETRIA EM PROGRAMA√á√ÉO DIN√ÇMICA:

            Exemplo:

                dp[i][j] = dp[j][i]

            Permite otimiza√ß√µes e poda de estados.

        SIMETRIA E SWAPS:

            Se voc√™ fizer:

                mat[i][j], mat[j][i] = mat[j][i], mat[i][j]

            Voc√™ est√° for√ßando simetria (ou quebrando).

        ERROS CL√ÅSSICOS

            testar simetria em matriz n√£o quadrada

            comparar tudo (ineficiente)

            confundir anti-sim√©trica com ‚Äún√£o sim√©trica‚Äù

            esquecer diagonal no caso anti-sim√©trico

            usar igualdade exata com floats

        DICAS:

            Pergunte sempre:

                A matriz √© quadrada?

                O crit√©rio √© igualdade ou nega√ß√£o?

                Preciso testar tudo ou metade?

                A diagonal importa?

                Isso √© propriedade ou opera√ß√£o?

        FRASES-CHAVE PARA MEMORIZAR

            . Sim√©trica espelha
            . Anti-sim√©trica inverte sinal
            . Diagonal √© eixo
            . Metade da matriz basta
            . Grafo explica tudo

    =====================================================================

    Matriz quadada e n√£o quadrada:

        - Uma matriz √© quadrada quando o n√∫mero de linhas √© igual ao n√∫mero de 
        colunas.

            A ‚àà R**n√ón

        Exemplos:

            2√ó2
            3√ó3
            100√ó100

                [ a b c ]
                [ d e f ]
                [ g h i ]

        DIFEREN√áA CONCEITUAL (O MAIS IMPORTANTE):

            | Aspecto               | Quadrada | N√£o quadrada  |
            | --------------------- | -------- | ------------- |
            | Linhas = Colunas      | ‚úî        | ‚ùå            |
            | Diagonal principal    | ‚úî        | ‚ùå (formal)   |
            | Transposi√ß√£o in place | ‚úî        | ‚ùå            |
            | Simetria              | ‚úî        | ‚ùå            |
            | Anti-simetria         | ‚úî        | ‚ùå            |
            | Determinante          | ‚úî        | ‚ùå            |
            | Inversa               | ‚úî        | ‚ùå            |
            | Autovalores           | ‚úî        | ‚ùå            |

            90% das propriedades ‚Äúavan√ßadas‚Äù s√≥ existem em matrizes quadradas.

        DIAGONAIS: QUEM TEM E QUEM N√ÉO TEM

            Matriz quadrada:

                diagonal principal ‚Üí mat[i][i]
                diagonal secund√°ria ‚Üí mat[i][n-1-i]
                diagonais paralelas ‚Üí bem definidas

            Matriz n√£o quadrada:

                n√£o h√° diagonal ‚Äúcompleta‚Äù
                existem diagonais parciais
                condi√ß√µes como i == j s√≥ valem enquanto √≠ndices existirem

            Em computa√ß√£o, voc√™ pode percorrer, mas n√£o pode aplicar 
            propriedades matem√°ticas cl√°ssicas.

        TRANSPOSI√á√ÉO: LIMITES CLAROS

            . Quadrada

                transposi√ß√£o in place poss√≠vel
                swap mat[i][j] ‚Üî mat[j][i]

            . N√£o quadrada

                transposi√ß√£o cria nova matriz
                dimens√µes mudam: m√ón ‚Üí n√óm

            Tentar in place aqui √© erro conceitual, n√£o s√≥ t√©cnico.

        SIMETRIA E ANTI-SIMETRIA:

            . S√≥ fazem sentido em matrizes quadradas

            Porque:

                A[i][j] precisa ser comparado com A[j][i]

            Se j n√£o existe como linha ‚Üí imposs√≠vel.

            Em computa√ß√£o, qualquer ‚Äúverifica√ß√£o de simetria‚Äù exige matriz 
            quadrada.
        
        SWAPS: O QUE MUDA

            . Swap de linhas

                - funciona em qualquer matriz

                    mat[i], mat[j] = mat[j], mat[i]

            . Swap de colunas

                - funciona em qualquer matriz (com cuidado)

                    for r in range(linhas):
                        mat[r][c1], mat[r][c2] = mat[r][c2], mat[r][c1]

            . Swap linha ‚Üî coluna

                - s√≥ em matriz quadrada

                Porque:

                    . Linha tem n elementos
                    . coluna precisa ter n posi√ß√µes

        MATRIZ QUADRADA COMO TRANSFORMA√á√ÉO:

            Em matem√°tica e computa√ß√£o:

                . matriz quadrada representa transforma√ß√µes
                . entrada e sa√≠da t√™m mesma dimens√£o

            Estruturalmente, quadrada = transforma√ß√£o do espa√ßo em si mesmo.

        MATRIZ N√ÉO QUADRADA COMO RELA√á√ÉO:

            Matrizes n√£o quadradas modelam:

                . rela√ß√µes entre conjuntos diferentes
                . dados tabulares
                . datasets
                . proje√ß√µes

            Estruturalmente, n√£o quadrada = mapeamento entre espa√ßos distintos.

        MATRIZES E GRAFOS:

            | Tipo de grafo   | Matriz                 |
            | --------------- | ---------------------- |
            | N√£o direcionado | Quadrada e sim√©trica   |
            | Direcionado     | Quadrada e assim√©trica |
            | Bipartido       | N√£o quadrada           |

            Excelente modelo mental.

        MATRIZES E MEM√ìRIA:

            Quadradas:

                . padr√µes de acesso mais previs√≠veis
                . opera√ß√µes sim√©tricas
                . cache-friendly em muitos algoritmos

            N√£o quadradas:

                . acesso mais irregular
                . transposi√ß√£o muda dimens√£o
                . cuidado com ordem dos loops

        ERROS CL√ÅSSICOS:

            tentar acessar mat[i][i] em matriz n√£o quadrada

            assumir simetria sem checar dimens√£o

            tentar transposi√ß√£o in place errada

            aplicar f√≥rmula de diagonal inv√°lida

            misturar linha/coluna por h√°bito

        DICAS:

            Antes de qualquer algoritmo, pergunte:

                Essa matriz √© quadrada?

                Estou usando alguma propriedade que exige isso?

                Transposi√ß√£o muda dimens√£o?

                Linha e coluna t√™m o mesmo tamanho?

                Estou pensando em transforma√ß√£o ou rela√ß√£o?

            Essas perguntas evitam bugs conceituais.

        FRASES-CHAVE PARA MEMORIZAR:

            . Quadrada transforma
            . N√£o quadrada relaciona
            . Diagonal exige quadrada
            . Simetria exige quadrada
            . In place exige quadrada

    =====================================================================

    Matriz circular:

        - Uma matriz circular √© uma matriz em que o acesso aos √≠ndices √© 
        tratado de forma circular, ou seja, sair por um lado faz voc√™ entrar 
        pelo lado oposto.

        Importante:

            . A matriz n√£o muda fisicamente
            . O que muda √© a forma de acessar os √≠ndices

        MODELO MENTAL CORRETO:

            Pense na matriz como um tabuleiro em forma de toro (donut):

                . saiu por cima ‚Üí entra por baixo
                . saiu pela esquerda ‚Üí entra pela direita

            Visualmente (2D circular):

                ‚Üë conecta ‚Üì
                ‚Üê conecta ‚Üí

        MATRIZ LINEAR √ó MATRIZ CIRCULAR:

            | Aspecto                | Linear | Circular       |
            | ---------------------- | ------ | -------------- |
            | √çndices fora do limite | Erro   | Reaproveitados |
            | Uso de `%`             | ‚ùå     | ‚úî              |
            | Estrutura muda         | ‚ùå     | ‚ùå             |
            | Acesso l√≥gico muda     | ‚ùå     | ‚úî              |

            Circularidade √© l√≥gica, n√£o estrutural.

        A CHAVE: M√ìDULO (%):

            - Tudo em matriz circular se baseia em:

                i_circular = i % linhas
                j_circular = j % colunas

            Isso garante:

                . -1 % n ‚Üí √∫ltimo √≠ndice
                . n % n ‚Üí 0

        ACESSO CIRCULAR B√ÅSICO:

                def get(mat, i, j):
                    linhas = len(mat)
                    colunas = len(mat[0])
                    return mat[i % linhas][j % colunas]

            . Esse get transforma qualquer matriz comum em circular.

        MATRIZ CIRCULAR ‚â† ROTA√á√ÉO DE MATRIZ

            | Matriz Circular | Rota√ß√£o        |
            | --------------- | -------------- |
            | muda acesso     | muda estrutura |
            | usa `%`         | usa swaps      |
            | l√≥gica          | f√≠sica         |
            | O(1)            | O(n¬≤)          |

            Matriz circular n√£o move dados.

        VIZINHAN√áA CIRCULAR:

            Em grids, voc√™ costuma acessar vizinhos:

                cima, baixo, esquerda, direita

            Em matriz circular:

                cima     = mat[(i-1) % L][j]
                baixo    = mat[(i+1) % L][j]
                esquerda = mat[i][(j-1) % C]
                direita  = mat[i][(j+1) % C]

            Sem if, sem borda especial.

        MATRIZ CIRCULAR E JANELAS 2D:

            Janela 3√ó3 ao redor de (i,j):

                for di in (-1, 0, 1):
                    for dj in (-1, 0, 1):
                        viz = mat[(i+di) % L][(j+dj) % C]

            . Padr√£o extremamente importante.

        MATRIZ CIRCULAR E SHIFT / ROTA√á√ÉO:

            . shift f√≠sico ‚Üí caro
            . rota√ß√£o f√≠sica ‚Üí cara
            . matriz circular ‚Üí s√≥ √≠ndice

        Exemplo:

            novo_i = (i + deslocamento) % L

        √â a generaliza√ß√£o 2D do vetor circular.

        IMPLEMENTA√á√ÉO F√çSICA √ó L√ìGICA:

            . Circular l√≥gica (preferida)

                usa %

                O(1)

                simples

            . Circular f√≠sica

                usa swaps/rota√ß√µes

                raramente necess√°ria

                mais complexa

        ERROS COMUNS:

            tentar ‚Äúcriar‚Äù matriz circular

            esquecer % em um dos eixos

            confundir rota√ß√£o com circularidade

            usar if desnecess√°rio

            n√£o tratar colunas diferentes de linhas

        DICAS:

            Antes de codar, pergunte:

                Quero mover dados ou s√≥ mudar acesso?

                    As bordas devem se conectar?

                    Posso usar %?

                    Isso √© 1D ou 2D?

                    Circular resolve sem if?

                Se sim ‚Üí matriz circular.

        FRASES-CHAVE PARA MEMORIZAR:

            . Circular √© l√≥gica
            . M√≥dulo conecta bordas
            . N√£o move dados
            . Excelente para grids
            . Evita condi√ß√µes

    =====================================================================

    Tuplas:

        - Tupla √© uma sequ√™ncia ordenada e imut√°vel de elementos.

        . Ordenada: tem posi√ß√£o (√≠ndice).

        . Imut√°vel: depois de criada, voc√™ n√£o altera t[i] = ... (d√° erro).

        . Pode conter tipos misturados: int, str, lista, outra tupla‚Ä¶

        Uso mental:

            ‚Äúquero agrupar valores que pertencem juntos e n√£o devem mudar‚Äù.

        Exemplos:

            . coordenada (x, y)
            . RGB (r, g, b)
            . registro simples (nome, idade, cidade)
            . retorno m√∫ltiplo de fun√ß√£o

        Criando tuplas (detalhe importante):

            EX:

                t1 = (1, 2, 3)
                t2 = 1, 2, 3          # par√™nteses s√£o opcionais
                t3 = (5,)             # tupla de 1 elemento TEM v√≠rgula
                t4 = ()               # tupla vazia

            Erro comum:

                (5)    # isso √© int, n√£o tupla

        √çndices de tuplas:

            Tuplas suportam:

                . √≠ndice positivo e negativo

                    t = ("a", "b", "c")
                    t[0]   # "a"
                    t[-1]  # "c"

        Tamanho de tupla:

            len(t)

        Slicing:

            - Tupla suporta slicing igual lista/string:

                t[1:4]
                t[:3]
                t[::2]
                t[::-1]

            Slicing cria nova tupla (n√£o √© in place).

        M√©todos ‚Äúespeciais‚Äù de tupla:

            - A tupla tem poucos m√©todos ‚Äúnormais‚Äù:

                t.count(x)
                t.index(x)

            Mas ela tem v√°rias propriedades comportamentais importantes:

                . √© hashable se todos os elementos forem hashable (isso permite 
                usar como chave de dict)

                . √© iter√°vel

                . suporta compara√ß√£o lexicogr√°fica

        Compara√ß√£o lexicogr√°fica (muito √∫til):

            (1, 2) < (1, 3)   # True
            (1, 2) < (0, 9)   # False

        Empacotamento e desempacotamento:

            Empacotamento:

                ponto = 10, 20

            Desempacotamento:

                x, y = ponto

            Desempacotamento com ‚Äúresto‚Äù:

                a, *meio, b = (1, 2, 3, 4, 5)
                # a=1, meio=[2,3,4], b=5

            - *meio vira lista por padr√£o.

        Tuplas com outros iter√°veis e com listas:

            Tupla pode conter lista:

                t = (1, [2, 3], 4)

            PS: Imut√°vel n√£o significa ‚Äútudo dentro √© imut√°vel‚Äù.

            Voc√™ n√£o troca t[1], mas pode modificar a lista dentro:

                t[1].append(99)

            Convers√µes (casting):

                tuple([1, 2, 3])       # (1,2,3)
                list((1, 2, 3))        # [1,2,3]
                tuple("abc")           # ('a','b','c')

        Tupla com loops e condi√ß√µes:

            Tupla √© iter√°vel:

                for x in t:
                    ...

            Com condi√ß√£o:

                for x in t:
                    if x > 0:
                        ...

            Com enumerate:

                for i, x in enumerate(t):
                    ...

        Return de dois ou mais dados:

            - Em Python, ‚Äúretornar v√°rios valores‚Äù √© retornar uma tupla:

                    def stats(a, b):
                        return a + b, a * b   # tupla

                    soma, prod = stats(2, 3)

                . Isso √© empacotamento + desempacotamento.

        Concatena√ß√£o de tupla:

                (1, 2) + (3, 4)   # (1,2,3,4)

            PS: Cria nova tupla.

        Repeti√ß√£o de tuplas:

                (1, 2) * 3  # (1,2,1,2,1,2)

            PS: Cuidado com repeti√ß√£o quando a tupla cont√©m listas:

                t = ([0],) * 3
                # repete a MESMA lista 3 vezes (mesma refer√™ncia)

        Tuplas aninhadas:

                t = ((1, 2), (3, 4))
                t[0]      # (1, 2)
                t[0][1]   # 2

            Muito usada para:

                . pontos 2D
                . tabelas fixas
                . ‚Äúregistros‚Äù simples

        Casting para tuplas e de tuplas para outros tipos:

            - J√° vimos tuple() e list(). Tamb√©m:

                set((1, 2, 2))  # {1,2}
                str((1, 2))     # "(1, 2)"

        Ordena√ß√£o de tuplas com sorted:

            - Ordenar lista de tuplas

            Muito comum:

                dados = [("Ana", 20), ("Jo√£o", 18), ("Bia", 25)]
                sorted(dados)  # ordena por nome (primeiro item)

            Por outro campo:

                sorted(dados, key=lambda x: x[1])  # ordena por idade

            . sorted retorna lista, mesmo que a entrada seja tupla.

            Se quiser tupla:

                tuple(sorted(dados))

        ‚ÄúCoisas legais‚Äù com tuplas:

            A) Tupla como ‚Äúregistro leve‚Äù

                usuario = ("Renato", 17, "SP")
                nome, idade, cidade = usuario

            B) Tupla como chave de dicion√°rio (muito poderoso)

                - Se todos os itens forem hashable:

                    visitas = {}
                    pos = (2, 5)          # coordenada
                    visitas[pos] = 1

                Isso √© base de:

                    . grids
                    . grafos
                    . memoization (cache)
                    . mapas 2D usando dict

            C) ‚ÄúIdeia de dicion√°rio com tuplas‚Äù (pares)

                Uma estrutura estilo dicion√°rio pode ser:

                    pares = (("a", 1), ("b", 2), ("c", 3))

                E voc√™ pode converter:

                    d = dict(pares)

                Ou buscar manualmente (menos eficiente):

                    for k, v in pares:
                        if k == "b":
                            ...

            D) Swap e m√∫ltiplas atribui√ß√µes (tuplas por tr√°s)

                a, b = b, a

        Erros comuns:

            . esquecer a v√≠rgula da tupla de 1 elemento: (5,)
            . achar que tupla ‚Äúcongela‚Äù objetos mut√°veis dentro
            . repetir tupla com listas e criar refer√™ncias duplicadas
            . tentar modificar t[i]

    =====================================================================

    Dicion√°rios:

        - Um dicion√°rio √© uma estrutura que associa uma chave a um valor.

        Formalmente:

            chave ‚Üí valor

        Exemplo:

            usuario = {
                "nome": "Renato",
                "idade": 17,
                "cidade": "SP"
            }

        Diferente de listas/tuplas:

            . acesso n√£o √© posicional

            . acesso √© por identidade (chave)

        ESTRUTURA INTERNA:

            Dicion√°rios s√£o implementados com tabelas hash.

                . A chave passa por uma fun√ß√£o hash()

                . O hash define onde o valor √© armazenado

                . Busca m√©dia: O(1)

            Isso √© MUITO mais r√°pido que listas para busca por chave.

        DEFINI√á√ïES IMPORTANTES:

            Chave:

                - deve ser imut√°vel
                - deve ser hashable
                - exemplos: str, int, float, tuple (imut√°vel)

            Valor:

                - pode ser qualquer tipo
                - mut√°vel ou n√£o

            EX:

                { (1, 2): "posi√ß√£o" }   # v√°lido
                { [1, 2]: "posi√ß√£o" }  # ERRO

        CHAVE √ó √çNDICE (EFICI√äNCIA):

            | Estrutura               | Acesso |
            | ----------------------- | ------ |
            | Lista (√≠ndice)          | O(1)   |
            | Lista (busca por valor) | O(n)   |
            | Dicion√°rio (chave)      | O(1)   |

            Pergunta mental:

                ‚ÄúTenho um identificador l√≥gico?‚Äù ‚Üí dicion√°rio

        PROPRIEDADES DOS DICION√ÅRIOS:

            . N√£o permitem chaves duplicadas
            . Inser√ß√£o sobrescreve valor
            . Mant√™m ordem de inser√ß√£o (Python 3.7+)
            . Mut√°veis
            . Iter√°veis

        M√©todos principais de dicion√°rios:

            1) Acesso e leitura:

                . d[key]

                    Acessa o valor. Se a chave n√£o existir ‚Üí KeyError.

                . d.get(key, default=None)

                    Acessa sem erro; se n√£o existir, retorna default.
                    Muito usado para evitar if key in d.

                . d.keys()

                    ‚Äúview‚Äù das chaves (n√£o √© lista). Iter√°vel.
                
                . d.values()

                    ‚Äúview‚Äù dos valores.

                . d.items()

                    ‚Äúview‚Äù de pares (chave, valor) ‚Äî perfeito para loops e sorted.

                As views (keys/values/items) refletem mudan√ßas no dicion√°rio 
                em tempo real.

            2) Inser√ß√£o / atualiza√ß√£o:

                . d[key] = value

                    Insere ou sobrescreve.

                . d.update(outro_dict | iterable_de_pares, **kwargs)

                    Faz ‚Äúmerge‚Äù/atualiza√ß√£o. Chaves repetidas s√£o sobrescritas 
                    pelo q

                    Ex:

                        d.update({"a": 1, "b": 2})
                        d.update([("c", 3), ("d", 4)])
                        d.update(e=5, f=6)

                . Operador de merge (Python 3.9+)

                    d1 | d2 ‚Üí cria novo dict mesclado

                    d1 |= d2 ‚Üí atualiza in place

            3) Remo√ß√£o:

                . del d[key]

                    Remove a chave (se n√£o existir ‚Üí KeyError).

                . d.pop(key, default=_sem)

                    Remove e retorna o valor. Se n√£o existir:

                        sem default ‚Üí KeyError

                        com default ‚Üí retorna default
                
                . d.popitem()

                    Remove e retorna um par (key, value).
                    
                    Hoje remove o √∫ltimo inserido (LIFO).

                    √ötil para consumir/‚Äúdesempilhar‚Äù itens.

                . d.clear()

                    Remove tudo.

            4) Cria√ß√£o e padr√µes √∫teis:

                . dict.fromkeys(iterable, value=None)

                    Cria um dict com chaves vindas do iter√°vel e o mesmo valor 
                    para todas.

                    EX:

                        d = dict.fromkeys(["a", "b", "c"], 0)  # {"a":0, "b":0, "c":0}

                    Cuidado com valor mut√°vel:

                        d = dict.fromkeys(["a","b"], [])  # MESMA lista para as duas chaves

                . d.setdefault(key, default=None)

                    Se a chave existir, retorna o valor.

                    Se n√£o existir, cria com default e retorna default.

                    Muito usado para ‚Äúacumular‚Äù:

                        d.setdefault(chave, []).append(valor)

        Opera√ß√µes/‚Äúfun√ß√µes especiais‚Äù (comportamento do dict):

            1) Pertin√™ncia

                key in d (testa chave, n√£o valor)
                key not in d

            2) Tamanho e itera√ß√£o

                len(d)

                for k in d: itera chaves

                for k, v in d.items(): pares

            3) C√≥pia

                d.copy() ‚Üí c√≥pia rasa (shallow)
                {**d} e d | {} tamb√©m criam c√≥pia rasa

            4) Compara√ß√£o

                d1 == d2 compara por conte√∫do (chaves/valores), n√£o por ordem

                d1 is d2 compara identidade (mesmo objeto)

            5) Ordena√ß√£o

                Dicion√°rio n√£o ‚Äúse ordena‚Äù por m√©todo pr√≥prio; voc√™ ordena os 
                itens:

                    sorted(d.items())  # por chave
                    sorted(d.items(), key=lambda kv: kv[1])  # por valor

                E se quiser de volta dict:

                    d_ordenado = dict(sorted(d.items()))

        Padr√µes de uso:

            1) Contagem (histograma)

                Padr√£o com get:

                    d[x] = d.get(x, 0) + 1

                ou com setdefault.

            2) Agrupamento

                grupos.setdefault(chave, []).append(item)

            3) Tabela de decis√£o (dispatch)

                acoes = {"soma": soma, "sub": sub}
                acoes.get(op, erro)()

            4) ‚ÄúMerge‚Äù de configura√ß√µes

                config = padrao | usuario

        DICION√ÅRIOS COM LOOPS E CONDI√á√ïES:

            . Iterar chaves:

                for k in d:
                    ...

            . Iterar valores:

                for v in d.values():
                    ...

            . Iterar pares:

                for k, v in d.items():
                    ...

            . Condi√ß√µes:

                if "idade" in usuario:
                    ...

        kwargs (IMPORTANT√çSSIMO):

            Em fun√ß√µes:

                def f(**kwargs):
                    print(kwargs)

            Chamada:

                f(nome="Ana", idade=20)

            kwargs √© um dicion√°rio.

        EMPACOTAMENTO E DESEMPACOTAMENTO:

            . Desempacotar em fun√ß√£o

                dados = {"a":1, "b":2}
                f(**dados)

            . Unir dicion√°rios

                novo = {**d1, **d2}

            Ordem importa ‚Üí sobrescrita.

        DICION√ÅRIOS ANINHADOS:

            EX:

                usuarios = {
                    "u1": {"nome":"Ana", "idade":20},
                    "u2": {"nome":"Jo√£o", "idade":30}
                }

            Acesso:

                usuarios["u1"]["idade"]

            Base de JSON, APIs e configs.

        DICION√ÅRIOS COM OUTROS ITER√ÅVEIS:

            . Lista de tuplas

                dict([("a",1), ("b",2)])

            . Zip

                dict(zip(chaves, valores))

        SOBRESCRITA (CUIDADO!):

                d = {"a":1}
                d["a"] = 99

            . N√£o cria nova chave, substitui.

        SWAP COM DICION√ÅRIOS:

            swap de valores:

                d["a"], d["b"] = d["b"], d["a"]

            Trocar chaves (menos comum):

                exige reconstru√ß√£o

            swap em dict √© l√≥gico, n√£o estrutural.

        M√âTODO dict() (VERS√ÅTIL):

            EX:

                dict(a=1, b=2)
                dict([("a",1), ("b",2)])

            Muito usado em APIs e convers√µes.

        DICION√ÅRIO INVERTIDO:

                inv = {v: k for k, v in d.items()}

            . S√≥ funciona se os valores forem:

                . √∫nicos

                . hashable

        DICION√ÅRIO ORDENADO:

            Desde Python 3.7+:

                dict mant√©m ordem de inser√ß√£o

            Para ordenar:

                dict(sorted(d.items()))

            Ou por valor:

                dict(sorted(d.items(), key=lambda x: x[1]))

        DICION√ÅRIO COM FUN√á√ïES (ESTRAT√âGIA):

            EX:

                ops = {
                    "soma": lambda a,b: a+b,
                    "sub": lambda a,b: a-b
                }

            Uso:

                ops["soma"](2,3)

            Isso substitui if/elif.

        FUN√á√ïES COM DICION√ÅRIOS:

            . entrada como config
            . retorno estruturado
            . m√∫ltiplos resultados
            . estado acumulado

            EX:

                def stats(nums):
                    return {
                        "min": min(nums),
                        "max": max(nums)
                    }

        DICION√ÅRIOS COMO TABELAS DE DECIS√ÉO (MUITO IMPORTANTE)

            Em vez de:

                if x == 1: ...
                elif x == 2: ...

            Use:

                acoes = {
                    1: func1,
                    2: func2
                }
                acoes[x]()

            Isso √©:

                . mais limpo
                . extens√≠vel
                . escal√°vel

        FRASES-CHAVE PARA MEMORIZAR:

            Dicion√°rio mapeia
            Chave √© identidade
            Hash √© O(1)
            Base de APIs
            Substitui ifs

        Erros comuns:

            for x in d: achar que x √© valor (na verdade √© chave)
            in em dict testa chave, n√£o valor
            fromkeys(..., []) cria listas compartilhadas
            usar d[key] sem garantir que a chave existe (prefira get quando fizer sentido)
            usar lista como chave
            esquecer .items()
            sobrescrever sem perceber
            iterar achando que vem ordenado por valor
            usar dict quando lista bastava (ou vice-versa)

    =====================================================================

    Conjuntos:

        - Set √© uma cole√ß√£o n√£o ordenada, mut√°vel e sem elementos duplicados.

        Modelo mental:

            ‚ÄúQuero saber se algo existe‚Äù

            ‚ÄúQuero remover duplicatas‚Äù

            ‚ÄúQuero comparar grupos‚Äù

        Exemplo:

            s = {1, 2, 3}

        Defini√ß√µes importantes:

            . Sem ordem (n√£o use √≠ndices)

            . Sem duplicatas

            . Mut√°vel (voc√™ adiciona/remove)

            . Elementos devem ser hashable (imut√°veis)

            V√°lido:

                {1, "a", (2, 3)}

            Inv√°lido:

                {[1, 2], {"a": 1}}  # erro

        Criando sets:

            set()              # conjunto vazio
            {1, 2, 3}          # literal
            set([1, 2, 2, 3])  # {1,2,3}
            set("banana")      # {'b','a','n'}

        PS: {} cria dicion√°rio, n√£o set.

        Set √ó Lista √ó Tupla √ó Dict (quando usar):

            | Estrutura | Uso ideal              |
            | --------- | ---------------------- |
            | list      | ordem, √≠ndices         |
            | tuple     | dados imut√°veis        |
            | dict      | chave ‚Üí valor          |
            | set       | pertin√™ncia, unicidade |

            Busca em set √© O(1) (hash).

        Opera√ß√µes fundamentais (o cora√ß√£o dos sets):

            . Pertin√™ncia

                    x in s
                    x not in s

                - Muito mais r√°pido que lista.

            . Uni√£o

                    A | B
                    A.union(B)

            . Interse√ß√£o

                    A & B
                    A.intersection(B)

            . Diferen√ßa

                    A - B
                    A.difference(B)

            . Diferen√ßa sim√©trica

                    A ^ B
                    A.symmetric_difference(B)

            Isso √© matem√°tica pura aplicada a c√≥digo.

        M√©todos principais de set:

            . Adi√ß√£o

                    s.add(x)
                    s.update(iteravel)

            . Remo√ß√£o

                    s.remove(x)     # erro se n√£o existir
                    s.discard(x)    # n√£o gera erro
                    s.pop()         # remove elemento arbitr√°rio
                    s.clear()

            . C√≥pia

                    s.copy()

        Compara√ß√µes e rela√ß√µes:

                A == B
                A <= B   # subconjunto
                A < B    # subconjunto pr√≥prio
                A >= B
                A.isdisjoint(B)  # n√£o t√™m elementos em comum

        Sets com loops e condi√ß√µes:

                for x in s:
                    if x > 0:
                        ...

            - Ordem n√£o garantida.

        Set comprehension:

                quadrados = {x*x for x in range(10) if x % 2 == 0}

            - Muito usado para filtros r√°pidos.

        Convers√µes (casting):

                set(lista)
                list(set(lista))     # remove duplicatas
                tuple(set(lista))

            Ordem pode mudar.

        Sets e fun√ß√µes:

                def comuns(a, b):
                    return set(a) & set(b)

            - Retorno ideal quando a ordem n√£o importa.

        Sets e dicion√°rios:

            . dict.keys() se comporta como um set

                d.keys() & outro_set

            Muito poderoso em valida√ß√µes.

        Frozenset (set imut√°vel):

                fs = frozenset([1, 2, 3])

            . imut√°vel
            . hashable
            . pode ser chave de dicion√°rio

            Usado em cache, grafos, estados.

        Erros comuns:

            . tentar indexar set (s[0])
            . assumir ordem
            . usar remove quando deveria discard
            . colocar mut√°veis dentro 
            . usar set quando precisa de ordem

        Dicas:

            Pergunte sempre:

                Preciso de ordem?

                Preciso de duplicatas?

                Vou testar pertin√™ncia muitas vezes?

                Opera√ß√µes de conjunto resolvem?

            Se sim ‚Üí set.

        Frases-chave para memorizar:

            . Set n√£o ordena
            . Set elimina duplicata
            . Set testa r√°pido
            . Set √© matem√°tica viva

    =====================================================================

    tecnica de ponteiros (1 ou mais ponteiros):

        - Ponteiro √© uma vari√°vel que aponta para uma posi√ß√£o de uma estrutura 
        de dados.

        Em Python:

            . o ‚Äúponteiro‚Äù normalmente √© um √≠ndice

            . ou uma refer√™ncia que se move

        Voc√™ n√£o move dados, voc√™ move o acesso.

        UM PONTEIRO (Single Pointer):

            - Um √≠ndice que percorre a estrutura de forma controlada.

            EX:

                i = 0
                while i < len(lista):
                    # usa lista[i]
                    i += 1

            Isso √© a base de:

                . varreduras
                . contagem
                . busca linear
                . parsing

            Quando usar:

                . voc√™ precisa visitar todos os elementos
                . a decis√£o depende apenas do elemento atual

        DOIS PONTEIROS (Two Pointers):

            - Usar dois √≠ndices independentes que se movem com regras pr√≥prias.

            Existem tr√™s padr√µes cl√°ssicos.

            . PADR√ÉO 1 ‚Äî Ponteiros convergentes (esquerda ‚Üî direita):

                i ‚Üí        ‚Üê j

                Exemplo:

                    i = 0
                    j = len(lista) - 1

                    while i < j:
                        # usa lista[i] e lista[j]
                        i += 1
                        j -= 1

                Usos cl√°ssicos

                    . inverter lista/string
                    . verificar pal√≠ndromo
                    . comparar extremos
                    . swaps sim√©tricos

                Voc√™ j√° usou isso sem perceber.

            . PADR√ÉO 2 ‚Äî Ponteiros na mesma dire√ß√£o (r√°pido / lento):

                slow ‚Üí ‚Üí ‚Üí
                fast ‚Üí ‚Üí ‚Üí ‚Üí

                EX:

                    slow = 0
                    for fast in range(len(lista)):
                        if condicao(lista[fast]):
                            lista[slow] = lista[fast]
                            slow += 1

                Usos cl√°ssicos

                    . remover elementos in place
                    . filtrar lista sem criar outra
                    . remover duplicatas
                    . compacta√ß√£o

                Muito usado em entrevistas e c√≥digo profissional.

            . PADR√ÉO 3 ‚Äî Ponteiros em duas estruturas:

                EX:

                    i = j = 0
                    while i < len(a) and j < len(b):
                        if a[i] < b[j]:
                            i += 1
                        else:
                            j += 1

                Usos cl√°ssicos:

                    . merge de listas ordenadas
                    . interse√ß√£o eficiente
                    . compara√ß√£o de streams

                Base do merge sort.

        MAIS DE DOIS PONTEIROS:

            Quando aparece

                janelas
                
                matrizes
                
                parsing avan√ßado
                
                estados m√∫ltiplos

            Exemplo:

                i, j, k = 0, 1, len(lista)-1

            O importante √©:

                cada ponteiro tem uma responsabilidade clara

        PONTEIROS + CONDICIONAIS (CHAVE):

            - Ponteiros s√≥ funcionam bem quando o movimento depende de condi√ß√µes.

            Exemplo:

                if soma < alvo:
                    i += 1
                else:
                    j -= 1

            Isso evita loops aninhados.

        PONTEIROS √ó LOOPS ANINHADOS

            | Abordagem    | Complexidade |
            | ------------ | ------------ |
            | Dois `for`   | O(n¬≤)        |
            | Two pointers | O(n)         |

            Isso √© otimiza√ß√£o algor√≠tmica real.

        PONTEIROS + JANELAS (SLIDING WINDOW)

            - Janela √© um caso especial de dois ponteiros:

                left = 0
                for right in range(n):
                    # expande
                    while condicao:
                        left += 1

            Voc√™ controla:

                expans√£o

                contra√ß√£o

        PONTEIROS EM STRINGS:

            - Strings s√£o imut√°veis, mas os ponteiros funcionam igual:

            EX:

                i = 0
                j = len(s) - 1

                while i < j:
                    if s[i] != s[j]:
                        return False
                    i += 1
                    j -= 1

            Base de valida√ß√µes de texto.

        PONTEIROS EM MATRIZES:

            Exemplo:

                percorrer diagonal

                swap sim√©trico

                vizinhan√ßa

            
            C√≥d ex:

                i = j = 0
                while i < n:
                    mat[i][j]
                    i += 1
                    j += 1

            Ponteiros aqui s√£o pares (i, j).

        PONTEIROS √ó ITERADORES

            . for x in lista ‚Üí iterador impl√≠cito
            . ponteiros ‚Üí controle expl√≠cito

            Use ponteiros quando:

                . o passo n√£o √© sempre +1
                . voc√™ precisa voltar, pular, sincronizar

        ERROS COMUNS:

            mover ponteiro errado

            esquecer condi√ß√£o de parada

            confundir i < j com i <= j

            sobrescrever dados in place

            usar ponteiros quando lista simples bastava

        COMO PENSAR (MENTALIDADE):

            Antes de codar, pergunte:

                1. Quantos acessos simult√¢neos preciso?
                2. Eles se movem juntos ou independentes?
                3. Quando cada ponteiro avan√ßa?
                4. Posso eliminar um loop aninhado?
                5. D√° para fazer in place?

            Se sim ‚Üí ponteiros.

        FRASES-CHAVE PARA MEMORIZAR:

            . Ponteiro move acesso
            . Dois ponteiros economizam tempo
            . Janela √© ponteiro disfar√ßado
            . O(n) vence O(n¬≤)
            . Controle √© tudo

    =====================================================================

    Divis√£o e conquista (Divide and Conquer):

        - Quebre um problema grande em problemas menores do mesmo tipo, 
        resolva os menores e combine os resultados.

        Essa frase √© tudo.

        Se voc√™ entende isso, entendeu a t√©cnica.

        O MODELO MENTAL CORRETO:

            Divis√£o e conquista sempre segue 3 etapas fixas:

                1. Dividir

                    Quebrar o problema em subproblemas menores, semelhantes ao 
                    original.

                2. Conquistar

                    Resolver os subproblemas:

                        . diretamente (caso base), ou

                        . chamando o mesmo algoritmo (recurs√£o)

                3. Combinar

                    Juntar as solu√ß√µes dos subproblemas para resolver o problema 
                    maior.

                    Se n√£o existe uma etapa clara de combina√ß√£o, provavelmente 
                    n√£o √© divis√£o e conquista.
    
            POR QUE ESSA T√âCNICA EXISTE?

                Porque muitos problemas:

                    . ficam intrat√°veis quando resolvidos de uma vez

                    . mas ficam simples quando quebrados

                Exemplo mental:

                    . ordenar 1 milh√£o de n√∫meros de uma vez ‚Üí dif√≠cil

                    . ordenar dois blocos de 500 mil ‚Üí mais f√°cil

                    . juntar os dois ordenados ‚Üí simples

            DIVIS√ÉO E CONQUISTA √ó FOR√áA BRUTA:

                | For√ßa bruta             | Divis√£o e conquista   |
                | ----------------------- | --------------------- |
                | Resolve tudo de uma vez | Divide o problema     |
                | Muitos loops            | Estrutura recursiva   |
                | Geralmente O(n¬≤)        | Geralmente O(n log n) |
                | Simples, mas lenta      | Elegante e eficiente  |

                Divis√£o e conquista √© otimiza√ß√£o estrutural, n√£o 
                micro-otimiza√ß√£o.

        RELA√á√ÉO COM RECURS√ÉO (IMPORTANTE):

            Quase toda divis√£o e conquista usa recurs√£o, mas:

                - nem toda recurs√£o √© divis√£o e conquista

            Diferen√ßa:

                Recurs√£o simples ‚Üí problema diminui linearmente

                Divis√£o e conquista ‚Üí problema se divide em v√°rios subproblemas

            Exemplo:

                Recurs√£o simples: n ‚Üí n-1
                Divis√£o e conquista: n ‚Üí n/2 + n/2

        CASO BASE (O PONTO CR√çTICO):

            Todo algoritmo de divis√£o e conquista precisa de um caso base, que 
            seja:

                simples

                resolvido diretamente

                sem nova divis√£o

            Exemplos:

                lista com 0 ou 1 elemento

                intervalo vazio

                submatriz 1√ó1

            Sem caso base ‚Üí stack overflow.

        COMPLEXIDADE (INTUI√á√ÉO, N√ÉO F√ìRMULA):

            O padr√£o cl√°ssico √©:

                T(n) = 2T(n/2) + O(n)

            Resultado t√≠pico:

                O(n log n)

            Isso explica por que esses algoritmos escalam t√£o bem.

        DIVIS√ÉO E CONQUISTA EM ARRAYS E LISTAS:

            Exemplo conceitual:

                somar uma lista

                dividir em duas metades

                somar cada metade

                somar os resultados

            N√£o √© o jeito mais r√°pido para somar, mas √© did√°tico.

        DIVIS√ÉO E CONQUISTA EM MATRIZES:

            Muito comum:

                dividir em quadrantes

                resolver cada bloco

                combinar

            Exemplos de uso:

                processamento de imagens

                compress√£o

                multiplica√ß√£o de matrizes (Strassen)

                jogos e simula√ß√µes

        QUANDO USAR DIVIS√ÉO E CONQUISTA:

            Use quando:

                o problema pode ser dividido em partes independentes

                as partes s√£o do mesmo tipo do problema original

                combinar resultados √© simples

                a divis√£o reduz bastante o tamanho

            N√£o use quando:

                os subproblemas dependem fortemente entre si

                o custo de dividir √© maior que resolver direto

                um loop simples resolve melhor

        ERROS COMUNS:

            dividir mas n√£o combinar

            dividir de forma desigual sem motivo

            esquecer o caso base

            criar muitas c√≥pias (custo alto)

            usar divis√£o e conquista s√≥ ‚Äúporque sim‚Äù

        COMO PENSAR (MENTALIDADE)

            Antes de tentar usar a t√©cnica, pergunte:

                1. Consigo dividir o problema em partes semelhantes?
                2. Resolver metade √© significativamente mais f√°cil?
                3. Como vou combinar as respostas?
                4. Qual √© o caso base?
                5. O custo total compensa?

            Se voc√™ responde essas perguntas, o algoritmo praticamente se 
            escreve sozinho.

        FRASES-CHAVE PARA MEMORIZAR:

            Dividir √© reduzir
            Conquistar √© resolver
            Combinar √© a alma
            Caso base salva a pilha
            O(n log n) nasce aqui

    =====================================================================

    n√∫meros aleat√≥rios:

        Computadores s√£o determin√≠sticos.

        Ent√£o‚Ä¶ como algo determin√≠stico ‚Äúgera aleatoriedade‚Äù?

        Resposta curta: n√£o gera aleatoriedade verdadeira, gera 
        pseudoaleatoriedade.

        ALEATORIEDADE NA MATEM√ÅTICA:

            Na matem√°tica, um processo aleat√≥rio:

                n√£o √© previs√≠vel

                n√£o tem padr√£o detect√°vel

                cada evento tem probabilidade bem definida

            Exemplo ideal:

                lan√ßamento de moeda perfeita

                ru√≠do t√©rmico

                decaimento radioativo

            Isso √© aleatoriedade verdadeira (f√≠sica).

        PSEUDOALEATORIEDADE (O QUE COMPUTADORES FAZEM):

            Pseudoaleat√≥rio = parece aleat√≥rio, mas √© gerado por um algoritmo 
            determin√≠stico.

            Caracter√≠sticas:

                come√ßa com um valor inicial (seed)

                produz uma sequ√™ncia longa

                estatisticamente ‚Äúboa‚Äù

                reprodut√≠vel

            Reprodutibilidade √© uma VANTAGEM enorme em software.

        O CONCEITO DE SEED (SEMENTE)

                seed ‚Üí sequ√™ncia

            Se:

                mesma seed ‚Üí mesma sequ√™ncia

                seed diferente ‚Üí sequ√™ncia diferente

            Exemplo mental:

                seed = 42

            Isso permite:

                testes reproduz√≠veis

                simula√ß√µes controladas

                depura√ß√£o

        ALGORITMOS CL√ÅSSICOS DE PSEUDOALEATORIEDADE:

            . Linear Congruential Generator (LCG)

                Um dos mais antigos:

                    X   ‚Äã = (aX  +  c) mod m
                     n+1      n

                Simples, r√°pido, mas previs√≠vel.

            . Mersenne Twister (Python usa!)

                . per√≠odo enorme: 2**19937 ‚àí 1

                . excelente distribui√ß√£o estat√≠stica

                . r√°pido

                . n√£o √© criptograficamente seguro

                Esse √© o cora√ß√£o do random do Python.

        ALEAT√ìRIO √ó CRIPTOGRAFICAMENTE SEGURO:

            | Tipo         | Uso                       |
            | ------------ | ------------------------- |
            | `random`     | simula√ß√µes, jogos, testes |
            | `secrets`    | senhas, tokens, seguran√ßa |
            | hardware RNG | criptografia real         |

            Nunca use random para:

                senha

                token

                chave de seguran√ßa

        O M√ìDULO random (PYTHON):

                import random

            Ele √© um gerador pseudoaleat√≥rio global, baseado no Mersenne Twister.

        SEED NO PYTHON:

                random.seed(10)

            Ap√≥s isso, a sequ√™ncia √© previs√≠vel.

        Uso t√≠pico:

            testes

            exemplos

            simula√ß√µes cient√≠ficas

        FUN√á√ïES PRINCIPAIS DO random:

            . random.random()

                random.random()  # float em [0.0, 1.0)

            . random.randint(a, b)

                random.randint(1, 6)  # inteiro entre 1 e 6 (inclusive)

            . random.randrange(start, stop, step)

                    random.randrange(0, 10, 2)

                - Parecido com range.

            . random.uniform(a, b)

                    random.uniform(1.5, 3.5)

                Float cont√≠nuo.

        ALEAT√ìRIO COM ITER√ÅVEIS:

            . random.choice(seq)

                random.choice(lista)

            . random.sample(seq, k)

                    random.sample(lista, 3)

                N√£o repete.

            . random.shuffle(lista)

                    random.shuffle(lista)

                In place (usa swaps).

        DISTRIBUI√á√ïES (IMPORTANTE):

            . Normal (Gaussiana)

                    random.gauss(mu, sigma)

                Muito usada em:

                    estat√≠stica

                    IA

                    simula√ß√µes

            . Outras

                expovariate

                betavariate

                triangular

                - O random √© mais matem√°tico do que parece.

        O M√ìDULO SECRETS

            - random N√ÉO √© seguro para seguran√ßa.

            . random ‚Üí r√°pido, previs√≠vel com seed

            . secrets ‚Üí imprevis√≠vel, pr√≥prio para seguran√ßa

            Em termos t√©cnicos:

                . random = pseudoaleat√≥rio determin√≠stico

                . secrets = CSPRNG (Cryptographically Secure PRNG)

            DE ONDE VEM A ALEATORIEDADE DO secrets?

                secrets usa fontes do sistema operacional, como:

                    ru√≠do do hardware

                    eventos imprevis√≠veis

                    pools de entropia do kernel

                Em Python:

                    secrets ‚Üí os.urandom()

                Isso √© o mais pr√≥ximo de ‚Äúaleatoriedade real‚Äù que um software 
                comum consegue.

            QUANDO USAR secrets (REGRA DE OURO):

                Use secrets sempre que houver:

                    senha

                    token

                    chave

                    link de reset

                    autentica√ß√£o

                    sess√£o

                    API key

                Nunca use random nesses casos.

            FUN√á√ïES PRINCIPAIS DO secrets

                    import secrets

                . secrets.randbelow(n)

                    Inteiro seguro em [0, n)

                        secrets.randbelow(10)

                    Substitui random.randrange em seguran√ßa.

                . secrets.choice(seq)

                    Escolhe elemento de forma segura

                        secrets.choice("abcdef012345")

                    Ideal para gerar senhas.

                . secrets.token_bytes(n)

                    Gera bytes aleat√≥rios seguros

                        secrets.token_bytes(16)

                    Base de chaves criptogr√°ficas.

                . secrets.token_hex(n):

                    Retorna string hexadecimal

                        secrets.token_hex(16)

                    Muito usado em tokens de API.

                . secrets.token_urlsafe(n)

                    Token seguro para URLs

                        secrets.token_urlsafe(16)

                    Perfeito para:

                        links de ativa√ß√£o

                        reset de senha

            secrets √ó random (COMPARA√á√ÉO FINAL)

            | Aspecto          | random | secrets |
            | ---------------- | ------ | ------- |
            | Previs√≠vel       | ‚úî      | ‚ùå      |
            | Reprodut√≠vel     | ‚úî      | ‚ùå      |
            | Seguro           | ‚ùå     | ‚úî       |
            | R√°pido           | ‚úî      | ‚ùå      |
            | Jogos/simula√ß√µes | ‚úî      | ‚ùå      |
            | Senhas/tokens    | ‚ùå     | ‚úî       |

            Escolher errado aqui √© falha grave de seguran√ßa.

        GERANDO SENHAS (EXEMPLO CONCEITUAL):

                alfabeto = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%"
                senha = "".join(secrets.choice(alfabeto) for _ in range(12))

            - sso √© seguran√ßa correta.

        secrets E DISTRIBUI√á√ïES:

            Importante:

                    secrets n√£o oferece distribui√ß√µes estat√≠sticas
                    
                    s√≥ oferece uniformidade segura

                Se voc√™ precisa de estat√≠stica ‚Üí random
                Se precisa de seguran√ßa ‚Üí secrets

        ERROS COMUNS

            achar que random √© ‚Äúverdadeiro‚Äù

            usar random para seguran√ßa

            esquecer seed em testes

            achar que distribui√ß√£o √© sempre uniforme

            confundir choice com sample

            usar random para senha

            usar seed achando que melhora seguran√ßa

            misturar random e secrets

            achar que secrets √© ‚Äúmelhor para tudo‚Äù


        COMO PENSAR (MENTALIDADE)

            Pergunte:

                Preciso de reprodutibilidade?
                
                Preciso de seguran√ßa?
                
                Preciso de distribui√ß√£o espec√≠fica?
                
                Posso modificar a lista in place?
                
                Isso √© estat√≠stica ou l√≥gica?

            Caso de secrets:

                Isso pode ser previsto por um atacante?

                Isso envolve autentica√ß√£o?

                Isso gera identidade secreta?

        FRASES-CHAVE PARA MEMORIZAR:

            Computador n√£o cria caos
            Random √© determin√≠stico
            Seed controla tudo
            Mersenne domina
            Seguran√ßa ‚â† random

    =====================================================================

    regex:

        - Regex √© uma linguagem para descrever padr√µes em texto.

        . N√£o √© Python.
        . N√£o √© algoritmo comum.
        . √â uma mini-linguagem declarativa.

        Voc√™ n√£o diz como procurar, voc√™ diz o padr√£o.

        Modelo mental correto:

            ‚ÄúRegex descreve o que eu aceito, n√£o como eu procuro‚Äù.

        POR QUE REGEX EXISTE?

            Porque texto √© ca√≥tico:

                valida√ß√µes (email, CPF, telefone)

                parsing

                logs

                scraping

                substitui√ß√µes em massa

            Sem regex:

                dezenas de if

                loops confusos

                c√≥digo fr√°gil

            Com regex:

                1 linha resolve (√†s vezes)

        REGEX N√ÉO √â M√ÅGICA (√â DETERMIN√çSTICA):

            Regex:

                percorre o texto

                tenta casar o padr√£o

                segue regras bem definidas

            O terror vem porque:

                s√≠mbolos parecem criptografia

                erros s√£o silenciosos

                leitura n√£o √© intuitiva no come√ßo

        REGEX NO PYTHON (re):

            M√ìDULO:

                import re

            Fun√ß√µes principais:

                re.search

                re.match

                re.findall

                re.sub

                re.split

        O ALFABETO DO REGEX (ESSENCIAL):

            . Literais

                    a  b  1  @

                Casam exatamente com o caractere.

            . Metacaracteres (os famosos)

                    .  ^  $  *  +  ?  { }  [ ]  ( )  |  \

                Eles t√™m significado especial.

        CLASSES DE CARACTERES:

            . B√°sicas:

                | Padr√£o | Significado          |
                | ------ | -------------------- |
                | `.`    | qualquer caractere   |
                | `\d`   | d√≠gito (0‚Äì9)         |
                | `\D`   | n√£o d√≠gito           |
                | `\w`   | letra, n√∫mero ou `_` |
                | `\W`   | n√£o `\w`             |
                | `\s`   | espa√ßo               |
                | `\S`   | n√£o espa√ßo           |

            . Conjuntos:

                [abc]     ‚Üí a ou b ou c
                [a-z]     ‚Üí letras min√∫sculas
                [0-9]     ‚Üí d√≠gitos
                [^0-9]    ‚Üí tudo exceto d√≠gitos

            Isso j√° resolve MUITA coisa.

        QUANTIFICADORES:

            | S√≠mbolo | Significado  |
            | ------- | ------------ |
            | `*`     | 0 ou mais    |
            | `+`     | 1 ou mais    |
            | `?`     | 0 ou 1       |
            | `{n}`   | exatamente n |
            | `{n,}`  | n ou mais    |
            | `{n,m}` | entre n e m  |

            Exemplo:

                \d+    ‚Üí um ou mais d√≠gitos

        √ÇNCORAS (POSI√á√ÉO NO TEXTO):

            | S√≠mbolo | Significado      |
            | ------- | ---------------- |
            | `^`     | in√≠cio da string |
            | `$`     | fim da string    |

            Exemplo:

                ^\d+$   ‚Üí string inteira s√≥ com n√∫meros

            Isso √© valida√ß√£o, n√£o busca solta.

        GRUPOS:

            . Grupos com par√™nteses

                (\d{2})-(\d{2})

            No Python:

                m = re.search(r"(\d{2})-(\d{2})", texto)
                m.group(1)
                m.group(2)

            Grupos servem para:

                extrair partes

                reutilizar padr√µes

                substituir com controle

        match √ó search √ó findall:

            | Fun√ß√£o    | O que faz                    |
            | --------- | ---------------------------- |
            | `match`   | casa s√≥ no in√≠cio            |
            | `search`  | casa em qualquer lugar       |
            | `findall` | retorna todas as ocorr√™ncias |

            90% das vezes voc√™ quer search ou findall.

        SUBSTITUI√á√ÉO (re.sub):

                re.sub(r"\d", "#", texto)

            Troca poderosa:

                limpar dados

                mascarar informa√ß√µes

                normalizar texto

        RAW STRING (MUITO IMPORTANTE):

            Sempre use:

                r"\d+"

            Evita conflitos com \n, \t, etc.

            Erro cl√°ssico de iniciante.

        REGEX √â GREEDY (GANANCIOSO):

            Por padr√£o:

                .* 

            - pega o m√°ximo poss√≠vel

            Vers√£o ‚Äún√£o gananciosa‚Äù:

                .*?

            Isso evita capturar demais.

        ERROS COMUNS (MUITO IMPORTANTES)

            esquecer r""

            usar match achando que busca tudo

            n√£o usar ^ e $ em valida√ß√£o

            regex muito complexa (ileg√≠vel)

            tentar resolver tudo com regex

            - Regex √© ferramenta, n√£o religi√£o.

        COMO APRENDER REGEX SEM SOFRER:

            Comece simples

            Teste sempre (regex101.com √© ouro)
            
            Leia regex da esquerda para a direita
            
            Pense em classes, n√£o em letras
            
            Quebre regex grande em partes

        FRASES-CHAVE PARA MEMORIZAR

            . Regex descreve padr√£o
            . N√£o √© algoritmo
            . Gan√¢ncia √© padr√£o
            . Raw string √© regra
            . Simples > complexo

    =====================================================================

    M√≥dulos, Bibliotecas e importa√ß√µes:

        . M√≥dulo: um arquivo .py (ex: utils.py)

        . Pacote (package): uma pasta com c√≥digo Python (hoje em dia pode ser 
        ‚Äúpackage‚Äù mesmo sem __init__.py, mas na pr√°tica ele ainda √© muito √∫til)

        . Biblioteca: um conjunto de m√≥dulos/pacotes (ex: requests, numpy), 
        normalmente instalado via pip

        import comum vs from ... import ...:

            import comum

                    import math
                    import meu_modulo

                . Voc√™ acessa com prefixo: math.sqrt(9)
                . Evita conflitos de nomes
                . Mais claro em projetos grandes

            from ... import ...

                    from math import sqrt
                    from pacote.modulo import func

                . Importa ‚Äúdireto‚Äù no namespace atual

                . Pode ficar confuso se voc√™ importar muitas coisas com nomes 
                comuns

            from ... import * (evite)

                . Polui o namespace

                . Dificulta leitura e debug

        Alias (as):

            Alias √© pra:

                encurtar nome

                evitar conflito

                padronizar

            S√£o apelidos dados a m√≥dulos ou fun√ß√µes do m√≥dulo.

            EX:

                import numpy as np
                import pandas as pd
                from datetime import datetime as dt

            Import relativo: . e .. (o que s√£o de verdade)

                Isso s√≥ faz sentido dentro de um pacote.

                . from . import x ‚Üí do pacote atual

                . from .. import y ‚Üí do pacote ‚Äúpai‚Äù

            Exemplo (estrutura):

                meuprojeto/
                app/
                    __init__.py
                    core/
                    __init__.py
                    config.py
                    services/
                    __init__.py
                    auth.py
                    main.py

            Dentro de services/auth.py:

                from ..core.config import SETTINGS

            Import relativo falha se voc√™ roda o arquivo ‚Äúsolto‚Äù (tipo python 
            app/services/auth.py).
            
            Ele funciona quando voc√™ roda como m√≥dulo (j√° j√° te mostro o jeito 
            certo).

        O erro mais comum: ‚Äúquando importo fora da pasta d√° erro‚Äù:

            Isso acontece por causa de uma regra simples:

                Python importa coisas a partir do que est√° no sys.path.
                
                E o primeiro item do sys.path costuma ser a pasta de onde voc√™ 
                executou (current working directory) ou o script principal.

            Ent√£o:

                . rodar python main.py a partir da raiz ‚â† rodar python 
                app/main.py

                . muda o caminho base de import

            Solu√ß√£o que funciona de verdade (a mais correta):

                Rodar com -m a partir da raiz do projeto.

                Ex:

                    python -m app.main

                Assim:

                    Python entende app como pacote
                    
                    import relativo funciona
                    
                    import absoluto fica est√°vel

        Import absoluto (o padr√£o mais robusto)

            Em projetos, prefira:

                from app.core.config import SETTINGS
                from app.services.auth import login

            E execute assim:

                python -m app.main

            Isso resolve 90% dos problemas de import ‚Äúfora da pasta‚Äù.

        __init__.py (pra que serve na pr√°tica):

            __init__.py marca uma pasta como pacote ‚Äúcl√°ssico‚Äù e tamb√©m pode:

                (a) Expor API do pacote

                    app/services/__init__.py:

                        from .auth import login
                        from .users import get_user

                    A√≠ voc√™ pode:

                        from app.services import login

                (b) Rodar c√≥digo no import (use com cuidado)

                    Tudo que estiver no __init__.py roda quando o pacote √© 
                    importado.

        ‚Äúimport ACIMA‚Äù (import para pasta acima):

            Aqui tem 3 formas:

                Forma certa (recomendada): estrutura + -m

                    Use import absoluto a partir do pacote raiz e execute com -m.

                Forma de ambiente: PYTHONPATH

                    Voc√™ pode definir a raiz no PYTHONPATH:

                        PYTHONPATH=. python app/main.py

                    Funciona, mas √© mais ‚Äúambiente dependente‚Äù.

                Forma gambiarra: mexer em sys.path

                    Dentro do arquivo:

                        import sys
                        from pathlib import Path
                        sys.path.append(str(Path(__file__).resolve().parents[1]))

                    Funciona, mas evite em projeto s√©rio. √â f√°cil virar bagun√ßa.

        Import circular (o que √© e como resolver):

            Circular: A importa B e B importa A (direto ou indireto).

            Exemplo:

                a.py importa b.py

                b.py importa a.py

            Isso explode porque, no meio do import, um m√≥dulo ainda est√° 
            ‚Äúmeio carregado‚Äù.

        Solu√ß√µes que funcionam:

            (1) Quebrar depend√™ncia movendo tipos/constantes para um m√≥dulo 
            terceiro

                constants.py, interfaces.py, schemas.py

            (2) Import tardio (lazy import)

                def func():
                    from app.services.auth import login
                    return login()

            (3) Inverter depend√™ncia (inje√ß√£o)

                Ao inv√©s de auth importar db, passe db como par√¢metro.

            (4) Evitar c√≥digo executando no import

                Se a.py roda l√≥gica no topo, piora circular.

        main, entrypoint e ‚Äúonde eu rodo?‚Äù:

            Regra de ouro:

                Sempre rode da raiz do projeto
                Sempre rode como m√≥dulo quando for pacote

            Exemplo:

                python -m app.main

            E no app/main.py:

                def main():
                    ...

                if __name__ == "__main__":
                    main()

        Padr√£o de estrutura de projeto que ‚Äún√£o d√° dor de cabe√ßa‚Äù

            Estrutura recomendada (simples e forte):

            meuprojeto/
            app/
                __init__.py
                main.py
                core/
                    __init__.py
                    config.py
                services/
                    __init__.py
                    auth.py
            tests/
            pyproject.toml  (opcional, mas √≥timo)

        Import absoluto sempre:

            from app.core.config import SETTINGS

        Rodar sempre:

            python -m app.main

        ‚ÄúOutras coisas‚Äù importantes (bem pr√°ticas):

            (a) M√≥dulo vs pacote com mesmo nome

                Se voc√™ tiver random.py no seu projeto, pode ‚Äúquebrar‚Äù import 
                random (vai importar o seu arquivo).

                Evite nomes que colidem com libs padr√£o.

            (b) Caching de imports

                Import s√≥ carrega uma vez por execu√ß√£o (fica em sys.modules). 
                Isso explica comportamentos ‚Äúestranhos‚Äù em reload/testes.

            (c) __all__

                Controla o que aparece em from modulo import * (mesmo que voc√™ 
                evite, √© bom saber).

        Checklist r√°pido quando ‚Äúdeu erro de import‚Äù:

            1. Voc√™ est√° rodando da raiz do projeto?
            2. Est√° rodando como m√≥dulo? (python -m ...)
            3. Seus imports s√£o absolutos a partir do pacote raiz?
            4. Tem colis√£o de nome? (tipo random.py, re.py, json.py)
            5. Tem import circular? (A ‚Üî B)

    =====================================================================

    Garbage:

        - O ‚Äúlixeiro inteligente‚Äù da mem√≥ria

        O PROBLEMA QUE O GC RESOLVE

            Em qualquer programa:

                . voc√™ cria objetos

                . usa esses objetos

                . em algum momento, eles n√£o s√£o mais necess√°rios

            Pergunta central:

                Como saber quando algo pode ser removido da mem√≥ria com
                seguran√ßa?

                Existem duas abordagens:

                    . manual (C, C++)
                    . autom√°tica (Python, Java, JS)

                Python usa autom√°tica.

        O QUE √â GARBAGE (LIXO)?

            - Garbage √© qualquer objeto que n√£o pode mais ser acessado pelo 
            programa.

            Exemplo simples:

                x = [1, 2, 3]
                x = None

            A lista [1, 2, 3]:

                ainda existe na mem√≥ria por um instante

                mas ningu√©m mais aponta para ela

                virou lixo

            ‚ÄúN√£o acess√°vel‚Äù √© a palavra-chave.

        MODELO MENTAL CORRETO (IMPORTANT√çSSIMO):

            - GC n√£o apaga vari√°veis, ele apaga objetos.

            Vari√°veis s√£o apenas refer√™ncias.

                vari√°vel ‚îÄ‚îÄ‚ñ∫ objeto

            Se nenhuma vari√°vel aponta para o objeto ‚Üí candidato a coleta.

        COMO O PYTHON FAZ GC (DUAS CAMADAS):

            - Python usa DOIS mecanismos:

                1) Contagem de refer√™ncias (principal)

                    Cada objeto tem um contador:

                        quantas refer√™ncias apontam para ele?

                    Quando o contador chega a 0:

                        . o objeto √© destru√≠do imediatamente

                        Exemplo:

                            a = []
                            b = a      # refcount = 2
                            a = None   # refcount = 1
                            b = None   # refcount = 0 ‚Üí destru√≠do

                        Isso explica por que Python ‚Äúlibera mem√≥ria r√°pido‚Äù.

                2) Garbage Collector c√≠clico (o verdadeiro GC)

                    A contagem de refer√™ncias falha em ciclos:

                        a = []
                        a.append(a)

                    Aqui:

                        . a referencia a si mesmo

                        . refcount nunca chega a 0
                    
                    Entra o GC c√≠clico.

        O PROBLEMA DOS CICLOS:

            Exemplo cl√°ssico:

                class A:
                    def __init__(self):
                        self.b = None

                class B:
                    def __init__(self):
                        self.a = None

                a = A()
                b = B()
                a.b = b
                b.a = a

            Mesmo apagando a e b:

                eles ainda se referenciam

                refcount ‚â† 0

            GC c√≠clico detecta grupos inacess√≠veis, mesmo com refer√™ncias 
            internas.
        
        COMO O GC C√çCLICO FUNCIONA (SIMPLIFICADO):

            1. Ele procura objetos container (listas, dicts, classes)
            2. Marca quem aponta para fora
            3. O que sobra isolado √© lixo
            4. Coleta

            N√£o roda o tempo todo (seria caro).

        GERA√á√ïES DO GC (MUITO IMPORTANTE):

            Python divide objetos em gera√ß√µes:

                Gera√ß√£o 0: objetos novos

                Gera√ß√£o 1: sobreviveram um pouco

                Gera√ß√£o 2: sobreviventes ‚Äúantigos‚Äù

            Hip√≥tese:

                ‚ÄúObjetos que sobrevivem muito tendem a continuar vivos‚Äù.

            Isso reduz custo de varredura.

        O M√ìDULO gc:

            ex:

                import gc

            Fun√ß√µes √∫teis:

                gc.collect() ‚Üí for√ßa coleta

                gc.disable() / gc.enable()

                gc.get_count() ‚Üí estat√≠sticas

                gc.get_objects() ‚Üí objetos rastreados

            √ötil para debug, profiling e sistemas cr√≠ticos.

        __del__ (DESTRUTOR) ‚Äî USE COM CUIDADO:

            EX:

                class X:
                    def __del__(self):
                        print("Objeto destru√≠do")

            Problemas:

                n√£o h√° garantia de quando ser√° chamado

                pode atrasar coleta

                pode quebrar ciclos

            Evite l√≥gica importante em __del__.

        GC √ó DESEMPENHO:

            GC n√£o √© gratuito:

                pausas pequenas

                custo cresce com muitos objetos

            Por isso:

                Python tenta coletar o m√≠nimo poss√≠vel

                usa heur√≠sticas

        COMO USAR O GC A SEU FAVOR (PARTE MAIS IMPORTANTE):

            1) Preferir escopos curtos

                def func():
                    temp = [x for x in range(100000)]

            Saiu da fun√ß√£o ‚Üí refer√™ncias caem ‚Üí mem√≥ria liberada.

            2) Quebrar ciclos manualmente

                a.b = None
                b.a = None

            Em sistemas grandes, isso importa.

            3) Usar with (context managers)

                with open("file.txt") as f:
                    ...

            Libera√ß√£o determin√≠stica, n√£o depende do GC.

            4) Usar estruturas simples

                menos objetos

                menos containers

                menos ciclos

            5) Reutilizar objetos quando poss√≠vel

                pools

                buffers

                caches

        O QUE O GC N√ÉO FAZ:

            . N√£o compacta mem√≥ria como JVM
            . N√£o garante libera√ß√£o imediata de mem√≥ria ao SO
            . N√£o substitui bom design
            . N√£o resolve vazamento l√≥gico (refer√™ncia viva sem querer)

        VAZAMENTO DE MEM√ìRIA EM PYTHON (SIM, EXISTE):

            Exemplo cl√°ssico:

                cache = []

                def f(x):
                    cache.append(x)

            O GC n√£o pode ajudar, porque ainda h√° refer√™ncia.

        COMPARA√á√ÉO COM OUTRAS LINGUAGENS:

            | Linguagem | Modelo                 |
            | --------- | ---------------------- |
            | C         | manual (`malloc/free`) |
            | C++       | RAII                   |
            | Python    | refcount + GC          |
            | Java      | GC puro                |
            | Rust      | ownership (sem GC)     |

            Python √© um meio-termo.

        FRASES-CHAVE PARA MEMORIZAR:

            . GC apaga objetos
            . Refer√™ncia mant√©m vivo
            . Ciclos precisam GC
            . with √© melhor que __del__
            . GC n√£o corrige design ruim

    =====================================================================

    shuffle:

        - Shuffle √© uma permuta√ß√£o aleat√≥ria dos elementos de uma cole√ß√£o.

        Ou seja:

            . todos os elementos continuam l√°
            . s√≥ a ordem muda
            . cada permuta√ß√£o v√°lida deve ter a mesma probabilidade

        A parte ‚Äúmesma probabilidade‚Äù √© o que separa:

            shuffle correto

            shuffle errado (muito comum!)

        SHUFFLE N√ÉO √â SORT + RANDOM:

            Errado:

                sorted(lista, key=lambda _: random.random())

            Por qu√™?

                distribui√ß√£o enviesada

                n√£o garante equiprobabilidade

                ineficiente

            Parece funcionar, mas estatisticamente est√° errado.

        SHUFFLE E MATEM√ÅTICA (INTUI√á√ÉO):

            Se uma lista tem n elementos:

                existem n! permuta√ß√µes poss√≠veis

                um shuffle correto d√° 1/n! de chance para cada uma

            Exemplo:

                3 elementos ‚Üí 3! = 6 ordens poss√≠veis

        SHUFFLE IN PLACE √ó N√ÉO IN PLACE:

            . In place

                modifica a lista original

                O(n)

                usa swaps

            . N√£o in place

                cria nova lista

                mais mem√≥ria

                √†s vezes √∫til

            Python prioriza in place para efici√™ncia.

        O ALGORITMO CORRETO: FISHER‚ÄìYATES (KNUTH SHUFFLE):

            Esse √© o shuffle certo. Todo o resto √© suspeito.

            . Ideia

                percorra a lista

                para cada posi√ß√£o i

                troque com uma posi√ß√£o aleat√≥ria j ‚â• i

            . Modelo mental

                posi√ß√£o atual ‚Üê‚Üí posi√ß√£o aleat√≥ria ainda n√£o fixada

            . Pseudoc√≥digo

                para i de n-1 at√© 1:
                    j ‚Üê n√∫mero aleat√≥rio entre 0 e i
                    swap(lista[i], lista[j])

            Cada passo ‚Äúfixa‚Äù um elemento no final.

        ERROS CL√ÅSSICOS DE SHUFFLE:

            . Escolher j sempre de 0 a n-1
            . Trocar sempre com qualquer posi√ß√£o
            . Usar choice repetidamente
            . Criar vi√©s sem perceber
            . Confundir rota√ß√£o com shuffle

            A faixa do √≠ndice aleat√≥rio importa muito.

        SHUFFLE √ó ROTA√á√ÉO √ó SHIFT:

            | T√©cnica | O que faz             |
            | ------- | --------------------- |
            | Shuffle | mistura aleat√≥ria     |
            | Rota√ß√£o | deslocamento circular |
            | Shift   | empurra elementos     |

            N√£o confundir: shuffle √© caos controlado.

        COMO PENSAR (MENTALIDADE)

            Antes de embaralhar, pergunte:

                Preciso de uniformidade real?
                
                Pode ser determin√≠stico?
                
                Pode modificar a lista?
                
                Seguran√ßa importa?
                
                Preciso reproduzir o resultado?

        FRASES-CHAVE PARA MEMORIZAR

            . Shuffle √© permuta√ß√£o
            . Fisher‚ÄìYates √© o padr√£o
            . In place √© eficiente
            . Random ‚â† seguro
            . Vi√©s mata shuffle

    =====================================================================

    bucket:

        - Bucket √© a t√©cnica de dividir dados em ‚Äúbaldes‚Äù (grupos) com base em 
        algum crit√©rio, geralmente um intervalo de valores.

        Em vez de tratar tudo junto:

            . voc√™ classifica
            . depois processa cada grupo separadamente

        √â dividir para organizar, n√£o dividir para recurs√£o (como divis√£o e 
        conquista).

        MODELO MENTAL (O MAIS IMPORTANTE):

            Imagine:

                . voc√™ tem n√∫meros de 0 a 100

                . cria 10 baldes:

                    0‚Äì9

                    10‚Äì19

                    20‚Äì29

                    ...

            cada n√∫mero vai para um √∫nico balde

            Depois:

                . trabalha balde por balde

            O segredo est√° no crit√©rio de distribui√ß√£o.

        BUCKET ‚â† HASH (CONFUS√ÉO COMUM):

            | Bucket                     | Hash                         |
            | -------------------------- | ---------------------------- |
            | Intervalos ordenados       | Distribui√ß√£o pseudoaleat√≥ria |
            | Mant√©m no√ß√£o de ordem      | N√£o mant√©m                   |
            | √ìtimo para dados num√©ricos | √ìtimo para busca             |
            | Base do Bucket Sort        | Base de dicion√°rios          |

            Bucket √© classifica√ß√£o por faixa, hash √© mapeamento arbitr√°rio.

        BUCKET SORT (O CASO MAIS FAMOSO):

            Ideia geral:

                1. Cria v√°rios buckets vazios

                2. Distribui os elementos

                3. Ordena cada bucket

                4. Concatena tudo

                Se os dados forem bem distribu√≠dos:

                    . desempenho pode chegar a O(n)

        EXEMPLO CONCEITUAL (SEM C√ìDIGO):

            Entrada:

                [42, 32, 23, 52, 25, 47]

            Buckets (por dezenas):

                20s ‚Üí [23, 25]
                30s ‚Üí [32]
                40s ‚Üí [42, 47]
                50s ‚Üí [52]

            Resultado final:

                [23, 25, 32, 42, 47, 52]

        ONDE BUCKET √â USADO NA PR√ÅTICA:

            bucket sort

            radix sort (usa buckets em cada d√≠gito)

            histogramas

            distribui√ß√£o de frequ√™ncia

            balanceamento de carga

            sharding
            
            filas por prioridade

            contagem por faixa

            classifica√ß√£o r√°pida

        COMO ESCOLHER BUCKETS (DECIS√ÉO CR√çTICA)

            Perguntas-chave:

                Qual o intervalo dos dados?

                Os dados s√£o uniformes?

                Quantos buckets usar?

                Cada bucket pode ser processado r√°pido?

            Buckets mal escolhidos = desempenho ruim.

        BUCKET FIXO √ó BUCKET DIN√ÇMICO:

            - Bucket fixo

                n√∫mero de buckets definido antes

                simples
                
                comum em provas e algoritmos cl√°ssicos

            - Bucket din√¢mico

                cria buckets conforme necess√°rio

                mais flex√≠vel

                comum em sistemas reais

        BUCKET COM LISTAS (IMPLEMENTA√á√ÉO CL√ÅSSICA):

            Buckets normalmente s√£o:

                listas

                filas

                contadores

            Cada bucket √© um mini-container.

        BUCKET E MEM√ìRIA:

            Trade-off cl√°ssico:

                mais buckets ‚Üí mais mem√≥ria

                menos buckets ‚Üí mais trabalho interno

            Bucket √© troca de espa√ßo por tempo.

        ERROS COMUNS

            bucket demais (overhead)

            bucket de menos (vira sort normal)

            distribui√ß√£o enviesada

            n√£o tratar valores fora do intervalo

            confundir bucket com hash

        BUCKET √ó DIVIS√ÉO E CONQUISTA:

            | Bucket           | Divis√£o e Conquista  |
            | ---------------- | -------------------- |
            | Divide por faixa | Divide por tamanho   |
            | Iterativo        | Geralmente recursivo |
            | Agrupa dados     | Resolve subproblemas |
            | Usa listas       | Usa chamadas         |

            S√£o t√©cnicas diferentes, mas podem coexistir.

        COMO PENSAR (MENTALIDADE)

            Antes de usar bucket, pergunte:
            
                Consigo classificar os dados por intervalo?
            
                Preciso manter ordem relativa?
            
                O dom√≠nio √© conhecido?
            
                A distribui√ß√£o √© razo√°vel?
            
            Se sim ‚Üí bucket √© forte candidato.

        FRASES-CHAVE PARA MEMORIZAR

            . Bucket organiza por faixa
            . N√£o √© hash
            . N√£o √© recurs√£o
            . Espa√ßo troca por tempo
            . Distribui√ß√£o manda

    =====================================================================

    buffer:

        - O intermedi√°rio silencioso entre velocidade e organiza√ß√£o

        O PROBLEMA QUE O BUFFER RESOLVE:

            Existe um problema fundamental em computa√ß√£o:

                - Componentes do sistema operam em velocidades diferentes.
            
            Exemplos:

                . CPU ‚Üí extremamente r√°pida
                . RAM ‚Üí r√°pida
                . Disco ‚Üí lento
                . Rede ‚Üí vari√°vel
                . Usu√°rio ‚Üí lent√≠ssimo

            Buffer existe para desacoplar essas velocidades.

        DEFINI√á√ÉO FORMAL:

            Buffer √© uma regi√£o de mem√≥ria tempor√°ria usada para armazenar 
            dados enquanto eles s√£o transferidos entre dois lugares.

            Palavras-chave:

                . tempor√°ria
                . intermedi√°ria
                . organizada
                . controlada

            Buffer n√£o √© algoritmo, √© estrat√©gia de fluxo.

        MODELO MENTAL CORRETO:

            Imagine duas pessoas:

                uma fala muito r√°pido

                outra escreve devagar

            Solu√ß√£o:

                quem fala dita em blocos

                o outro anota quando consegue

            O bloco anotado √© o buffer.

        Se h√° fluxo de dados ‚Üí h√° buffer.

        BUFFER ‚â† CACHE (CONFUS√ÉO CL√ÅSSICA):

            | Buffer     | Cache       |
            | ---------- | ----------- |
            | Tempor√°rio | Persistente |
            | Ordenado   | Otimizado   |
            | Fluxo      | Acesso      |
            | IO-centric | CPU-centric |

            Buffer organiza transfer√™ncia, cache otimiza reuso.

        BUFFER DE ENTRADA E SA√çDA:

            - Buffer de entrada (input buffer)

                . dados chegam

                . ficam armazenados

                . s√£o consumidos depois

                Exemplo:

                    teclado

                    leitura de arquivo

            - Buffer de sa√≠da (output buffer)

                . dados s√£o produzidos

                . acumulados

                . enviados em bloco

                Exemplo:

                    escrita em arquivo

                    print()

        BUFFER NO PYTHON (SEM PERCEBER):

            EX:

                print("Ol√°")

            Voc√™ pensa:

                ‚Äúimprimi na tela‚Äù

            Na pr√°tica:

                o texto vai para um buffer

                o buffer √© descarregado depois

            Por isso existe:

                print("Ol√°", flush=True)

        BUFFERING EM ARQUIVOS:

            EX:

                f = open("arquivo.txt", "w")
                f.write("dados")

            . write n√£o garante escrita imediata
            . vai para buffer
            . s√≥ vai ao disco quando:
            . buffer enche
            . flush()
            . close()
            
            Isso √© enorme ganho de desempenho.

        flush() ‚Äî ESVAZIAR O BUFFER:

            EX:

                f.flush()

            . for√ßa envio dos dados
            . reduz risco de perda
            . aumenta custo

            Trade-off cl√°ssico:

                mais flush ‚Üí mais seguran√ßa

                menos flush ‚Üí mais desempenho

        BUFFER E CONTEXT MANAGER (with):

            EX:

                with open("a.txt", "w") as f:
                    f.write("oi")

            Ao sair do bloco:

                . buffer √© descarregado

                . arquivo √© fechado

            Isso √© libera√ß√£o determin√≠stica, melhor que depender do GC.

        BUFFER E SISTEMAS OPERACIONAIS:

            O SO:

                gerencia buffers

                usa page cache

                agrupa chamadas de IO

            Muitas vezes:

                seu flush() ainda fica no cache do SO

                s√≥ depois vai para o disco f√≠sico

        BUFFER EM REDE (INTUI√á√ÉO):

            dados chegam em pacotes

            buffer acumula

            aplica√ß√£o consome no ritmo dela

            Problemas comuns:

                buffer pequeno ‚Üí perda

                buffer grande ‚Üí lat√™ncia

            Lat√™ncia √ó throughput.

        BUFFER CIRCULAR (IMPORTANTE):

            Usado quando:

                fluxo cont√≠nuo

                tamanho fixo

                reaproveitamento de mem√≥ria

            Muito eficiente.

        BUFFER OVERFLOW (CONCEITO CL√ÅSSICO):

            Em linguagens sem controle:

                . escrever al√©m do buffer
                . sobrescrever mem√≥ria
                . falha de seguran√ßa

            Python:

                . protegido
                . mas o conceito ainda importa (principalmente em C, SO, redes).

        COMO USAR BUFFER AO SEU FAVOR:

            1) Trabalhar em blocos

                - leia 1MB por vez
                - escreva em blocos

            2) Evitar flush excessivo

                - flush s√≥ quando necess√°rio

            3) Preferir with

                - garante descarregamento

            4) Usar buffers pr√≥prios (listas, deque)

                - para pipelines
                - para filas
                - para streaming

        ERROS COMUNS:

            achar que write() grava imediatamente

            esquecer flush() em logs cr√≠ticos

            flush a cada linha sem necessidade

            confundir buffer com cache

            n√£o entender lat√™ncia causada por buffer

        COMO PENSAR (MENTALIDADE):

            Sempre pergunte:

                Existe diferen√ßa de velocidade?

                O dado pode esperar?

                Posso agrupar opera√ß√µes?

                Preciso de consist√™ncia imediata?

                Qual o custo do flush?

        FRASES-CHAVE PARA MEMORIZAR:

            . Buffer desacopla velocidades
            . Buffer √© tempor√°rio
            . Flush for√ßa envio
            . with resolve 90%
            . Buffer melhora desempenho

        T√âCNICAS DE PROGRAMA√á√ÉO COM BUFFER:

            - Buffer n√£o √© s√≥ mem√≥ria ‚Üí √© estrat√©gia de fluxo

            Buffer = acumular ‚Üí processar ‚Üí liberar

            Sempre que voc√™:

                n√£o quer processar dado por dado

                quer reduzir custo de opera√ß√£o

                quer desacoplar produ√ß√£o e consumo

            voc√™ usa buffer.

        BUFFER DE ACUMULA√á√ÉO (BATCHING):

            . Ideia

                Acumular dados e processar em lote.

            . Exemplo mental

                em vez de salvar no banco a cada item

                salva a cada 100 itens

            Reduz custo brutalmente.

            . Modelo

                buffer ‚Üê dados
                se buffer cheio:
                    processa
                    limpa buffer

        BUFFER DE PRODU√á√ÉO √ó CONSUMO:

            . Problema cl√°ssico

                produtor gera dados r√°pido

                consumidor processa devagar

            . Solu√ß√£o

                Buffer intermedi√°rio.

            Isso √© a base do Producer‚ÄìConsumer Pattern.

        BUFFER CIRCULAR (T√âCNICA FUNDAMENTAL):

            . Quando usar

                tamanho fixo

                fluxo cont√≠nuo

                reaproveitar mem√≥ria

            . Modelo mental

                    [ _ _ _ _ _ ]
                      ‚Üë       ‚Üì
                     head   tail

                . escreve no tail
                . l√™ no head
                . √≠ndices giram (m√≥dulo)

        BUFFER COMO JANELA DESLIZANTE:

            - Voc√™ j√° viu isso sem chamar de buffer

            . Exemplo

                analisar √∫ltimos 5 valores

                manter hist√≥rico curto

            Buffer = janela + pol√≠tica de descarte.

        BUFFER PARA REDUZIR COMPLEXIDADE:

            Sem buffer:

                processa tudo a cada passo

                custo alto

            Com buffer:

                mant√©m estado parcial

                atualiza incrementalmente

        BUFFER E IO EFICIENTE (NA PR√ÅTICA):

            . T√©cnica

                ler grandes blocos

                escrever grandes blocos

            Em vez de:

                1 caractere ‚Üí write

            Fa√ßa:

                1024 caracteres ‚Üí write

            Ganho enorme.

        BUFFER COMO FILTRO:

            Voc√™ pode ter:

                entrada ‚Üí buffer ‚Üí transforma√ß√£o ‚Üí buffer ‚Üí sa√≠da

            Cada est√°gio trabalha no seu ritmo.

        BUFFER COMO ISOLADOR DE ERRO:

            Ideia

            Se algo falhar:

                buffer ainda segura os dados

                n√£o perde tudo

        BUFFER E CONTROLE DE FLUXO:

            Buffer pequeno

                baixa lat√™ncia

                risco de overflow

            Buffer grande

                alta lat√™ncia

                mais mem√≥ria

        Escolha do tamanho √© decis√£o de engenharia.

    =====================================================================

    Arquivos e context managers:

        Um arquivo √© um recurso externo controlado pelo sistema operacional, 
        usado para:

            . armazenar dados
            . ler dados
            . persistir informa√ß√£o

        Arquivo n√£o √© vari√°vel, n√£o √© mem√≥ria RAM.

        Ele vive fora do seu programa.

        Caracter√≠sticas importantes:

            - Precisa ser aberto
            - Precisa ser fechado
            - Opera com buffer
            - Pode falhar (permiss√£o, inexist√™ncia, etc.)

        A FUN√á√ÉO open():

            O que open() faz?

                open(nome_arquivo, modo)

            . pede ao SO acesso ao arquivo
            . retorna um objeto arquivo
            . N√ÉO garante escrita imediata (usa buffer)

            Exemplo b√°sico:

                f = open("dados.txt", "w")
                f.write("Ol√°")
                f.close()

            Se esquecer close(), o arquivo pode:

                ficar aberto

                perder dados

                causar erro no Windows

        MODOS DE ABERTURA DE ARQUIVO:

            | Modo   | Significado          |
            | ------ | -------------------- |
            | `"r"`  | leitura              |
            | `"w"`  | escrita (apaga tudo) |
            | `"a"`  | escrita (append)     |
            | `"r+"` | leitura + escrita    |
            | `"w+"` | escrita + leitura    |
            | `"a+"` | leitura + append     |
            | `"b"`  | bin√°rio              |
            | `"t"`  | texto (padr√£o)       |

        FUN√á√ïES / M√âTODOS DO OBJETO ARQUIVO:

            . read()

                    f.read()

                - l√™ TODO o arquivo
                - retorna str ou bytes

            . read(n)

                    f.read(10)

                - l√™ n caracteres

            . readline()

                    f.readline()

                - l√™ uma linha

            . readlines()

                    f.readlines()

                - retorna lista de linhas

            . write()

                    f.write("texto")

                - escreve no buffer
                - N√ÉO pula linha automaticamente

            . writelines()

                    f.writelines(["a\n", "b\n"])

                - escreve v√°rias linhas
                - N√ÉO adiciona \n

            . seek()

                    f.seek(0)

                - move o cursor no arquivo

            . tell()

                    f.tell()

                - retorna posi√ß√£o atual do cursor

            . flush()

                    f.flush()

                - for√ßa escrita do buffer no SO

            . close()

                    f.close()

                - fecha o arquivo
                - libera recurso
                - faz flush automaticamente

        O COMANDO with (CONTEXT MANAGER):

            with garante:

                abertura correta

                fechamento autom√°tico

                mesmo se der erro

            Exemplo correto (padr√£o profissional)

                with open("dados.txt", "w") as f:
                    f.write("Ol√° mundo")

            O Python faz:

                1. open
                2. executa o bloco
                3. flush
                4. close

            N√£o depende do Garbage Collector

        EXEMPLOS COM TODOS OS MODOS:

            . Leitura (r)

                with open("dados.txt", "r") as f:
                    print(f.read())

            . Escrita (w)

                with open("dados.txt", "w") as f:
                    f.write("novo conte√∫do")

            . Append (a)

                with open("dados.txt", "a") as f:
                    f.write("\nlinha nova")

            . Leitura + escrita (r+)

                with open("dados.txt", "r+") as f:
                    conteudo = f.read()
                    f.write("\nextra")

            . Bin√°rio (rb / wb)

                with open("imagem.png", "rb") as f:
                    dados = f.read()

        BUFFER + FLUSH:

            write() n√£o grava imediatamente no disco.

            Exemplo:

                with open("log.txt", "w") as f:
                    f.write("linha 1")
                    f.flush()
                    f.write("linha 2")

            Use flush() quando:

                logs

                progresso

                sistemas cr√≠ticos

        ARQUIVO COMO ITERADOR:

            Arquivo √© iter√°vel:

                with open("dados.txt") as f:
                    for linha in f:
                        print(linha.strip())

            . Econ√¥mico
            . Ideal para arquivos grandes
            . Usa buffer automaticamente

        M√öLTIPLAS LINHAS:

            . Escrita

                linhas = ["a\n", "b\n", "c\n"]

                with open("dados.txt", "w") as f:
                    f.writelines(linhas)

            . Leitura

                with open("dados.txt") as f:
                    linhas = f.readlines()
            
        ARQUIVOS BIN√ÅRIOS:

            with open("arquivo.bin", "wb") as f:
                f.write(b"\x00\x01\x02")

        CONTEXT MANAGER N√ÉO √â S√ì ARQUIVO:

            Qualquer classe com:

                __enter__

                __exit__

            Exemplo simples

                class MeuContexto:
                    def __enter__(self):
                        print("Entrou")
                        return self

                    def __exit__(self, exc_type, exc_val, exc_tb):
                        print("Saiu")

                with MeuContexto():
                    print("Dentro")

        POR QUE with √â T√ÉO IMPORTANTE?

            Sem with:

                vazamento de recurso

                arquivo travado

                dados perdidos

                bugs dif√≠ceis

            Com with:

                fechamento garantido

                c√≥digo limpo

                padr√£o profissional

            Em produ√ß√£o, with n√£o √© opcional.

        ERROS COMUNS:

            . Esquecer close()
            . Ler arquivo gigante com read()
            . Escrever sem \n
            . N√£o usar strip()
            . Abrir arquivo v√°rias vezes sem necessidade

        DICAS:

            Use with sempre

            Prefira iterar linha a linha

            Use flush() s√≥ quando necess√°rio

            Evite l√≥gica pesada dentro do with

            Use modo correto (r, w, a)

        FRASES-CHAVE PARA MEMORIZAR:

            . Arquivo √© recurso externo
            . open n√£o grava imediatamente
            . Buffer melhora desempenho
            . with garante fechamento
            . Arquivo √© iter√°vel

            - Se voc√™ abriu um arquivo sem with, voc√™ provavelmente fez errado.

    =====================================================================

    Geradores python:

        - Um gerador √© um objeto que produz valores sob demanda, um de cada
        vez, em vez de armazenar tudo na mem√≥ria.

        Ideia central:

            lista ‚Üí armazena tudo

            gerador ‚Üí produz quando pedem

            EX:

                Gerador = fluxo de valores

        COMO UM GERADOR FUNCIONA (MODELO MENTAL):

            Um gerador:

                . executa at√© encontrar yield
                . pausa
                . devolve um valor
                . continua exatamente de onde parou na pr√≥xima chamada

            Ele mant√©m:

                . estado interno
                . vari√°veis locais
                . posi√ß√£o de execu√ß√£o

        FINALIDADE DOS GERADORES:

            Geradores existem para:

                economizar mem√≥ria

                trabalhar com dados grandes

                processar streams

                criar pipelines

                produzir dados infinitos

                desacoplar produ√ß√£o e consumo

            Gerador √© fluxo, n√£o cole√ß√£o.

        SINTAXE DE UM GERADOR:

            Fun√ß√£o geradora:

                def contador():
                    yield 1
                    yield 2
                    yield 3
            

            Chamando:

                g = contador()
                print(next(g))  # 1
                print(next(g))  # 2
                print(next(g))  # 3
        
        O PAPEL DO yield:

            O que yield faz?

                produz um valor

                pausa a fun√ß√£o

                salva o estado

                retorna depois

            yield n√£o encerra a fun√ß√£o.

        GERADOR SEM yield (N√ÉO EXISTE):

            Importante:

                Sem yield, n√£o √© gerador.

                    def f():
                        return 1

            Isso √©:

                fun√ß√£o normal

                n√£o mant√©m estado

                executa tudo de uma vez

            yield √© o que transforma fun√ß√£o em gerador.

        GERADOR POR EXPRESS√ÉO (GENERATOR EXPRESSION):

            Exemplo cl√°ssico:

                x = (i for i in range(5))

            Isso √© um gerador, n√£o uma tupla.

            Por que √© eficiente?

                n√£o cria lista

                gera valores sob demanda

                consumo incremental

            Compara√ß√£o:

                lista = [i for i in range(10_000_000)]
                gerador = (i for i in range(10_000_000))

            O gerador usa ordens de magnitude menos mem√≥ria.
        
        GERADOR VS FUN√á√ÉO:

            | Fun√ß√£o            | Gerador           |
            | ----------------- | ----------------- |
            | Executa tudo      | Executa em etapas |
            | Usa `return`      | Usa `yield`       |
            | N√£o mant√©m estado | Mant√©m estado     |
            | Retorna 1 valor   | Retorna v√°rios    |

        RETURN VS YIELD:

            . return

                encerra a fun√ß√£o

                devolve valor final

                EX:

                    def soma():
                        return 10

            . yield

                pausa

                devolve valor parcial

                pode continuar

                EX:

                    def soma():
                        yield 3
                        yield 7

            - return encerra
            - yield continua

        GERADORES COMO ITERADORES:

            Todo gerador:

                . √© um iterador
                . implementa __iter__ e __next__

            ex:

                g = (i for i in range(3))

                for x in g:
                    print(x)

            Depois de consumido, acabou.

        APLICA√á√ïES REAIS DE GERADORES:

            . Leitura de arquivos

                def ler_linhas(nome):
                    with open(nome) as f:
                        for linha in f:
                            yield linha.strip()

            . Processamento em pipeline

                def quadrados(nums):
                    for n in nums:
                        yield n * n

            . Dados infinitos

                def naturais():
                    n = 0
                    while True:
                        yield n
                        n += 1

        FUN√á√ïES QUE USAM GERADORES:

            EX:

                def pares(nums):
                    for n in nums:
                        if n % 2 == 0:
                            yield n


            Uso:

                dados = range(10)
                for x in pares(dados):
                    print(x)

            Fun√ß√µes + geradores = pipelines.

        DECORADORES COM GERADORES:

            Decorador que ‚Äúobserva‚Äù valores:

                def log_generator(func):
                    def wrapper(*args):
                        for valor in func(*args):
                            print("Gerado:", valor)
                            yield valor
                    return wrapper

            Decoradores n√£o quebram geradores se usarem yield.

        GERADOR DE GERADORES:

            def sublistas():
                yield (i for i in range(3))
                yield (i for i in range(3, 6))

            Uso:

                for g in sublistas():
                    for x in g:
                        print(x)

            Muito usado em pipelines complexos.

        yield from:

            yield from delega a produ√ß√£o de valores de um gerador para outro 
            iter√°vel/gerador.
    
            Ou seja:

                em vez de fazer for + yield

                voc√™ entrega o controle para outro gerador

            PROBLEMA QUE yield from RESOLVE:

                Forma manual (verbosa):

                    def g1():
                        for x in range(3):
                            yield x

                    def g2():
                        for v in g1():
                            yield v

                Forma pythonica (yield from):

                    def g2():
                        yield from g1()

                Mesmo comportamento, menos c√≥digo, mais claro.

            MODELO MENTAL DO yield from:

                yield from iterable
                ‚Üì
                ‚ÄúProduza tudo que esse iter√°vel produzir‚Äù

                Ele:

                    itera

                    repassa valores

                    repassa exce√ß√µes

                    repassa StopIteration

            yield from COM ITER√ÅVEIS SIMPLES:

                    def letras():
                        yield from "abc"

                    list(letras())  # ['a', 'b', 'c']

                Funciona com:

                    listas

                    tuplas

                    strings

                    ranges

                    outros geradores

            yield from COM V√ÅRIAS FONTES:

                    def tudo():
                        yield from range(3)
                        yield from range(3, 6)
                
                Resultado:

                    0 1 2 3 4 5

                Muito usado para compor fluxos.

            yield from √ó GERADOR DE GERADORES:

                . Sem yield from

                        def geradores():
                            yield (i for i in range(3))
                            yield (i for i in range(3, 6))

                    Resultado: geradores dentro de geradores.

                . Com yield from

                        def flatten():
                            yield from range(3)
                            yield from range(3, 6)

                    Resultado: fluxo plano.

            yield from E RETURN (DETALHE AVAN√áADO):

                Um return dentro de um gerador:

                        def g():
                            yield 1
                            return 99

                    . o 99 vira o valor do StopIteration

                Com yield from:

                        def g2():
                            x = yield from g()
                            print(x)

                    Usado em corrotinas avan√ßadas (async).

        propriedades de geradores de express√£o:

            Essas fun√ß√µes consomem iter√°veis:

                sum(g)
                min(g)
                max(g)
                any(g)
                all(g)
            
            Exemplo:

                g = (i for i in range(5))
                print(sum(g))  # 10

            Elas percorrem o gerador uma vez.

            Tamb√©m funcionam:

                list(g)
                tuple(g)
                set(g)

            Mas:

                consomem o gerador

                perdem o benef√≠cio de mem√≥ria

            FUN√á√ïES QUE N√ÉO FUNCIONAM COM GERADORES:

                . len()

                    . gerador n√£o sabe quantos elementos ainda vir√£o
                    . fluxo pode ser infinito

                . Acesso por √≠ndice:

                    . n√£o guarda elementos
                    . n√£o permite acesso aleat√≥rio

                . Reuso:

                    - Consumiu ‚Üí acabou.

            FUN√á√ïES QUE FUNCIONAM PARCIALMENTE:

                . sorted()

                    . Funciona
                    . Converte tudo para lista internamente

                    Cuidado com dados grandes.

                . enumerate()

                        for i, v in enumerate(g):
                            ...

                    . Seguro
                    . Streaming
                    . Muito usado

                . zip():

                    . Funciona
                    . Consome em paralelo

                    Excelente com geradores.

        ERROS COMUNS:

            . Achar que gerador √© lista
            . Tentar usar len()
            . Consumir duas vezes sem recriar
            . Esquecer que ele acaba
            . Misturar return e yield sem entender

        DICAS PR√ÅTICAS

            Use gerador para dados grandes

            Use listas para acesso aleat√≥rio

            Prefira generator expressions quando poss√≠vel

            Combine geradores em pipeline

            Use yield from quando poss√≠vel

        FRASES-CHAVE PARA MEMORIZAR

            . Gerador √© fluxo
            . yield pausa
            . Gerador economiza mem√≥ria
            . Consumiu, acabou
            . Pipeline √© poder

            - Se voc√™ n√£o precisa de todos os dados ao mesmo tempo, use gerador.

    =====================================================================

    Programa√ß√£o funcional (map, any, sum, all, lambda k entre outras fun√ß√µes):

        - Programa√ß√£o funcional √© um paradigma que trata computa√ß√£o como 
        avalia√ß√£o de fun√ß√µes.

        Ou seja:

            foco em transformar dados

            menos foco em estado mut√°vel

            menos efeitos colaterais

        Ideia central:

            entrada ‚Üí fun√ß√£o ‚Üí sa√≠da

        √â UM PARADIGMA?

            Sim.

            Principais paradigmas:

                imperativo (C, Python cl√°ssico)

                orientado a objetos

                funcional

                l√≥gico

            Python √© multiparadigma:

                permite estilo funcional

                mas n√£o √© puramente funcional

        PARA QUE SERVE / POR QUE FOI CRIADA?

            Programa√ß√£o funcional surgiu para:

                evitar bugs de estado

                facilitar paralelismo

                melhorar previsibilidade

                trabalhar com matem√°tica e l√≥gica

            Muito forte em:

                matem√°tica

                processamento de dados

                pipelines

                big data

                streams

                IA / ML

        PROGRAMA√á√ÉO FUNCIONAL EM PYTHON:

            Python n√£o for√ßa o paradigma, mas oferece:

                fun√ß√µes como objetos

                fun√ß√µes de alta ordem

                lambdas

                iter√°veis

                geradores

                fun√ß√µes built-in funcionais

            Em Python, programa√ß√£o funcional √© estilo, n√£o dogma.

        FUN√á√ïES E M√âTODOS FUNCIONAIS DO PYTHON:

            - Agora o cora√ß√£o do tema.

            map():

                - Aplica uma fun√ß√£o a cada elemento de um iter√°vel.

                    map(funcao, iteravel)

                Exemplo:

                    nums = [1, 2, 3]
                    resultado = map(lambda x: x * 2, nums)
                    print(list(resultado))  # [2, 4, 6]

                Retorna um iterador, n√£o lista.

            filter():

                - Filtra elementos com base em uma condi√ß√£o.

                    filter(funcao, iteravel)

                EX:

                    pares = filter(lambda x: x % 2 == 0, nums)
                    print(list(pares))  # [2]

            sum():

                    sum(iteravel)

                EX:

                    sum([1, 2, 3])  # 6

                Muito usado com geradores.

            any() e all():

                any:

                    - Retorna True se algum elemento for verdadeiro.

                        any([0, False, 3])  # True

                all:

                    - Retorna True se todos forem verdadeiros.

                        all([1, 2, 3])  # True

                Ambos usam curto-circuito.

            reduce() (fun√ß√£o especial):

                Lib:

                    from functools import reduce

                - Reduz um iter√°vel a um √∫nico valor.

                EX:

                    reduce(lambda a, b: a + b, [1, 2, 3, 4])  # 10

            lambda como programa√ß√£o funcional:

                lambda √© Fun√ß√£o an√¥nima, de uma express√£o.
                
                N√£o tem:

                    m√∫ltiplas linhas

                    return expl√≠cito

                    statements complexos

            sorted() com key:

                sorted(pessoas, key=lambda p: p["idade"])

            zip() e enumerate():

                . zip

                    zip([1,2], [3,4]) ‚Üí (1,3), (2,4)

                . enumerate

                    for i, v in enumerate(lista):
                        ...

                Muito usados em estilo funcional.

        LIST COMPREHENSION (FUNCIONAL H√çBRIDO):

                [x * 2 for x in nums if x % 2 == 0]

            Muitas vezes √© mais leg√≠vel que map/filter

        T√âCNICAS FUNCIONAIS (COM EXEMPLOS):

            PIPELINE DE DADOS:

                resultado = sum(
                    x * x
                    for x in nums
                    if x % 2 == 0
                )

            FUN√á√ïES COMO ARGUMENTO:

                def aplicar(f, dados):
                    return map(f, dados)

            IMUTABILIDADE (CONCEITO):

                Em funcional:

                    . evite modificar dados

                    . produza novos

                EX:

                    nova_lista = [x+1 for x in lista]

        QUANDO USAR PROGRAMA√á√ÉO FUNCIONAL:

            Use quando:

                transformar dados

                pipelines

                processamento em lote

                dados imut√°veis

                leitura clara

            Evite quando:

                l√≥gica complexa

                muitos estados intermedi√°rios

                efeitos colaterais

                lambdas gigantes

        OUTRAS COISAS IMPORTANTES (QUE MUITOS ESQUECEM):

            operator module (add, mul, etc.)

            lib itertools

            curto-circuito (any, all)

            lazy evaluation

            geradores + funcional = ouro

        ERROS COMUNS:

            . Usar lambda gigante
            . Abusar de reduce
            . C√≥digo ileg√≠vel s√≥ ‚Äúpra ser funcional‚Äù
            . Converter tudo em lista sem necessidade
            . Ignorar curto-circuito

        DICAS:

            prefira legibilidade

            use generator expressions

            combine sum, any, all

            use map/filter quando ficarem claros

            se ficou confuso ‚Üí volte para for

        FRASES-CHAVE PARA MEMORIZAR:

            . Funcional transforma dados
            . Fun√ß√µes s√£o valores
            . Menos estado, menos bugs
            . Lazy √© poderoso
            . Clareza > estilo

            - Use programa√ß√£o funcional para clareza e fluxo, n√£o para mostrar 
            que sabe programa√ß√£o funcional.

    =====================================================================

    Fallback:

        - Fallback √© uma estrat√©gia de ter um plano alternativo quando a op√ß√£o 
        principal falha.

        Em outras palavras:

            tenta A ‚Üí se falhar ‚Üí usa B

        Fallback n√£o √© erro, √© previs√£o de erro.

        POR QUE FALLBACK EXISTE?

            Porque na vida real:

                arquivos n√£o existem

                rede cai

                dados v√™m errados

                usu√°rio erra

                API responde mal

                recurso acaba

            - C√≥digo sem fallback quebra.

            - C√≥digo com fallback se adapta.

        MODELO MENTAL (GUARDE ISSO)

            Fallback = degrada√ß√£o controlada

            O sistema:

                n√£o entrega o melhor cen√°rio

                mas continua funcionando

        Fallback SIMPLES (VALORES PADR√ÉO)

            . Exemplo cl√°ssico:

                valor = entrada if entrada is not None else 0

            Ou usando or:

                valor = entrada or 0

            Muito comum para:

                config

                input

                defaults

        Fallback COM EXCE√á√ïES (TRY / EXCEPT):

            . Arquivo com fallback

                Se n√£o existir ‚Üí usa padr√£o.

                    try:
                        with open("config.txt") as f:
                            config = f.read()
                    except FileNotFoundError:
                        config = "config padr√£o"

            . Fallback EM FUN√á√ïES

                Fun√ß√£o sempre retorna algo v√°lido.

                    def dividir(a, b):
                        try:
                            return a / b
                        except ZeroDivisionError:
                            return 0

            . Fallback COM FUN√á√ïES ALTERNATIVAS

                Muito usado em:

                    algoritmos

                    APIs

                    servi√ßos externos

                ex:

                    def metodo_principal():
                        raise Exception("falhou")

                    def metodo_backup():
                        return "resultado alternativo"

                    try:
                        resultado = metodo_principal()
                    except:
                        resultado = metodo_backup()

            . Fallback EM DICION√ÅRIOS:

                . get:

                    idade = dados.get("idade", 0)

                . setdefault:

                    dados.setdefault("contador", 0)

                Evita KeyError.

            . Fallback EM CONFIGURA√á√ïES (PADR√ÉO PROFISSIONAL):

                Ordem comum:

                    1. vari√°vel de ambiente
                    2. arquivo
                    3. valor padr√£o

                EX:

                    import os

                    DEBUG = os.getenv("DEBUG", "False")

            . Fallback EM LISTAS E ITER√ÅVEIS

                Evita IndexError.

                    primeiro = lista[0] if lista else None

            . Fallback EM EXPRESS√ïES FUNCIONAIS

                next(..., default) √© fallback elegante.

                    resultado = next((x for x in lista if x > 10), 0)

            . Fallback EM PIPELINES:

                - Pipeline nunca para completamente.

                    def processar(dado):
                        try:
                            return etapa1(dado)
                        except:
                            return etapa_backup(dado)

        Fallback ‚â† SILENCIAR ERRO (CONFUS√ÉO COMUM):

            Ruim:

                try:
                    ...
                except:
                    pass

            Bom:

                try:
                    ...
                except Exception:
                    usar_alternativa()

            Fallback precisa:

                . inten√ß√£o clara

                . comportamento definido

        ERROS COMUNS:

            . Fallback que esconde bug
            . except: gen√©rico demais
            . Fallback errado (resultado inv√°lido)
            . Fallback caro demais
            . Fallback sem log

        DICAS:

            fallback deve ser simples

            fallback deve ser seguro
            
            fallback deve ser documentado
            
            fallback deve ser raro, n√£o rotina
            
            fallback n√£o substitui corre√ß√£o

        FRASES-CHAVE PARA MEMORIZAR:

            . Fallback √© plano B
            . Fallback n√£o √© gambiarra
            . Erro previsto √© robustez
            . Sistema n√£o pode morrer
            . Falhar com controle

            Nunca confie que tudo vai funcionar ‚Äî
            mas sempre saiba o que fazer quando n√£o funcionar.

    =====================================================================

    Exce√ß√µes, raise, assertations e testes de software:

        - Exce√ß√£o √© um evento anormal que interrompe o fluxo normal do programa.

        Ela indica que:

            . algo inesperado aconteceu

            . o programa n√£o consegue continuar normalmente

        Exemplos:

            dividir por zero

            acessar √≠ndice inv√°lido

            arquivo inexistente

            tipo incorreto

        PARA QUE SERVEM EXCE√á√ïES:

            Exce√ß√µes existem para:

                . separar erro de l√≥gica normal

                . evitar verifica√ß√µes infinitas com if

                . propagar falhas corretamente

                . permitir recupera√ß√£o (fallback)

                Exce√ß√£o n√£o √© bug, √© sinal de erro.

        try / except:

            Forma b√°sica

                try:
                    x = int("abc")
                except:
                    x = 0

            Fluxo:

                1. tenta executar o try
                2. se falhar ‚Üí entra no except
                3. se n√£o falhar ‚Üí ignora o except

            PS: evite usar apenas except, por que √© considerado m√°pr√°tica e tamb√©m
            ofusca bugs e erros

        try / except / else:

            - Quando voc√™ quer executar algo somente se N√ÉO houve erro.

            ex:

                try:
                    x = int("10")
                except ValueError:
                    print("Erro")
                else:
                    print("Convers√£o OK:", x)

            ps: else n√£o executa se houver exce√ß√£o.

        try / except / finally:

            O papel do finally: Sempre executa, com erro ou sem erro.

                try:
                    f = open("a.txt")
                except FileNotFoundError:
                    print("Arquivo n√£o existe")
                finally:
                    print("Encerrando opera√ß√£o")

            Muito usado para:

                fechar recursos

                liberar conex√µes

                limpar estado

        try / except / else / finally:

            Forma completa:

                try:
                    x = int("5")
                except ValueError:
                    print("Erro")
                else:
                    print("Tudo certo")
                finally:
                    print("Fim")

            Ordem:

                1. try
                2. except (se erro)
                3. else (se n√£o erro) 
                4. finally (sempre)

        try / except / finally (sem else):

            - √ötil quando voc√™ sempre precisa limpar algo.

                try:
                    x = int("x")
                except ValueError:
                    x = 0
                finally:
                    print("Valor:", x)

        except ESPEC√çFICO (MUITO IMPORTANTE):

            Ruim:

                except:
                    ...

            Bom:

                except ValueError:
                    ...

            Exce√ß√µes espec√≠ficas:

                documentam o erro

                evitam esconder bugs

                tornam c√≥digo seguro

        except COM M√öLTIPLAS EXCE√á√ïES:

            - Muito comum em valida√ß√£o de dados.

                except (ValueError, TypeError):
                    print("Erro de convers√£o")

        ALIAS COM except:

            EX:

                except ValueError as e:
                    print("Erro:", e)

            e cont√©m:

                mensagem

                tipo

                contexto

        raise:

            - raise lan√ßa uma exce√ß√£o manualmente.

            EX:

                raise ValueError("valor inv√°lido")

            Voc√™ for√ßa o erro.

            POR QUE USAR raise

                validar regras de neg√≥cio

                garantir contratos

                parar execu√ß√£o inv√°lida

                comunicar erro para quem chama

            raise = controle consciente de falha.

            raise EM FUN√á√ïES:

                EX:

                    def sacar(valor):
                        if valor <= 0:
                            raise ValueError("valor inv√°lido")
                        return valor

                Melhor que retornar None silenciosamente.

            RELAN√áAR EXCE√á√ÉO:

                - Mant√©m traceback original.

                    try:
                        ...
                    except Exception:
                        raise

            raise ... from ...:

                - Exception chaining (encadeamento de exce√ß√µes)

                Sintaxe:

                    raise NovaExcecao(...) from excecao_original

                Significa:

                    ‚ÄúEstou levantando um novo erro, mas ele foi causado por 
                    outro.‚Äù

                POR QUE ISSO EXISTE?

                    Porque √†s vezes voc√™:

                    captura uma exce√ß√£o t√©cnica

                    quer traduzir para uma exce√ß√£o de dom√≠nio

                    sem perder a causa original

                EXEMPLO SEM from (PERDE CONTEXTO):

                    EX:

                        try:
                            int("abc")
                        except ValueError:
                            raise RuntimeError("Erro ao converter")

                    Problema:

                        voc√™ perde a causa original

                        traceback fica pobre

                EXEMPLO COM raise ... from ...:

                    try:
                        int("abc")
                    except ValueError as e:
                        raise RuntimeError("Erro ao converter") from e

                Agora o Python mostra:

                    erro original (ValueError)

                    erro atual (RuntimeError)

                    rela√ß√£o entre eles

                    - Debug muito melhor.

                COMO O TRACEBACK FICA (CONCEITO):

                    ValueError: invalid literal for int()

                    The above exception was the direct cause of the following exception:

                    RuntimeError: Erro ao converter

                Isso √© ouro para manuten√ß√£o.

                raise ... from None (SUPRIMIR CONTEXTO):

                    - √Äs vezes voc√™ n√£o quer mostrar a causa original.

                        try:
                            int("abc")
                        except ValueError:
                            raise RuntimeError("Erro gen√©rico") from None

                    Resultado:

                        . erro original some

                        . s√≥ aparece o erro novo

                        PS: Use com cuidado (UX / seguran√ßa).

                USO PROFISSIONAL DE raise from:

                    - Tradu√ß√£o de erro t√©cnico ‚Üí erro de dom√≠nio

                        class ErroDeNegocio(Exception):
                                pass

                            try:
                                open("config.txt")
                            except FileNotFoundError as e:
                                raise ErroDeNegocio("Configura√ß√£o ausente") from e

                    Camada de neg√≥cio n√£o depende de erro t√©cnico.

                EXCE√á√ïES ANINHADAS:

                    - Um try/except dentro de outro try/except.

                    Usado quando:

                        etapas t√™m falhas diferentes

                        cada falha tem tratamento pr√≥prio

                    EXEMPLO SIMPLES DE ANINHAMENTO:

                        EX:

                            try:
                                x = int(input())
                                try:
                                    y = 10 / x
                                except ZeroDivisionError:
                                    y = 0
                            except ValueError:
                                y = 0

                        - Cada erro tratado no n√≠vel correto.

                    POR QUE N√ÉO FAZER UM TRY GIGANTE?

                        Ruim:

                            try:
                                x = int(input())
                                y = 10 / x
                            except:
                                y = 0

                        Problema:

                            trata erros diferentes da mesma forma

                            esconde bugs

                            l√≥gica confusa

                    EXCE√á√ïES ANINHADAS + raise from:

                        EX:

                            try:
                                try:
                                    int("abc")
                                except ValueError as e:
                                    raise TypeError("Tipo inv√°lido") from e
                            except TypeError as final:
                                print(final)

                        Muito usado em:

                            parsing

                            valida√ß√£o

                            pipelines

                    PADR√ÉO PROFISSIONAL (CAMADAS):

                        Entrada do usu√°rio
                        ‚Üì
                        Valida√ß√£o (ValueError)
                        ‚Üì
                        Regra de neg√≥cio (Exce√ß√£o pr√≥pria)
                        ‚Üì
                        Camada externa trata tudo

                    C√≥digo:

                        try:
                            processar()
                        except ErroDeNegocio:
                            ...
                        except Exception:
                            ...

                QUANDO USAR raise from:

                    Use quando:

                        traduz exce√ß√µes

                        muda camada

                        quer preservar causa

                    N√£o use quando:

                        erro j√° √© sem√¢ntico

                        causa n√£o importa

                        poluir traceback

        assert:

            - assert verifica uma condi√ß√£o e lan√ßa erro se for falsa.

            EX:

                assert x > 0

            Se falso ‚Üí AssertionError

            PARA QUE SERVE assert:

                . verificar suposi√ß√µes internas
                . validar invariantes
                . testar contratos
                . debug

                assert n√£o √© valida√ß√£o de usu√°rio.

            assert COM MENSAGEM:

                EX:

                    assert x > 0, "x deve ser positivo"

            IMPORTANTE SOBRE assert:

                - Em Python:

                    python -O script.py

                assert pode ser removido.

                Nunca use assert para l√≥gica cr√≠tica.

        HIERARQUIA DE EXCE√á√ïES EM PYTHON:

            TODAS AS EXCE√á√ïES V√äM DE UM √öNICO LUGAR:

                - Toda exce√ß√£o em Python herda, direta ou indiretamente, 
                de BaseException.

                Hierarquia raiz:

                    BaseException

                Nada escapa disso.

            CAMADAS DA HIERARQUIA (VIS√ÉO GERAL):

                EX:

                    BaseException
                    ‚îú‚îÄ‚îÄ SystemExit
                    ‚îú‚îÄ‚îÄ KeyboardInterrupt
                    ‚îú‚îÄ‚îÄ GeneratorExit
                    ‚îî‚îÄ‚îÄ Exception
                        ‚îú‚îÄ‚îÄ ArithmeticError
                        ‚îÇ    ‚îú‚îÄ‚îÄ ZeroDivisionError
                        ‚îÇ    ‚îî‚îÄ‚îÄ OverflowError
                        ‚îú‚îÄ‚îÄ LookupError
                        ‚îÇ    ‚îú‚îÄ‚îÄ IndexError
                        ‚îÇ    ‚îî‚îÄ‚îÄ KeyError
                        ‚îú‚îÄ‚îÄ ValueError
                        ‚îú‚îÄ‚îÄ TypeError
                        ‚îú‚îÄ‚îÄ FileNotFoundError
                        ‚îú‚îÄ‚îÄ IOError / OSError
                        ‚îú‚îÄ‚îÄ ImportError
                        ‚îú‚îÄ‚îÄ AttributeError
                        ‚îî‚îÄ‚îÄ RuntimeError
 
                Regra importante:

                    . voc√™ quase sempre captura coisas que herdam de Exception

                    . n√£o capture BaseException

            BaseException (NUNCA CAPTURE):

                EX:

                    except BaseException:
                        ...

                ERRADO na maioria dos casos.

                Por qu√™?

                    Porque BaseException inclui:

                        KeyboardInterrupt (Ctrl+C)

                        SystemExit (sys.exit)

                    Capturar isso impede o programa de:

                        encerrar

                        ser interrompido corretamente

            Exception (A BASE DO QUE VOC√ä USA):

                Padr√£o correto:

                    except Exception:
                        ...

                Isso captura:

                    erros de l√≥gica

                    erros de IO

                    erros de tipo

                    erros de valor

                90% dos casos usam Exception ou subclasses.

            PRINCIPAIS EXCE√á√ïES BUILT-IN (AS MAIS USADAS):

                . ValueError:

                    - Valor correto, mas conte√∫do inv√°lido.

                        int("abc")

                . TypeError

                    - Tipo errado.

                        "1" + 2

                . IndexError

                    - √çndice inv√°lido.

                        lista = [1, 2, 3, 4, 5]
                        lista[10]

                . KeyError

                    - Chave inexistente.

                        d = {"nome": "Jo√£o", "idade": 22}
                        d["x"]

                . ZeroDivisionError

                    - Erro de divis√£o por zero

                        10 / 0

                . FileNotFoundError

                    open("inexistente.txt")

                . AttributeError

                    None.upper()

                . ImportError

                    import modulo_inexistente

            AGRUPANDO EXCE√á√ïES POR CATEGORIA:

                Categoria aritm√©tica:

                    ArithmeticError
                    ‚îú‚îÄ‚îÄ ZeroDivisionError
                    ‚îú‚îÄ‚îÄ OverflowError

                Categoria de acesso

                    LookupError
                     ‚îú‚îÄ‚îÄ IndexError
                     ‚îú‚îÄ‚îÄ KeyError

                Isso permite capturar fam√≠lias de erros:

                    except LookupError:
                        ...

            ORDEM DOS except (MUITO IMPORTANTE):

                Errado:

                    except Exception:
                        ...
                    except ValueError:
                        ...

                Correto:

                    except ValueError:
                        ...
                    except Exception:
                        ...

                Sempre do mais espec√≠fico para o mais gen√©rico.

        COMO CRIAR SUAS PR√ìPRIAS EXCE√á√ïES (CUSTOM):

            - Exce√ß√µes customizadas devem herdar de Exception, nunca de 
            BaseException.

            . Exce√ß√£o simples

                    class SaldoInsuficienteError(Exception):
                        pass

                Uso:

                    raise SaldoInsuficienteError("Saldo insuficiente")

            EXCE√á√ÉO CUSTOMIZADA COM DADOS:

                EX:

                    class IdadeInvalidaError(Exception):
                        def __init__(self, idade):
                            self.idade = idade
                            super().__init__(f"Idade inv√°lida: {idade}")

                Uso:

                    if idade < 0:
                        raise IdadeInvalidaError(idade)

                Muito usado em regras de neg√≥cio.

            POR QUE CRIAR EXCE√á√ïES PR√ìPRIAS?

                Porque:

                    tornam o erro sem√¢ntico

                    documentam regras do dom√≠nio

                    facilitam captura espec√≠fica

                    evitam ValueError gen√©rico

                Exemplo ruim:

                    raise ValueError("saldo inv√°lido")

                Exemplo bom:

                    raise SaldoInsuficienteError()

            CAPTURANDO EXCE√á√ïES CUSTOMIZADAS:

                - C√≥digo mais claro, mais robusto.

                    try:
                        sacar(1000)
                    except SaldoInsuficienteError as e:
                        print("Erro de neg√≥cio:", e)

            EXCE√á√ïES VS RETORNO DE ERRO:

                Ruim:

                    def dividir(a, b):
                        if b == 0:
                            return None

                Bom:

                    def dividir(a, b):
                        if b == 0:
                            raise ZeroDivisionError()

                Exce√ß√µes quebram o fluxo ‚Äî retornos n√£o.

            CRIANDO UMA ‚ÄúCAMADA‚Äù DE EXCE√á√ïES (PADR√ÉO PROFISSIONAL):

                class AppError(Exception):
                    pass

                class AuthError(AppError):
                    pass

                class PermissaoError(AuthError):
                    pass

            Agora voc√™ pode capturar:

                except AppError:
                    ...

            Isso √© arquitetura de exce√ß√µes.


        TESTES DE SOFTWARE:

            - Testes s√£o c√≥digos que verificam automaticamente se outros 
            c√≥digos funcionam corretamente.
    
            Eles servem para:

                evitar regress√µes

                garantir comportamento

                documentar o sistema

                dar confian√ßa para refatorar

            POR QUE USAR TESTES:

                Sem testes:

                    medo de mudar c√≥digo

                    bugs reaparecem

                    manuten√ß√£o cara

                Com testes:

                    seguran√ßa

                    previsibilidade

                    qualidade

                Teste √© investimento, n√£o custo.

            TESTES MANUAIS COM LOOPS:

                - Simples, mas poderoso.

                    for entrada, esperado in [(2,4), (3,9)]:
                        assert quadrado(entrada) == esperado

            DOCTEST:

                Testes dentro da documenta√ß√£o:

                    def soma(a, b):
                        """
                        >>> soma(2, 3)
                        5
                        """
                        return a + b

                Executa:

                    python -m doctest arquivo.py

                Bom para exemplos simples.

            UNITTEST:

                Framework padr√£o do Python:

                    import unittest

                    class TesteSoma(unittest.TestCase):
                        def test_soma(self):
                            self.assertEqual(2 + 3, 5)

                Estruturado, verboso, cl√°ssico.

            PYTEST:

                - Framework moderno (o mais usado hoje)

                    def test_soma():
                        assert 2 + 3 == 5

                Vantagens:

                    simples

                    poderoso

                    fixtures

                    √≥timo para projetos reais

            MOCK:

                Simular:

                    arquivos

                    rede

                    banco

                    APIs
                
                EX:

                    from unittest.mock import Mock

                    m = Mock()
                    m()  # simula chamada

                Testa c√≥digo sem depend√™ncias externas.

        OUTROS TIPOS DE TESTE:

            teste unit√°rio

            teste de integra√ß√£o

            teste de sistema

            teste de regress√£o

            teste de carga

            teste de aceita√ß√£o

            PS: Nem todo teste √© unit√°rio.

        OUTRAS COISAS IMPORTANTES:

            exce√ß√µes s√£o parte da API

            teste documenta comportamento

            erro esperado tamb√©m √© teste

            cobertura n√£o √© qualidade

            teste ruim √© pior que nenhum

        ERROS COMUNS:

            . except: gen√©rico
            . Engolir erro com pass
            . Usar assert para valida√ß√£o de usu√°rio
            . N√£o testar erro esperado
            . Testes fr√°geis demais
            . Criar exce√ß√£o herdando de BaseException
            . Usar s√≥ ValueError pra tudo
            . except: gen√©rico
            . Exce√ß√£o sem mensagem
            . Exce√ß√£o para fluxo normal


        DICAS:

            capture exce√ß√µes espec√≠ficas

            use raise para contrato

            use assert para suposi√ß√µes internas

            teste casos de erro

            escreva testes pequenos

            Exce√ß√£o = evento raro

            Use nomes claros

            Capture espec√≠fico

            Lance (raise) cedo

            Documente exce√ß√µes como parte da API


        FRASES-CHAVE PARA MEMORIZAR

            . Exce√ß√£o n√£o √© bug
            . raise √© contrato
            . assert √© suposi√ß√£o
            . Teste d√° confian√ßa
            . C√≥digo sem teste √© aposta
            . Toda exce√ß√£o herda de BaseException
            . Capture Exception, n√£o BaseException
            . Espec√≠fico antes do gen√©rico
            . Exce√ß√£o √© sem√¢ntica
            . Dom√≠nio pede exce√ß√£o pr√≥pria


            Se um erro √© poss√≠vel, ele deve ser tratado ou testado ‚Äî nunca 
            ignorado.

    =====================================================================

    Assincronismo, fun√ß√µes e geradores ass√≠ncronos, threads e processos:

        PRIMEIRO: O PROBLEMA QUE TUDO ISSO RESOLVE

            Situa√ß√£o cl√°ssica (c√≥digo s√≠ncrono)

                dados = baixar_dados()
                processar(dados)
                salvar(dados)

            Se baixar_dados() demora:

                . tudo trava
                . CPU fica ociosa
                . usu√°rio espera

            Isso √© bloqueio.

        O QUE √â ASSINCRONISMO (IDEIA CENTRAL):

            - Assincronismo √© permitir que o programa continue enquanto espera 
            algo lento.
    
            Exemplos de coisas lentas:

                rede

                disco

                banco

                API

                sleep

            Assincronismo ‚â† paralelismo

            Assincronismo = n√£o bloquear

        MODELO MENTAL SIMPLES:

            EX:

                S√≠ncrono: faz ‚Üí espera ‚Üí faz ‚Üí espera
                Ass√≠ncrono: faz ‚Üí agenda ‚Üí faz outra coisa ‚Üí volta depois

        PYTHON TEM 3 CAMINHOS PRINCIPAIS:

            1. Assincronismo cooperativo (async/await)
            2. Threads (I/O concorrente)
            3. Processos (CPU paralelo)

            Cada um serve para um problema diferente.

        ASSINCRONISMO COM async / await:

            O QUE √â UMA FUN√á√ÉO ASS√çNCRONA:

                EX:

                    async def tarefa():
                        ...

                Isso cria uma corrotina, n√£o uma fun√ß√£o normal.

                Ela:

                    n√£o executa imediatamente

                    precisa ser aguardada

            O QUE √â await:

                - await diz: ‚Äúpause aqui e volte depois‚Äù

                - Outra forma de express√£o: "Pause aqui e devolve o controle
                pro event loop, para outras tarefas rodarem."

                Use await apenas:

                    . corrotinas (async def)
                    . awaitables (asyncio.sleep, gather, I/O async etc)

                EX:

                    async def exemplo():
                        await algo_lento()

                Outro exemplo:

                    import asyncio

                    async def tarefa():
                        print("A")
                        await asyncio.sleep(1)  # N√£o bloqueia o programa
                        print("B")

                Enquanto espera:

                    . o loop de eventos executa outras tarefas

                    . nada fica bloqueado

            EVENT LOOP (O CORA√á√ÉO DO ASSYNC):

                Python usa um loop de eventos:

                    agenda tarefas

                    alterna execu√ß√£o

                    controla espera

                EX:

                    import asyncio

                    asyncio.run(main())

            EXEMPLO SIMPLES ASS√çNCRONO:

                import asyncio

                async def tarefa():
                    print("in√≠cio")
                    await asyncio.sleep(1)
                    print("fim")

                asyncio.run(tarefa())

            - sleep n√£o bloqueia o programa.

            asyncio.run(coro):

                - Cria e gerencia o event loop, executa a corrotina principal e 
                fecha tudo no final.
    
                EX:

                    async def main():
                        await asyncio.sleep(0.1)

                    asyncio.run(main())

                Regra:

                    - normalmente voc√™ tem um asyncio.run() no seu programa 
                    (entrypoint).
            
            asyncio.gather(*aws):

                - Roda v√°rias tarefas ‚Äúao mesmo tempo‚Äù (cooperativo) e espera 
                todas terminarem.

                EX:

                    import asyncio

                    async def job(i):
                        await asyncio.sleep(0.2)
                        return i * 2

                    async def main():
                        resultados = await asyncio.gather(job(1), job(2), job(3))
                        print(resultados)  # [2, 4, 6]

                    asyncio.run(main())

                Observa√ß√µes importantes:

                    . retorna resultados na mesma ordem dos argumentos, n√£o na 
                    ordem de t√©rmino.

                    . se uma falha, por padr√£o pode cancelar/propagar (depende 
                    do caso; d√° pra controlar).    

            asyncio.wait(aws, ...):

                - Espera um conjunto de tarefas e devolve dois conjuntos: done e 
                pending.
    
                Use quando voc√™ quer:

                    esperar ‚Äúo primeiro terminar‚Äù

                    impor timeout

                    controlar tarefas pendentes

                Exemplo (esperar a primeira terminar):

                    import asyncio

                    async def job(i, t):
                        await asyncio.sleep(t)
                        return i

                    async def main():
                        tasks = {asyncio.create_task(job(1, 1.0)),
                                asyncio.create_task(job(2, 0.2))}

                        done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)

                        for d in done:
                            print("terminou:", await d)

                        for p in pending:
                            p.cancel()

                    asyncio.run(main())

                Diferen√ßa pr√°tica:

                    gather: ‚Äúquero tudo‚Äù

                    wait: ‚Äúquero controle (done/pending/timeout/first)‚Äù

            asyncio.create_task(coro):

                - Agenda uma corrotina para rodar em paralelo (cooperativo) 
                imediatamente.
        
                EX:

                    async def main():
                        t = asyncio.create_task(job(1))
                        print("faz outra coisa")
                        r = await t

            async for:

                - Loop para consumir gerador ass√≠ncrono (stream async).

                EX:

                    import asyncio

                    async def stream():
                        for i in range(3):
                            await asyncio.sleep(0.2)
                            yield i

                    async def main():
                        async for x in stream():
                            print(x)

                    asyncio.run(main())

                Use quando dados chegam ao longo do tempo:

                    websocket

                    filas async

                    eventos

            Outras coisas √∫teis do asyncio:

                . asyncio.sleep(t) ‚Üí ‚Äúespera‚Äù sem bloquear

                . asyncio.TimeoutError + asyncio.wait_for(coro, timeout) ‚Üí 
                timeout

                . asyncio.as_completed(tasks) ‚Üí consumir resultados conforme 
                terminam (stream de tasks)

                . asyncio.to_thread(func, *args) ‚Üí rodar fun√ß√£o bloqueante em 
                thread sem travar o loop


            QUANDO USAR async:

                Use quando:

                    I/O

                    muitas conex√µes

                    APIs

                    scraping

                    servidores

                N√£o use para:

                    CPU pesado

                    loops intensos

        GERADORES ASS√çNCRONOS:

            O QUE √â UM GERADOR ASS√çNCRONO:

                async def gerar():
                    for i in range(3):
                        await asyncio.sleep(1)
                        yield i

            Consumo:

                async for x in gerar():
                    print(x)

            Combina:

                yield

                await

        PARA QUE SERVE:

            streams ass√≠ncronos

            dados em tempo real
            
            WebSockets
            
            pipelines async

            - Muito usado em servidores.

        THREADS:

            - Thread = execu√ß√£o concorrente dentro do mesmo processo

            Cria uma thread para rodar uma fun√ß√£o.

            . compartilha mem√≥ria
            . leve
            . ideal para I/O

        EXEMPLO COM THREAD:

            from threading import Thread

            def tarefa():
                print("executando")

            t = Thread(target=tarefa)
            t.start()
            t.join()

        Outro exemplo:

            from threading import Thread

            def minha_funcao(n):
                print("rodando", n)

            t = Thread(target=minha_funcao, args=(10,))
            t.start()
            t.join()

        start() e join():

            start() ‚Üí inicia a thread

            join() ‚Üí espera a thread terminar

            Dica:

                sempre join() quando voc√™ precisa garantir que terminou.


        GIL (IMPORTANTE):

            Python tem GIL (Global Interpreter Lock):

                . apenas uma thread executa Python por vez

                . threads n√£o paralelizam CPU

            Mas:

                . funcionam bem para I/O

        Lock (mutex):

            - Garante que s√≥ uma thread por vez entre na regi√£o cr√≠tica.

            EX:

                from threading import Thread, Lock

                lock = Lock()
                contador = 0

                def inc():
                    global contador
                    for _ in range(10000):
                        with lock:
                            contador += 1

                threads = [Thread(target=inc) for _ in range(2)]
                for t in threads: t.start()
                for t in threads: t.join()
                print(contador)

            Use Lock para proteger:

                escrita em vari√°vel compartilhada

                estruturas mut√°veis (listas/dicts) em trechos cr√≠ticos

                contadores
            
        Outras coisas √∫teis em threading:

            RLock ‚Üí lock reentrante (mesma thread pode ‚Äúpegar de novo‚Äù)

            Semaphore ‚Üí limita N acessos simult√¢neos (tipo vagas de 
            estacionamento)

            Event ‚Üí sinaliza√ß√£o entre threads (liga/desliga)

            Condition ‚Üí coordena√ß√£o avan√ßada

            current_thread().name ‚Üí debug

        Regra pr√°tica:

            thread √© boa para I/O, n√£o para CPU pesado (GIL).

        QUANDO USAR THREADS:

            Use para:

                I/O bloqueante

                bibliotecas n√£o async

                tarefas independentes

            N√£o use para:

                CPU pesado

        PROCESSOS:

            - Processo = execu√ß√£o independente, com mem√≥ria pr√≥pria

            . sem GIL compartilhado
            . paralelismo real
            . mais pesado

        EXEMPLO COM PROCESSOS:

            from multiprocessing import Process

            def tarefa():
                print("processo")

            p = Process(target=tarefa)
            p.start()
            p.join()

        QUANDO USAR PROCESSOS:

            Use quando:

                CPU intenso

                c√°lculos pesados

                paralelismo real

            Evite quando:

                overhead importa

                troca de dados frequente

        multiprocessing ‚Äî paralelismo real (CPU):

            Process(target=func, args=...)

            - Executa a fun√ß√£o em outro processo (outra mem√≥ria), sem GIL 
            compartilhado.

            EX:

                from multiprocessing import Process

                def trabalho():
                    print("rodando em processo")

                p = Process(target=trabalho)
                p.start()
                p.join()

            Diferen√ßa chave:

                - processo n√£o compartilha mem√≥ria facilmente.

            Comunica√ß√£o entre processos (o b√°sico):

                Quando precisa trocar dados:

                    multiprocessing.Queue

                    Pipe

                    Manager (mais alto n√≠vel)

                Exemplo com Queue:

                    from multiprocessing import Process, Queue

                    def produtor(q):
                        q.put(42)

                    if __name__ == "__main__":
                        q = Queue()
                        p = Process(target=produtor, args=(q,))
                        p.start()
                        print(q.get())
                        p.join()

            Outras coisas √∫teis em multiprocessing:

                Pool ‚Üí mapa paralelo (v√°rios workers)

                cpu_count() ‚Üí quantos n√∫cleos

                Value/Array ‚Üí compartilhamento controlado

                Lock tamb√©m existe no multiprocessing (para recursos 
                compartilhados via IPC)

            Regra pr√°tica:

                use para CPU pesado (c√°lculo, compress√£o, parsing pesado).

            Como escolher r√°pido:

                . I/O com muita espera ‚Üí asyncio
                . I/O bloqueante / libs n√£o async ‚Üí threading (ou asyncio.to_thread)
                . CPU pesado ‚Üí multiprocessing

            Erros cl√°ssicos

                asyncio: usar time.sleep() dentro de async def (bloqueia tudo)

                threading: mexer em estado compartilhado sem Lock (race condition)

                multiprocessing: tentar usar vari√°veis globais como se fossem 
                compartilhadas (n√£o s√£o)


        COMPARA√á√ÉO FINAL (IMPORTANTE):

            | T√©cnica   | Serve para | Paralelo real | Mem√≥ria       |
            | --------- | ---------- | ------------- | ------------- |
            | `async`   | I/O        | ‚ùå            | baixa         |
            | Threads   | I/O        | ‚ùå            | compartilhada |
            | Processos | CPU        | ‚úÖ            | separada      |

        Por que bugs de concorr√™ncia s√£o ‚Äú1 em 1 milh√£o‚Äù:

            - Quando voc√™ usa threads/async/processos, a ordem das opera√ß√µes 
            muda conforme:

                agendamento do SO

                carga da m√°quina

                timing de rede/disco

                CPU dispon√≠vel

                GC, caches, etc.

            Isso cria interleavings (intercala√ß√µes) diferentes:

                Thread A: l√™ x ‚Üí calcula ‚Üí escreve x
                Thread B: l√™ x ‚Üí calcula ‚Üí escreve x

            Se a ordem for ‚Äúruim‚Äù, d√° bug. Se for ‚Äúboa‚Äù, passa.

            Por que √© dif√≠cil achar?

                N√£o determinismo: voc√™ n√£o consegue ‚Äúrepetir‚Äù o mesmo agendamento 
                facilmente.

                Observer effect: adicionar print/log muda o timing e o bug some.

                Janela m√≠nima: a falha depende de uma janela de microssegundos.

                - Nome disso: race condition + heisenbug.

            Problemas cl√°ssicos com Threads e Processos:

                Race condition (condi√ß√£o de corrida):

                    - Dois fluxos acessam/alteram o mesmo estado sem prote√ß√£o.

                    Exemplo (bugado):

                        import threading

                        contador = 0

                        def inc():
                            global contador
                            for _ in range(100_000):
                                contador += 1  # n√£o √© at√¥mico

                        threads = [threading.Thread(target=inc) for _ in range(2)]
                        for t in threads: t.start()
                        for t in threads: t.join()

                        print(contador)  # √†s vezes < 200000

                    ‚Äúcontador += 1‚Äù vira v√°rias etapas por baixo: 
                    ler ‚Üí somar ‚Üí escrever.
    
                Deadlock (travamento m√∫tuo):

                    - Dois locks, duas threads ‚Äî cada uma segura um lock e 
                    espera o outro.

                    EX:

                        T1: pega lock A, espera lock B
                        T2: pega lock B, espera lock A
                        => ningu√©m anda

                Livelock:

                    N√£o travam, mas ficam ‚Äúdan√ßando‚Äù e ningu√©m progride 
                    (ex.: ambos cedem sempre).

                Starvation (fome):

                    Uma thread nunca consegue recurso (prioridade, lock injusto, 
                    fila mal projetada).

                Processos: overhead + IPC + serializa√ß√£o:

                    Processos t√™m mem√≥ria separada: compartilhar estado exige:

                        filas, pipes, sockets

                        serializa√ß√£o (pickle)
                        
                        mais custo

        T√©cnicas de uso de thread: ‚Äútr√¢nsito / passar um por cima do outro‚Äù:

            Voc√™ descreveu perfeito: interse√ß√£o.

            1. ‚ÄúSem√°foro‚Äù (controle de acesso)

                . S√≥ um carro passa por vez numa via cr√≠tica.

                . Em c√≥digo: mutex/lock.

                Padr√£o:

                    lock = threading.Lock()

                    with lock:
                        # regi√£o cr√≠tica (apenas 1 thread entra)
                        ...

                Regras de ouro do ‚Äútr√¢nsito‚Äù

                    1. Regi√£o cr√≠tica pequena
                    2. Sempre mesma ordem de locks (evita deadlock)
                    3. Evite ‚Äúlock em tudo‚Äù (vira gargalo)

            2 ‚ÄúRotat√≥ria‚Äù (fila / ordem)

                - Em vez de todo mundo disputar, voc√™ cria uma fila: Queue.

                Padr√£o profissional: produtor-consumidor

                . threads n√£o compartilham ‚Äúestado mut√°vel‚Äù

                . elas trocam mensagens por fila

                EX:

                    from queue import Queue
                    from threading import Thread

                    q = Queue()

                    def produtor():
                        for i in range(10):
                            q.put(i)
                        q.put(None)  # sentinela

                    def consumidor():
                        while True:
                            item = q.get()
                            if item is None:
                                break
                            # processa item
                            q.task_done()

                    Thread(target=produtor).start()
                    Thread(target=consumidor).start()

                Isso reduz MUITO chance de race condition.

            3 ‚ÄúFaixa exclusiva‚Äù (separar responsabilidades)

                - Uma thread s√≥ produz
                - outra s√≥ consome
                - ningu√©m mexe nos dados do outro diretamente

        Erro cl√°ssico no Async: bloquear o event loop:

            O erro:

                Dentro de async def, voc√™ chama algo bloqueante:

                    time.sleep()

                    requests.get()

                    leitura pesada CPU

                    I/O bloqueante sem await

                Errado:

                    import asyncio, time

                    async def tarefa():
                        time.sleep(2)  # BLOQUEIA tudo
                        return 1

                    async def main():
                        r = await asyncio.gather(tarefa(), tarefa())
                        print(r)

                    asyncio.run(main())

                Resultado: n√£o ‚Äúroda junto‚Äù, trava o loop.

            Corre√ß√µes:

                Se for ‚Äúespera‚Äù: use asyncio.sleep

                    import asyncio

                    async def tarefa():
                        await asyncio.sleep(2)
                        return 1

                Se for fun√ß√£o bloqueante (ex.: lib n√£o async): jogue pra thread

                    import asyncio
                    import time

                    def bloqueante():
                        time.sleep(2)
                        return 1

                    async def main():
                        r = await asyncio.gather(
                            asyncio.to_thread(bloqueante),
                            asyncio.to_thread(bloqueante),
                        )
                        print(r)

                    asyncio.run(main())

                Isso √© um ‚Äúfallback‚Äù elegante: mant√©m async, mas delega bloqueio.

        Async generator + gather (padr√£o real):

            Aqui tem 2 padr√µes muito √∫teis:

                asyncio.gather para rodar N tarefas ao mesmo tempo

                    import asyncio

                    async def baixa(id):
                        await asyncio.sleep(1)
                        return f"dado-{id}"

                    async def main():
                        resultados = await asyncio.gather(*(baixa(i) for i in range(5)))
                        print(resultados)

                    asyncio.run(main())

                Gerador ass√≠ncrono para ‚Äústream‚Äù de resultados:

                    Use quando voc√™ quer produzir itens ao longo do tempo.

                        import asyncio

                        async def stream():
                            for i in range(5):
                                await asyncio.sleep(0.5)
                                yield i

                        async def main():
                            async for x in stream():
                                print("chegou:", x)

                        asyncio.run(main())

                Combinando: tasks + ‚Äústream‚Äù (gather incremental)

                    Quando voc√™ quer disparar tarefas e ir coletando conforme 
                    terminam, use as_completed (mais ‚Äústreaming‚Äù que gather):

                        import asyncio
                        import random

                        async def job(i):
                            await asyncio.sleep(random.random())
                            return i * i

                        async def main():
                            tasks = [asyncio.create_task(job(i)) for i in range(10)]
                            for coro in asyncio.as_completed(tasks):
                                print("resultado:", await coro)

                        asyncio.run(main())

                    Esse padr√£o √© MUITO real em:

                        scraping

                        chamadas HTTP

                        filas async

                        processamento concorrente de IO

        Como ca√ßar bugs ‚Äú1 em 1 milh√£o‚Äù (t√©cnicas pr√°ticas):

            Aumentar probabilidade (stress test)

                . rodar 1000x em loop
                . aumentar concorr√™ncia
                . diminuir sleeps aleat√≥rios

            Adicionar jitter controlado

                . sleep(random.uniform(0, 0.001)) para for√ßar interleavings

            Logs com contexto

                . timestamp
                . thread name
                . task id

            Tornar determin√≠stico quando poss√≠vel

                . seed fixo
                . entradas fixas

            Preferir design que evita compartilhamento

                . filas (Queue)
                . imutabilidade
                . ‚Äúmessage passing‚Äù

            Para async:

                . PYTHONASYNCIODEBUG=1
                . asyncio.run(..., debug=True) (quando dispon√≠vel)
                . timeouts e cancelamento consciente

            Quanto menos estado compartilhado, menos bugs raros.

            Se tiver que compartilhar, proteja (lock) ou serialize (fila).

        ERROS COMUNS:

            . usar async para CPU
            . misturar time.sleep com async
            . criar threads demais
            . ignorar GIL
            . achar que async √© mais r√°pido sempre

        DICAS:

            I/O ‚Üí async

            CPU ‚Üí processos

            c√≥digo legado ‚Üí threads

            n√£o misture sem motivo

            escolha ferramenta certa

        FRASES-CHAVE PARA MEMORIZAR:

            . Ass√≠ncrono n√£o bloqueia
            . Thread n√£o paraleliza CPU
            . Processo paraleliza
            . GIL existe
            . Ferramenta certa importa

            N√£o escolha async, threads ou processos por moda.

            Escolha pelo tipo de problema.

    =====================================================================

    Worse com Python:

        - O operador Walrus permite atribuir um valor a uma vari√°vel dentro de 
        uma express√£o e ao mesmo tempo usar esse valor.

        Antes (sem walrus):

            n = len(a)
            if n > 10:
                print(n)

        Com walrus:

            if (n := len(a)) > 10:
                print(n)

        Esse √© exatamente um caso cl√°ssico citado na doc do Python.

        Por que existe / quando √© √∫til:

            Ele evita:

                repetir uma chamada cara (len(...), regex, leitura, etc.)

                criar uma linha extra s√≥ pra guardar o resultado

            1) Regex (muito usado):

                EX:

                    import re

                    if (m := re.search(r"\d+", texto)):
                        print("Achou:", m.group())

                Exemplo semelhante aparece na refer√™ncia do Python.

            2) Loop lendo ‚Äúem blocos‚Äù (stream):

                EX:

                    while (chunk := f.read(1024)):
                        processar(chunk)

                Aqui voc√™ l√™ e testa ‚Äúse veio algo‚Äù numa linha.

            3) Compreens√£o (use com cuidado):

                EX:

                    pares = [y for x in nums if (y := x*2) % 4 == 0]

                Funciona, mas pode ficar feio/ileg√≠vel.

        Regras pr√°ticas (pra n√£o virar bagun√ßa):

            - Use quando a vari√°vel ajuda a entender e evita repeti√ß√£o.
            
            . Evite se isso deixar a condi√ß√£o ‚Äúcr√≠ptica‚Äù ou se criar vari√°vel ‚Äúfantasma‚Äù (ningu√©m sabe de onde veio).

            Boa pr√°tica: usar par√™nteses em condi√ß√µes:

                if (n := len(a)) > 10:
                    ...

        O que N√ÉO √©:

            N√£o √© ‚Äúatalho de performance m√°gica‚Äù sempre.

            N√£o substitui = normal.

            N√£o √© ‚Äúobrigat√≥rio‚Äù ‚Äî √© ferramenta de casos espec√≠ficos.

        Erros comuns:

            Usar walrus s√≥ para ‚Äúencurtar‚Äù c√≥digo e piorar legibilidade.

            Misturar com l√≥gica complexa no if/while.

            Esquecer que ele cria/atualiza a vari√°vel no escopo atual (pode confundir em fun√ß√µes longas).

        Frases-chave

            ‚ÄúAtribui e devolve o valor.‚Äù

            ‚ÄúUse para evitar repeti√ß√£o e deixar mais claro.‚Äù

            Regra de ouro: Se o walrus n√£o deixar o c√≥digo mais leg√≠vel, n√£o use.

    =====================================================================

    M√≥dulo math e numpy:

        - Antes de entrar em math e numpy, alinhar conceito de arquiteto:

        O que √© cada coisa?

            | Conceito       | O que √©                              | Exemplo             |
            | -------------- | ------------------------------------ | ------------------- |
            | **M√≥dulo**     | Arquivo `.py` com fun√ß√µes/constantes | `math`, `random`    |
            | **Biblioteca** | Conjunto de m√≥dulos                  | `numpy`, `pandas`   |
            | **Framework**  | Estrutura que manda no fluxo         | `Django`, `FastAPI` |

        - math = m√≥dulo padr√£o

        - numpy = biblioteca externa (cient√≠fica)

        M√ìDULO math ‚Äî O B√ÅSICO PROFISSIONAL:

            O que o math √©?

                Parte da biblioteca padr√£o

                Implementado em C

                Focado em n√∫meros escalares

                N√£o trabalha com vetores ou matrizes

            Importa√ß√£o:

                import math

            ou (menos recomendado):

                from math import sqrt, sin, cos

        Fun√ß√µes essenciais do math:

            . Constantes

                math.pi      # œÄ
                math.e       # n√∫mero de Euler
                math.inf     # infinito
                math.nan     # Not a Number

            . Raiz e pot√™ncia

                math.sqrt(16)      # 4.0
                math.pow(2, 3)     # 8.0  (sempre float)

            Profissionalmente:

                Prefira ** para pot√™ncia

                math.pow existe por compatibilidade matem√°tica

            . Trigonometria (radianos!):

                EX:
                
                    math.sin(math.pi / 2)  # 1.0
                    math.cos(0)            # 1.0
                    math.tan(math.pi / 4)

                Erro cl√°ssico de iniciante: usar graus

                Solu√ß√£o:

                    math.sin(math.radians(30))

            . Logaritmos:

                EX:

                    math.log(10)        # log natural
                    math.log10(100)     # base 10
                    math.log(8, 2)      # base 2

            . Arredondamento:

                EX:

                    math.floor(3.7)   # 3
                    math.ceil(3.1)    # 4
                    math.trunc(3.9)   # 3

            Limita√ß√µes do math (importante!):

                math.sqrt([1, 4, 9])  # ‚ùå ERRO

            Por qu√™?

                math n√£o √© vetorizado

                Ele trabalha um n√∫mero por vez

            Aqui nasce o numpy.

        NUMPY ‚Äî A VIRADA DE CHAVE PROFISSIONAL:

            O que √© o numpy?

                Biblioteca cient√≠fica

                Base de Data Science, IA, Engenharia, F√≠sica

                Implementada em C + Fortran

                Extremamente r√°pida

                Vetorizada

            Instala√ß√£o:

                pip install numpy

            Importa√ß√£o padr√£o (profissional):

                import numpy as np

            O conceito mais importante do NumPy:

                - Tudo gira em torno do ndarray

                EX:

                    import numpy as np

                    a = np.array([1, 2, 3])

                Isso n√£o √© uma lista.

                Diferen√ßa real:

                    | Lista Python   | ndarray             |
                    | -------------- | ------------------- |
                    | heterog√™nea    | homog√™neo           |
                    | lenta          | extremamente r√°pida |
                    | loop expl√≠cito | vetoriza√ß√£o         |

            Vetoriza√ß√£o (onde o numpy humilha):

                Python puro:

                    lista = [1, 2, 3]
                    resultado = []

                    for x in lista:
                        resultado.append(x * 2)

                NumPy:

                    a = np.array([1, 2, 3])
                    a * 2

                - Sem loop expl√≠cito
                - Mais r√°pido
                - Mais leg√≠vel

        Usando fun√ß√µes do math no numpy:

            O numpy reimplementa tudo de forma vetorial:

                np.sqrt([1, 4, 9])        # array([1., 2., 3.])
                np.sin([0, np.pi/2])
                np.log([1, 10, 100])

            Importante:

                math.sqrt(np.array([1, 4, 9]))
                np.sqrt(np.array([1, 4, 9]))

            Opera√ß√µes matem√°ticas reais:

                a = np.array([1, 2, 3])
                b = np.array([4, 5, 6])

                a + b     # soma vetorial
                a * b     # multiplica√ß√£o elemento a elemento
                a @ b     # produto escalar

        Estat√≠stica b√°sica (profissional):

            dados = np.array([10, 20, 30, 40])

            np.mean(dados)
            np.std(dados)
            np.var(dados)
            np.min(dados)
            np.max(dados)

        Regra de ouro (grave isso)

            math ‚Üí c√°lculo pontual, simples, escalar
            numpy ‚Üí dados, vetores, matrizes, desempenho

    =====================================================================

    M√≥dulos e controle de sistema com PYTHON 
    (shutil, sys, os, psutil, platform, subprocess, signal):

        Ideia central: esses m√≥dulos s√£o a ‚Äúponte‚Äù entre Python e o sistema 
        operacional (Linux/Windows/macOS): arquivos, processos, vari√°veis de 
        ambiente, comandos, sinais, monitoramento.

        Mapa mental r√°pido: quem faz o qu√™

            sys: informa√ß√µes do interpretador + argumentos do programa + 
            stdin/stdout.

            os: caminhos, pastas, vari√°veis de ambiente, permiss√µes, chamadas 
            simples ao SO.

            shutil: opera√ß√µes ‚Äúde alto n√≠vel‚Äù com arquivos/pastas (copiar, 
            mover, apagar, zipar).

            platform: descobrir detalhes do sistema (SO, vers√£o, arquitetura).

            subprocess: executar comandos externos com controle (o jeito ‚Äúcerto‚Äù).

            signal: lidar com sinais (CTRL+C, kill, terminar com seguran√ßa).

            psutil: monitorar CPU/RAM/disco/rede e processos (super √∫til; 
            precisa instalar).

        1) sys ‚Äî o ‚Äúpainel‚Äù do Python rodando

            sys.argv (argumentos de linha de comando)

                EX:

                    import sys

                    print(sys.argv)  # lista de strings

                Rodando:

                    python app.py --modo rapido 10

                Sa√≠da:

                    ['app.py', '--modo', 'rapido', '10']

            sys.exit(codigo)

                EX:

                    import sys

                    if True:
                        print("Erro!")
                        sys.exit(1)   # 0 = ok, !=0 = erro

            sys.path (onde o Python procura m√≥dulos)

                EX:

                    import sys
                    print(sys.path)

        2) os ‚Äî sistema, caminhos, ambiente e arquivos

            Caminhos e diret√≥rios:

                import os

                print(os.getcwd())          # pasta atual
                os.chdir("/tmp")            # muda diret√≥rio (cuidado!)
                print(os.listdir("."))      # lista arquivos/pastas

            Vari√°veis de ambiente:

                import os

                print(os.environ.get("HOME"))          # Linux/mac
                print(os.environ.get("USERPROFILE"))   # Windows

            Criar pastas (sem erro se j√° existir):

                import os

                os.makedirs("logs/2026/fev", exist_ok=True)

            Nota: para caminhos, o melhor hoje √© pathlib (mas os continua muito 
            usado).

        3) shutil ‚Äî copiar/mover/apagar/zipar

            Copiar arquivo:

                import shutil

                shutil.copy2("origem.txt", "backup/origem.txt")  # copy2 preserva metadados

            Copiar pasta inteira:

                import shutil

                shutil.copytree("meu_projeto", "meu_projeto_backup", dirs_exist_ok=True)

            Mover/renomear:

                import shutil

                shutil.move("arquivo.txt", "pasta/arquivo.txt")

            Apagar pasta inteira (cuidado!):

                import shutil

                shutil.rmtree("pasta_velha")

            Criar ZIP:

                import shutil

                shutil.make_archive("backup_projeto", "zip", "meu_projeto")
                # gera backup_projeto.zip

        4) platform ‚Äî descobrir o sistema

            EX:

                import platform

                print(platform.system())        # 'Linux', 'Windows', 'Darwin'
                print(platform.release())       # vers√£o do kernel/Windows
                print(platform.machine())       # 'x86_64', 'arm64'
                print(platform.python_version())

            Uso cl√°ssico: fazer c√≥digo diferente por SO:

                import platform

                if platform.system() == "Windows":
                    print("Rodando no Windows")
                else:
                    print("Rodando no Linux/mac")

        5) subprocess ‚Äî executar comandos externos (do jeito certo)

            Evite os.system(...) ‚Äî prefira subprocess.

            Caso simples: rodar e ver sa√≠da

                import subprocess

                resultado = subprocess.run(
                    ["python", "--version"],
                    capture_output=True,
                    text=True
                )

                print("stdout:", resultado.stdout)
                print("stderr:", resultado.stderr)
                print("returncode:", resultado.returncode)

            Rodar comando que pode falhar e levantar erro

                import subprocess

                subprocess.run(["ls", "-la"], check=True)

            Rodar via shell (s√≥ quando necess√°rio)

                import subprocess

                subprocess.run("echo OI && echo TCHAU", shell=True, check=True)

            - Regra de ouro: quando puder, use lista ["cmd", "arg1"] em vez de 
            string.

        6) signal ‚Äî lidar com CTRL+C e encerramento seguro

            Em Python, CTRL+C gera KeyboardInterrupt e tamb√©m um sinal (SIGINT).
            Voc√™ pode ‚Äúcapturar‚Äù para fechar recursos:

                import signal
                import time

                rodando = True

                def ao_sair(sig, frame):
                    global rodando
                    print(f"\nRecebi sinal {sig}. Encerrando com seguran√ßa...")
                    rodando = False

                signal.signal(signal.SIGINT, ao_sair)   # CTRL+C
                signal.signal(signal.SIGTERM, ao_sair)  # kill padr√£o no Linux

                while rodando:
                    print("Trabalhando...")
                    time.sleep(1)

                print("Finalizado.")

        7) psutil ‚Äî monitorar recursos e processos (muito usado em DevOps)

            Instala√ß√£o:

                pip install psutil

            CPU e RAM:

                import psutil

                print("CPU %:", psutil.cpu_percent(interval=1))
                mem = psutil.virtual_memory()
                print("RAM total:", mem.total)
                print("RAM usada %:", mem.percent)

            Discos:

                import psutil

                disco = psutil.disk_usage("/")
                print(disco.total, disco.used, disco.percent)

            Listar processos (nome + pid):

                import psutil

                for p in psutil.process_iter(["pid", "name"]):
                    print(p.info)

            Encerrar processos por nome (ex.: chrome) ‚Äî cuidado

                import psutil

                alvo = "chrome"

                for p in psutil.process_iter(["pid", "name"]):
                    nome = (p.info["name"] or "").lower()
                    if alvo in nome:
                        try:
                            p.terminate()  # pede para encerrar
                        except psutil.Error:
                            pass

        Mini-projeto pr√°tico (juntando tudo): ‚Äúdiagn√≥stico do PC‚Äù

            Esse script:

                detecta SO (platform)
                
                mostra caminho atual (os)
                
                mostra CPU/RAM (psutil)
                
                mostra argumentos (sys.argv)

            EX:

            import os
            import sys
            import platform

            try:
                import psutil
            except ImportError:
                psutil = None

            print("=== DIAGN√ìSTICO ===")
            print("SO:", platform.system(), platform.release())
            print("Python:", platform.python_version())
            print("Pasta atual:", os.getcwd())
            print("Args:", sys.argv)

            if psutil:
                print("CPU %:", psutil.cpu_percent(interval=1))
                print("RAM %:", psutil.virtual_memory().percent)
            else:
                print("psutil n√£o instalado. Rode: pip install psutil")


    =====================================================================

        dotenv:

        - dotenv serve para carregar vari√°veis de ambiente a partir de um 
        rquivo .env.

        Em vez de colocar senhas, tokens, chaves e configs sens√≠veis direto no 
        c√≥digo (ERRADO), voc√™ coloca num arquivo separado.

        Vari√°veis de ambiente:

            Vari√°veis de ambiente s√£o valores guardados pelo sistema 
            operacional, n√£o pelo seu programa.

            Elas existem:

                fora do c√≥digo

                antes do programa rodar

                e podem ser lidas por qualquer programa que o sistema execute

            Pense nelas como configura√ß√µes globais do sistema.

            Analogia simples

                Imagine seu computador como uma casa:

                    O sistema operacional √© a casa

                    Os programas s√£o pessoas que entram na casa

                    As vari√°veis de ambiente s√£o bilhetes colados na parede

                Qualquer pessoa que entra pode ler:

                    ‚ÄúPORTA = azul‚Äù

                    ‚ÄúTEMPERATURA = 22‚Äù

                Mas o bilhete n√£o est√° dentro da pessoa, est√° na casa.

            Exemplo real de vari√°vel de ambiente:

                Algumas muito comuns:

                    PATH ‚Üí onde o sistema procura programas
                    HOME ‚Üí sua pasta pessoal
                    USER / USERNAME ‚Üí seu usu√°rio
                    LANG ‚Üí idioma do sistema
                    PYTHONPATH ‚Üí onde o Python procura m√≥dulos

            Como ver vari√°veis de ambiente:

                No Linux / macOS:

                    env

                ou

                    echo $PATH

            No Windows (PowerShell):

                Get-ChildItem Env:

            Como acessar no Python:

                EX:

                    import os

                    print(os.environ["HOME"])

                Ou de forma segura:

                    import os

                    user = os.getenv("USER", "desconhecido")
                    print(user)

                - getenv evita erro se a vari√°vel n√£o existir.

            Para que elas servem na pr√°tica?

                1. Configura√ß√£o sem mexer no c√≥digo

                    Linux:

                        export DEBUG=true

                    Python:

                        if os.getenv("DEBUG") == "true":
                            print("Modo debug ativo")

                2. Guardar segredos (senha, token, API key)

                    Linux:
                        
                        export API_KEY="abc123"

                    Python:

                        api_key = os.getenv("API_KEY")

                Assim voc√™ n√£o coloca senha no c√≥digo.

                3. Configurar comportamento por ambiente

                    + DEV

                    + TESTE

                    + PRODU√á√ÉO

                    Linux:

                        export AMBIENTE=prod

                    Python:

                        if os.getenv("AMBIENTE") == "prod":
                            print("Rodando em produ√ß√£o")

            O que n√£o fazer:

                - N√£o usar vari√°vel de ambiente para dados tempor√°rios
                - N√£o confiar nelas para seguran√ßa total
                - N√£o hardcodar senha no c√≥digo

            Vari√°vel de ambiente = configura√ß√£o externa ao programa

            Em software profissional, elas servem para separar c√≥digo de 
            configura√ß√£o. C√≥digo n√£o muda, ambiente muda.

            Configura√ß√£o por ambiente (DEV / TEST / PROD):

                Voc√™ tem o mesmo c√≥digo, mas ele roda em lugares diferentes:

                    | Ambiente | Banco          | Debug     |
                    | -------- | -------------- | --------- |
                    | DEV      | localhost      | ligado    |
                    | TEST     | banco de teste | desligado |
                    | PROD     | banco real     | desligado |

                Linux:

                    export ENV=dev

                Python:

                    import os

                    if os.getenv("ENV") == "dev":
                        DEBUG = True
                    else:
                        DEBUG = False

            Segredos e credenciais:

                Nunca se coloca isso no c√≥digo:

                    senha de banco

                    token de API

                    chave privada

                Linux:

                    export DB_PASSWORD="senha_super_secreta"

                Python:

                    senha = os.getenv("DB_PASSWORD")

                Assim:

                    o c√≥digo pode ir para o Git

                    o segredo n√£o

            Feature flags (ligar/desligar recursos):

                Muito usado em sistemas grandes.

                EX:

                    export NOVO_RELATORIO=true

                Python:

                    if os.getenv("NOVO_RELATORIO") == "true":
                        gerar_relatorio_novo()
                    else:
                        gerar_relatorio_antigo()

            Integra√ß√£o com containers e CI/CD:

                Docker, GitHub Actions, GitLab CI usam vari√°veis de ambiente 
                como padr√£o.

                    env:
                        DATABASE_URL: postgres://...

                O c√≥digo n√£o sabe de onde veio, s√≥ l√™.

            Logs, n√≠veis e comportamento:

                Linux:

                    export LOG_LEVEL=INFO

                Python:

                    import logging

                    logging.basicConfig(level=os.getenv("LOG_LEVEL", "WARNING"))

            Portas, paths e recursos externos:

                Linux:

                    export PORT=8080

                Python:

                    porta = int(os.getenv("PORT", 8000))

            Anti-padr√µes comuns:

                . config.py com senha dentro
                . if baseado em hostname fixo
                . alterar c√≥digo para mudar ambiente

            Regra de ouro (arquitetura)

                Configura√ß√£o pertence ao ambiente, n√£o ao c√≥digo.

            Fluxo mental correto:

                1. O sistema define o ambiente
                2. O c√≥digo l√™ o ambiente
                3. O comportamento se adapta

        O jeito errado (N√ÉO FA√áA):

            EX:

                API_KEY = "sk-123456"
                DB_PASSWORD = "senha123"

            Problemas:

                vaza no GitHub

                vaza em print, log, erro

                imposs√≠vel trocar ambiente (dev / prod)

        O jeito certo (PROFISSIONAL):

            EX:

                API_KEY=sk-123456
                DB_PASSWORD=senha123
                DEBUG=True

            E no Python:

                import os

                api_key = os.getenv("API_KEY")

        Instala√ß√£o do dotenv:

            pip install python-dotenv

        - O pacote se chama python-dotenv, o m√≥dulo importado √© dotenv.

        Estrutura de projeto correta:

            meu_projeto/
            ‚îÇ
            ‚îú‚îÄ .env
            ‚îú‚îÄ .gitignore
            ‚îú‚îÄ main.py
            ‚îú‚îÄ config.py
            ‚îî‚îÄ venv/

        No .gitignore:

            .env

        PS: .env NUNCA vai para o Git.

        Sintaxe do arquivo .env:

            # Coment√°rios come√ßam com #
            DEBUG=True
            PORT=8000

            DB_HOST=localhost
            DB_USER=admin
            DB_PASS=123456

            API_KEY="minha-chave-secreta"

        Regras importantes:

            . N√ÉO usar espa√ßos:

                DB_USER = admin

            . Correto:

                DB_USER=admin

            . Strings n√£o precisam de aspas (s√≥ se tiver espa√ßo)

            . Tudo √© string

        Como carregar o .env:

            Forma correta (b√°sica):

                from dotenv import load_dotenv
                import os

                load_dotenv()  # carrega o .env

                api_key = os.getenv("API_KEY")
                print(api_key)

            load_dotenv():

                . l√™ o arquivo .env

                . injeta tudo em os.environ

        Forma profissional (arquivo de config):

            - Esse padr√£o √© muito usado em projetos reais

            config.py:

                from dotenv import load_dotenv
                import os

                load_dotenv()

                DEBUG = os.getenv("DEBUG") == "True"
                PORT = int(os.getenv("PORT", 8000))

                DB_HOST = os.getenv("DB_HOST")
                DB_USER = os.getenv("DB_USER")
                DB_PASS = os.getenv("DB_PASS")

            main.py:

                from config import DEBUG, PORT

                print(DEBUG)
                print(PORT)

        os.getenv() vs os.environ:

            os.getenv():

                EX:
                
                    os.getenv("API_KEY")
                    os.getenv("PORT", 8000)  # valor padr√£o

                . N√£o quebra se n√£o existir
                . Mais seguro

            os.environ[]:

                EX:

                    os.environ["API_KEY"]

                . Lan√ßa erro se n√£o existir
                . √ötil quando a vari√°vel √© obrigat√≥ria

            Padr√£o profissional:

                API_KEY = os.getenv("API_KEY")
                if not API_KEY:
                    raise RuntimeError("API_KEY n√£o definida")

        Usando dotenv em m√∫ltiplos ambientes:

            Exemplo de arquivos:

                .env.dev
                .env.prod

            Carregar manualmente:

                from dotenv import load_dotenv

                load_dotenv(".env.dev")

            Ou:

                load_dotenv(".env.prod")

        Fun√ß√µes importantes do dotenv:

            EX:

                from dotenv import (
                    load_dotenv,
                    find_dotenv,
                    dotenv_values
                )

            find_dotenv():

                - Procura .env automaticamente:

                    load_dotenv(find_dotenv())

            dotenv_values() (sem jogar no ambiente):

                    from dotenv import dotenv_values

                    config = dotenv_values(".env")
                    print(config["API_KEY"])

                Bom para:

                    testes

                    leitura isolada

                    scripts

        O que √© a t√©cnica .env + .env-example?

            √â uma forma de:

                usar vari√°veis de ambiente

                sem expor segredos

                sem quebrar o projeto para quem clona o reposit√≥rio

            Ela separa configura√ß√£o sens√≠vel de documenta√ß√£o de configura√ß√£o.

            Arquivos envolvidos:

                1. .env ‚Üí configura√ß√£o real (N√ÉO versionada)

                    . Cont√©m valores de verdade
                    . Pode ter senha, token, chave
                    . Nunca vai para o Git

                    Exemplo:

                        DB_HOST=localhost
                        DB_USER=admin
                        DB_PASSWORD=senha_super_secreta
                        DEBUG=true
                        PORT=8000

                    Esse arquivo fica s√≥ na sua m√°quina / servidor.

                2. .env-example ‚Üí modelo/documenta√ß√£o (versionado)

                    . Mostra quais vari√°veis o projeto espera
                    . N√£o cont√©m segredos reais
                    . Vai para o Git

                    Exemplo:

                        DB_HOST=
                        DB_USER=
                        DB_PASSWORD=
                        DEBUG=
                        PORT=

                    Ou com valores ilustrativos:

                        DB_HOST=localhost
                        DB_USER=usuario
                        DB_PASSWORD=senha_aqui
                        DEBUG=false
                        PORT=8000

            Por que isso √© uma t√©cnica t√£o boa?

                Seguran√ßa

                    Senhas n√£o v√£o para o reposit√≥rio

                    Evita vazamento acidental

                Onboarding f√°cil

                    Quem clona o projeto:

                        copia .env-example ‚Üí .env

                        preenche os valores

                        roda o projeto
                    
                    Sem perguntar nada.
            
            Fluxo real de uso:

                Passo 1 ‚Äî .gitignore

                    .env

                Passo 2 ‚Äî criar .env-example

                    DATABASE_URL=
                    API_KEY=
                    LOG_LEVEL=

                Passo 3 ‚Äî cada dev cria seu .env

                    load_dotenv() l√™ o .env e injeta no ambiente.

            Detalhes importantes (muitos erram):

                N√£o colocar .env no Git

                    Mesmo sem senha hoje ‚Äî amanh√£ pode ter.

                N√£o usar .env como config l√≥gica

                    Nada de:

                        USAR_CACHE=True

                    para l√≥gica complexa sem valida√ß√£o.

            Regra mental

                .env = dados reais
                .env-example = contrato de configura√ß√£o

        Erros comuns:

            . Esquecer de chamar load_dotenv()
            . Subir .env para o Git
            . Usar dotenv para:
                l√≥gica
                listas
                objetos complexos

            - dotenv √© para configura√ß√£o simples

        Exemplo REAL: conex√£o com banco:

            .env:

                DB_HOST=localhost
                DB_PORT=5432
                DB_USER=admin
                DB_PASS=senha

            db.py:

                import os
                from dotenv import load_dotenv

                load_dotenv()

                conn_str = (
                    f"postgresql://{os.getenv('DB_USER')}:"
                    f"{os.getenv('DB_PASS')}@"
                    f"{os.getenv('DB_HOST')}:"
                    f"{os.getenv('DB_PORT')}/meubanco"
                )

                print(conn_str)

        Quando usar dotenv:

            Use dotenv para:

                senhas

                tokens

                URLs

                portas

                flags (DEBUG)

            N√ÉO use dotenv para:

                l√≥gica de neg√≥cio

                dados do usu√°rio

                estruturas complexas

    =====================================================================

    time, datetime e locale:

        TIME:

            - Usado para pausas, medir tempo, timestamps.

            Exemplo 1 ‚Äî pausa no programa

                import time

                print("Come√ßando...")
                time.sleep(2)
                print("2 segundos depois")

            Exemplo 2 ‚Äî timestamp atual (epoch)

            - Retorna segundos desde 01/01/1970 (Unix Epoch).

                import time

                agora = time.time()
                print(agora)

            Exemplo 3 ‚Äî medir tempo de execu√ß√£o

                import time

                inicio = time.time()

                time.sleep(1.5)

                fim = time.time()

                print(f"Tempo gasto: {fim - inicio:.2f} segundos")

        DATETIME:

            Exemplo 4 ‚Äî data e hora atual

                from datetime import datetime

                agora = datetime.now()
                print(agora)

            Exemplo 5 ‚Äî formatar data e hora

                EX:

                    from datetime import datetime

                    agora = datetime.now()

                    print(agora.strftime("%d/%m/%Y"))
                    print(agora.strftime("%H:%M:%S"))

                Alguns formatos importantes:

                    . %d ‚Üí dia
                    . %m ‚Üí m√™s
                    . %Y ‚Üí ano
                    . %H ‚Üí hora
                    . %M ‚Üí minuto
                    . %S ‚Üí segundo

            Exemplo 6 ‚Äî criar uma data manualmente

                from datetime import datetime

                data = datetime(2026, 2, 3, 10, 30)
                print(data)

            Exemplo 7 ‚Äî diferen√ßa entre datas

                from datetime import datetime

                inicio = datetime(2026, 2, 1)
                fim = datetime(2026, 2, 3)

                diferenca = fim - inicio
                print(diferenca.days)

        LOCALE:

            - Usado para datas em portugu√™s, valores monet√°rios, relat√≥rios.

            Exemplo 8 ‚Äî definir locale para portugu√™s do Brasil

                EX:

                    import locale

                    locale.setlocale(locale.LC_ALL, "pt_BR.UTF-8")

                No Windows pode ser:

                    locale.setlocale(locale.LC_ALL, "Portuguese_Brazil")

            Exemplo 9 ‚Äî data por extenso (pt-BR)

                EX:

                    from datetime import datetime
                    import locale

                    locale.setlocale(locale.LC_TIME, "pt_BR.UTF-8")

                    agora = datetime.now()
                    print(agora.strftime("%A, %d de %B de %Y"))

                Exemplo de sa√≠da:

                    ter√ßa-feira, 03 de fevereiro de 2026

            Exemplo 10 ‚Äî moeda brasileira

                EX:

                    import locale

                    locale.setlocale(locale.LC_ALL, "pt_BR.UTF-8")

                    valor = 1234.56
                    print(locale.currency(valor, grouping=True))

                Sa√≠da:

                    R$ 1.234,56

        Compara√ß√£o r√°pida:

            | M√≥dulo     | Para que serve                     |
            | ---------- | ---------------------------------- |
            | `time`     | pausa, timestamp, medir execu√ß√£o   |
            | `datetime` | datas, horas, c√°lculos             |
            | `locale`   | idioma, moeda, formata√ß√£o regional |

    =====================================================================

    Pathlib e glob:

        - pathlib √© um m√≥dulo da biblioteca padr√£o que trata caminhos como 
        objetos, n√£o como strings.

        Em vez disso:

            "/home/user/projeto/arquivo.txt"

        Voc√™ trabalha com isso:

            Path("arquivo.txt")

        Resultado:

            c√≥digo mais limpo

            menos bugs

            multiplataforma autom√°tico (Windows/Linux/macOS)

        Jeito antigo (os.path):

            import os

            caminho = os.path.join(os.getcwd(), "dados", "arquivo.txt")

        Jeito moderno (pathlib)

            from pathlib import Path

            caminho = Path.cwd() / "dados" / "arquivo.txt"

        Muito mais leg√≠vel.

        Importa√ß√£o b√°sica:

            from pathlib import Path

        Criando caminhos:

            Pasta atual

                Path.cwd()

            Pasta home do usu√°rio

                Path.home()

            Caminho relativo
            
                p = Path("dados/arquivo.txt")

            Caminho absoluto

                p = Path("/tmp/arquivo.txt")

        Testes importantes (arquivo ou pasta?):

            p.exists()     # existe?
            p.is_file()    # √© arquivo?
            p.is_dir()     # √© pasta?

        Exemplo:

            p = Path("config.py")

            if p.exists():
                print("Existe")

        Criar pastas (limpo e seguro):

            Path("backup").mkdir(exist_ok=True)

        Criar hierarquia:

            Path("logs/2026/fev").mkdir(parents=True, exist_ok=True)

        Ler e escrever arquivos (muito elegante):

            Ler texto

                texto = Path("arquivo.txt").read_text(encoding="utf-8")

            Escrever texto
                
                Path("arquivo.txt").write_text("Ol√° mundo", encoding="utf-8")

            Sem open(), sem close().

        Partes do caminho:

            p = Path("/home/renato/projeto/main.py")

            print(p.name)        # main.py
            print(p.stem)        # main
            print(p.suffix)      # .py
            print(p.parent)      # /home/renato/projeto
            print(p.parents[0])  # projeto

        Iterar arquivos de uma pasta:

            for item in Path.cwd().iterdir():
                print(item)

        Somente arquivos .py:

            for py in Path.cwd().iterdir():
                if py.suffix == ".py":
                    print(py)

        Agora entra o glob

            glob serve para buscar arquivos por padr√£o (wildcards).

            Exemplo mental:

                *.py

                data_*.csv

                **/*.txt

        Path.glob():

            from pathlib import Path

            for arquivo in Path.cwd().glob("*.py"):
                print(arquivo)

        . Busca somente na pasta atual.

        Busca recursiva (subpastas)

            for arquivo in Path.cwd().glob("**/*.py"):
                print(arquivo)

        . ** = tudo, recursivo.

        1. Listar todos os .py (menos venv):

            from pathlib import Path

            for p in Path.cwd().glob("**/*.py"):
                if "venv" not in p.parts:
                    print(p)

        2. Criar backup de arquivos .txt

            from pathlib import Path
            import shutil

            backup = Path("backup")
            backup.mkdir(exist_ok=True)

            for arquivo in Path.cwd().glob("*.txt"):
                shutil.copy2(arquivo, backup / arquivo.name)

        3. Contar arquivos por extens√£o

            from pathlib import Path

            contador = {}

            for p in Path.cwd().glob("**/*"):
                if p.is_file():
                    contador[p.suffix] = contador.get(p.suffix, 0) + 1

            print(contador)

        Erros comuns:

            Misturar string com Path:

                Path("dados") + "arquivo.txt"  # ERRO

            Correto:

                Path("dados") / "arquivo.txt"

            Esquecer que glob() retorna Path, n√£o string.

    =====================================================================

    zipfile, tarfile:

    =====================================================================

    Json:

    =====================================================================

    pyautogui:

    =====================================================================

    bs4:

    =====================================================================

    requests:

    =====================================================================

    curl_cffi:

    =====================================================================

    Selenium:

    =====================================================================

    playwright:

    =====================================================================

    scrappy:

    =====================================================================

    sockets, http.client e http.server:

    =====================================================================

    Pillow:

    =====================================================================

    io:

    =====================================================================

    logging e pdb:

    =====================================================================

    cryptography:

    ======================================================================


Um pouco sobre POO:

    Objetos e classes:

        O QUE √â UMA CLASSE?

            - Classe √© um molde.

            - √â como um modelo que define como algo deve ser.

        Nada existe de verdade ainda.

        √â s√≥ a ideia da coisa.

        Exemplo do mundo real:

            . Planta de uma casa ‚Üí classe

            . Casa constru√≠da ‚Üí objeto

            A planta:

                define quantos quartos

                define banheiro, cozinha

                define estrutura

            Mas n√£o √© a casa real.

        Em Python:

            Sintaxe:

                class Pessoa:
                    pass

            Isso significa:

                Existe um molde chamado Pessoa

                Mas ainda n√£o criamos nenhuma pessoa de verdade

        O QUE √â UM OBJETO?

            - Objeto √© algo criado a partir da classe.

            - √â a coisa real, concreta.

        Se a classe √© o molde,

        o objeto √© o que voc√™ usa de verdade no programa.

        Criando um objeto em Python:

            p1 = Pessoa()

        Agora sim:

            Pessoa ‚Üí classe

            p1 ‚Üí objeto (inst√¢ncia)

        Inst√¢ncia = objeto criado a partir de uma classe.

        CLASSE vs OBJETO (N√ÉO CONFUNDIR!):

            | Classe                 | Objeto          |
            | ---------------------- | --------------- |
            | Molde                  | Coisa real      |
            | N√£o ocupa mem√≥ria √∫til | Ocupa mem√≥ria   |
            | Defini√ß√£o              | Uso             |
            | `class Pessoa`         | `p1 = Pessoa()` |

            Erro cl√°ssico: achar que classe e objeto s√£o a mesma coisa.

            N√£o s√£o. Nunca.

        ATRIBUTOS ‚Äî DADOS DO OBJETO:

            Atributos s√£o:

                caracter√≠sticas

                informa√ß√µes

                dados do objeto

        Exemplo:

            Pessoa tem:

                nome

                idade

        Criando atributos com __init__:

            class Pessoa:
                def __init__(self, nome, idade):
                    self.nome = nome
                    self.idade = idade

        Aqui tem MUITA coisa importante, ent√£o vamos quebrar.

        O que √© __init__?

            . √â um m√©todo especial
            . Executa automaticamente quando o objeto √© criado
            . Serve para montar o objeto por dentro

        √â como ‚Äúligar‚Äù o objeto.

        O que √© self?

            - self √© o pr√≥prio objeto

            - D√° ideia de pr√≥prio ou eu na execu√ß√£o

            Quando voc√™ escreve:

                self.nome = nome

            Voc√™ est√° dizendo:

                ‚ÄúEste objeto vai ter um atributo chamado nome‚Äù

                OU Inconcientemente como uma pessoa
 
                "Eu como objeto terei um atributo chamado nome"

        Criando o objeto agora:

            EX:

                p1 = Pessoa("Renato", 25)

            Dentro do Python acontece:

                self.nome = "Renato"

                self.idade = 25

        Acessando os atributos:

            print(p1.nome)
            print(p1.idade)

        M√âTODOS ‚Äî A√á√ïES DO OBJETO:

            M√©todos s√£o:

                fun√ß√µes

                que vivem dentro da classe

                e trabalham com o objeto

            Exemplo:

                class Pessoa:
                    def __init__(self, nome, idade):
                        self.nome = nome
                        self.idade = idade

                    def falar(self):
                        print(f"Meu nome √© {self.nome}")

            Usando:

                p1 = Pessoa("Renato", 25)
                p1.falar()

            Importante:

                M√©todo SEMPRE recebe self

                Voc√™ chama com objeto.metodo()

        POR QUE USAR CLASSES E OBJETOS?

            Sem POO:

                c√≥digo espalhado

                dif√≠cil de manter

                dif√≠cil de entender

            Com POO:

                c√≥digo organizado

                cada coisa cuida de si

                mais f√°cil crescer o projeto

        Projetos grandes SEM POO viram bagun√ßa.

        ERROS MAIS COMUNS:

            . Esquecer o self
            . Criar classe e tentar usar sem criar objeto
            . Confundir atributo com vari√°vel comum
            . Tentar acessar atributo sem objeto.

            Exemplo errado:

                print(nome)  # ERRADO

            Certo:

                print(p1.nome)  # CORRETO

        DETAHLES ADICIONAIS:

            1) Por que nomes de classes come√ßam com MAI√öSCULA?

                - N√£o √© ‚Äúobriga√ß√£o‚Äù do Python, √© conven√ß√£o (PEP 8). Em Python:

                    Classe: CamelCase (Primeira letra mai√∫scula)

                    Vari√°vel / fun√ß√£o / m√©todo: snake_case (min√∫sculas com _)

                Por que isso existe (na pr√°tica)?

                    1. Leitura instant√¢nea do c√≥digo
                        Quando voc√™ v√™ Pessoa(...), seu c√©rebro bate o olho e 
                        entende: ‚Äúisso √© uma classe sendo instanciada‚Äù

                    2. Evita confus√£o entre ‚Äúcoisa‚Äù (tipo/estrutura) e 
                    ‚Äúa√ß√£o/valor‚Äù (fun√ß√£o/vari√°vel).
    
                    3. Padr√£o de equipe / projetos grandes
                        Python √© muito usado em times. Seguir conven√ß√£o deixa 
                        seu c√≥digo ‚Äúprofissional‚Äù e f√°cil de manter.

                Funciona assim:

                    class Pessoa:          # Classe (CamelCase)
                        pass

                    def criar_pessoa():    # Fun√ß√£o (snake_case)
                        pass

                    nome_usuario = "Renato"  # Vari√°vel (snake_case)

                - Se voc√™ chamar uma classe de pessoa, o Python aceita, mas 
                fica ‚Äúestranho‚Äù e aumenta a chance de confus√£o.

            2) Objetos vs Vari√°veis (esse aqui √© crucial)

                A verdade simples:

                    Vari√°vel √© um NOME (uma etiqueta)

                    Objeto √© a COISA na mem√≥ria

                A vari√°vel ‚Äúaponta‚Äù (referencia) um objeto.

                    Exemplo:

                        x = 10

                    . x = vari√°vel (nome)

                    . 10 = objeto inteiro (um int)

                    Com classe:

                        class Pessoa:
                            def __init__(self, nome):
                                self.nome = nome

                        p1 = Pessoa("Renato")

                    . p1 = vari√°vel (nome/etiqueta)

                    . Pessoa("Renato") = objeto (inst√¢ncia) na mem√≥ria

                    Ent√£o: p1 n√£o √© o objeto.

                    p1 √© s√≥ o ‚Äúapelido‚Äù que aponta pro objeto.

            3) Por que isso importa? (duas vari√°veis podem apontar pro MESMO 
            objeto)

                EX:

                    p1 = Pessoa("Renato")
                    p2 = p1

                Agora:

                    p1 e p2 s√£o vari√°veis diferentes

                    mas apontam pro mesmo objeto

                Se mudar por p2, muda por p1 tamb√©m:

                    p2.nome = "Jo√£o"
                    print(p1.nome)  # "Jo√£o"

                Porque o objeto √© o mesmo ‚Äî s√≥ tem duas etiquetas nele.

            4) ‚ÄúVari√°vel igual‚Äù n√£o significa ‚Äúobjeto igual‚Äù

                Exemplo com lista (bem visual):

                    a = [1, 2]
                    b = a
                    b.append(3)

                    print(a)  # [1, 2, 3]

                Mesma ideia: a e b apontam pro mesmo objeto lista.

        Python √© realmente Orientado a Objetos?

            Sim, Python TEM POO de verdade.

            Mas n√£o √© OO ‚Äúpuro‚Äù

            E √© exatamente isso que confunde muita gente

            1. O que significa ‚Äúlinguagem orientada a objetos‚Äù?

                Uma linguagem OO, em ess√™ncia, precisa permitir:

                    Objetos

                    Classes

                    Encapsulamento

                    Heran√ßa

                    Polimorfismo

                Python tem todos esses pontos.

                Ent√£o, tecnicamente, √© OO.

            2. Ent√£o por que dizem que Python ‚Äún√£o √© OO de verdade‚Äù?

                - Porque muita gente confunde OO obrigat√≥rio com OO existente.

                Em linguagens como o Java, por exemplo,
                tudo precisa estar classe, n√£o existe fun√ß√£o solta e 
                n√£o existe c√≥digo fora de objeto (na pr√°tica).

                A linguagem Java for√ßa OO

                Python (OO opcional e flex√≠vel)

                    No Python:

                        print("Hello")

                    . Fun√ß√µes soltas existem
                    . C√≥digo procedural existe
                    . OO √© uma ferramenta, n√£o uma pris√£o

                    Python permite, n√£o obriga.

            3. Python √© diferente porque o MODELO DE OBJETOS √© diferente

                Aqui est√° o ponto mais importante.

                Em Python:

                    Tudo √© objeto.

                        x = 10
                        print(type(x))   # <class 'int'>

                int √© uma classe

                10 √© um objeto

                fun√ß√µes s√£o objetos

                classes s√£o objetos

                Classe tamb√©m √© objeto:

                    - UMA CLASSE QUALQUER √© um objeto da classe type

            4. ‚ÄúPython n√£o serve para POO‚Äù ‚Äî de onde vem isso?

                Vem principalmente de 3 fontes:

                    1. Abuso de c√≥digo procedural

                        Muita gente escreve Python assim:

                            def faz_tudo():
                                pass

                        E nunca cria classes.

                        A culpa n√£o √© da linguagem ‚Äî √© do uso.

                    2. Falta de encapsulamento forte:

                        Em Python:

                            self._idade

                        O _ √© conven√ß√£o, n√£o trava real.

                        Alguns acham isso ‚ÄúPOO fraca‚Äù.
                        
                        Na verdade √© confian√ßa no programador.

                Python n√£o liga para o tipo, liga para o comportamento.

                Isso √© polimorfismo din√¢mico, n√£o aus√™ncia de POO.

        Python n√£o √© menos orientado a objetos.
    
        Ele √© menos dogm√°tico.

    ==========================================================================

    Vari√°veis de classe e Construtor:

        O CONSTRUTOR (__init__) ‚Äî O NASCIMENTO DO OBJETO:

            - O __init__ √© o m√©todo construtor

            Ele roda automaticamente quando o objeto √© criado.

            EX:

                class Pessoa:
                    def __init__(self, nome):
                        self.nome = nome

            Quando voc√™ faz:

                p1 = Pessoa("Renato")

            O Python faz internamente:

                1. cria o objeto vazio
                2. chama __init__(self, "Renato")
                3. inicializa os atributos

                - Sem __init__, o objeto nasce ‚Äúpelado‚Äù.

        ATRIBUTOS DE INST√ÇNCIA (do objeto):

            - Atributos que pertencem a cada objeto individualmente

            EX:

                class Pessoa:
                    def __init__(self, nome):
                        self.nome = nome

            Criando objetos:

                p1 = Pessoa("Renato")
                p2 = Pessoa("Ana")

            Resultado:

                p1.nome ‚Üí "Renato"

                p2.nome ‚Üí "Ana"

            Cada objeto tem seus pr√≥prios dados.

        VARI√ÅVEIS DE CLASSE:

            Vari√°vel de classe pertence √† classe, n√£o aos objetos 
            individualmente.

            . Ela √© compartilhada por todos.

            Exemplo simples:

                class Pessoa:
                    especie = "Humano"   # vari√°vel de classe

                    def __init__(self, nome):
                        self.nome = nome

            Usando:

                p1 = Pessoa("Renato")
                p2 = Pessoa("Ana")

                print(p1.especie)
                print(p2.especie)

            Ambos imprimem:

                Humano

            - Porque especie n√£o est√° no objeto, est√° na classe.

        Onde cada coisa vive na mem√≥ria?

            Atributo de inst√¢ncia:

                    self.nome

                . vive dentro do objeto

                . cada objeto tem o seu

            Vari√°vel de classe:

                    Pessoa.especie

                . vive na classe

                . todos os objetos compartilham

        A REGRA DE OURO:

            - Acesso n√£o muda propriedade

            Mesmo que voc√™ escreva:

                p1.especie

            Isso n√£o transforma especie em atributo do objeto.

            √â s√≥ um atalho para Pessoa.especie.

        O ERRO CL√ÅSSICO:

            Veja esse c√≥digo:

                class Pessoa:
                    contador = 0

                    def __init__(self):
                        self.contador += 1

            Criando objetos:

                p1 = Pessoa()
                p2 = Pessoa()

                print(Pessoa.contador)

            Resultado: 0
            ‚ÄúU√©, n√£o deveria ser 2?‚Äù

            O que aconteceu?

                self.contador += 1

            Isso cria um atributo novo no objeto, N√ÉO altera a vari√°vel de 
            classe.

        JEITO CERTO de mexer em vari√°vel de classe:

            EX:

                class Pessoa:
                    contador = 0

                    def __init__(self):
                        Pessoa.contador += 1

            Agora sim:

                p1 = Pessoa()
                p2 = Pessoa()

                print(Pessoa.contador)  # 2

            Sempre acesse vari√°vel de classe pelo nome da classe.

        Construtor com valores padr√£o:

            ex:

                class Produto:
                    def __init__(self, nome, preco=0.0):
                        self.nome = nome
                        self.preco = preco

            Uso:
            
                p1 = Produto("Caneta")
                p2 = Produto("Caderno", 15.0)


    ==========================================================================

    M√©todos:

        M√©todo √© uma fun√ß√£o que pertence a uma classe e atua sobre um objeto ou 
        sobre a pr√≥pria classe.

        Diferen√ßa-chave:

            Fun√ß√£o ‚Üí existe sozinha

            M√©todo ‚Üí vive dentro de uma classe

        Fun√ß√£o comum:

            def somar(a, b):
                return a + b

        M√©todo:

            class Calculadora:
                def somar(self, a, b):
                    return a + b

        M√âTODO DE INST√ÇNCIA:

            M√©todo que trabalha com dados do objeto
            
            Recebe self

            Exemplo b√°sico:

                class Pessoa:
                    def __init__(self, nome):
                        self.nome = nome

                    def falar(self):
                        print(f"Meu nome √© {self.nome}")

            Uso:

                p1 = Pessoa("Renato")
                p1.falar()

            O Python faz isso internamente:

                Pessoa.falar(p1)

        - self √© o pr√≥prio objeto passado automaticamente.

        REGRA DE OURO DOS M√âTODOS:

            Todo m√©todo de inst√¢ncia precisa de self

            e todo acesso a atributos precisa de self.

            ERRADO:

                print(nome)

            CERTO:

                print(self.nome)

        M√âTODOS COM PAR√ÇMETROS:

            class ContaBancaria:
                def __init__(self, saldo):
                    self.saldo = saldo

                def depositar(self, valor):
                    self.saldo += valor

                def sacar(self, valor):
                    self.saldo -= valor
        
            . uso:

                conta = ContaBancaria(100)
                conta.depositar(50)
                print(conta.saldo)  # 150

        M√âTODOS QUE RETORNAM VALORES:

            ex:

                class Aluno:
                    def __init__(self, nota):
                        self.nota = nota

                    def aprovado(self):
                        return self.nota >= 6

            Uso:

                a1 = Aluno(7)
                print(a1.aprovado())  # True

            - M√©todo n√£o precisa imprimir ‚Äî pode s√≥ retornar.

        M√âTODO QUE CHAMA OUTRO M√âTODO:

            EX:

                class Usuario:
                    def logar(self):
                        self._verificar_senha()
                        print("Usu√°rio logado")

                    def _verificar_senha(self):
                        print("Senha verificada")

            - self permite que m√©todos conversem entre si.

        M√âTODOS DE CLASSE (@classmethod):

            M√©todo que trabalha com a classe, n√£o com o objeto
            
            Recebe cls

            Exemplo cl√°ssico:

                class Usuario:
                    total = 0

                    def __init__(self):
                        Usuario.total += 1

                    @classmethod
                    def total_usuarios(cls):
                        return cls.total

            Uso:

                u1 = Usuario()
                u2 = Usuario()

                print(Usuario.total_usuarios())

            Use quando:

                . o m√©todo depende da classe

                . n√£o de um objeto espec√≠fico

        M√âTODOS EST√ÅTICOS (@staticmethod):

            - M√©todo que n√£o depende nem do objeto nem da classe

            √â basicamente:

                uma fun√ß√£o

                organizada dentro da classe

            Exemplo:

                class Matematica:
                    @staticmethod
                    def somar(a, b):
                        return a + b

            Uso:

                print(Matematica.somar(2, 3))

            N√£o usa self nem cls.

        QUANDO USAR CADA TIPO?

            | Tipo      | Usa    | Quando                   |
            | --------- | ------ | ------------------------ |
            | Inst√¢ncia | `self` | mexe nos dados do objeto |
            | Classe    | `cls`  | mexe nos dados da classe |
            | Est√°tico  | nada   | l√≥gica auxiliar          |

        ERROS CL√ÅSSICOS:

            . Esquecer self
            . Tentar acessar atributo sem self.
            . Usar @staticmethod quando precisa de self
            . Colocar l√≥gica de objeto em m√©todo de classe

    ==========================================================================

    Fun√ß√µes com classes e vice-versa:

        FUN√á√ÉO ‚â† M√âTODO (mas parecem)

            Fun√ß√£o

                Vive fora da classe

                N√£o tem self

                N√£o pertence a nenhum objeto

                EX:

                    def somar(a, b):
                        return a + b

            M√©todo

                Vive dentro da classe

                Pertence √† classe

                Geralmente recebe self

                EX:

                    class Calculadora:
                        def somar(self, a, b):
                            return a + b

                - M√©todo √© uma fun√ß√£o especial, com contexto de objeto ou classe.

        FUN√á√ïES USANDO OBJETOS (fun√ß√£o ‚Äúconversa‚Äù com classe)

            Isso √© muito comum e totalmente correto.

            Exemplo:

                class Pessoa:
                    def __init__(self, nome):
                        self.nome = nome

            Fun√ß√£o externa usando objeto:

                def apresentar(pessoa):
                    print(f"Ol√°, meu nome √© {pessoa.nome}")

            Uso:

                p1 = Pessoa("Renato")
                apresentar(p1)

            A fun√ß√£o:

                . n√£o pertence √† classe

                . mas usa o objeto normalmente

            Isso funciona porque:

                Python liga mais para comportamento do que para ‚Äúonde a fun√ß√£o 
                mora‚Äù.

        QUANDO USAR FUN√á√ÉO E N√ÉO M√âTODO?

            Use fun√ß√£o quando:

                a l√≥gica n√£o pertence ao objeto

                √© utilit√°ria

                pode ser reutilizada por v√°rias classes

            Exemplo:

                def validar_email(email):
                    return "@" in email

            N√£o faz sentido isso estar dentro de Usuario.

        CLASSES USANDO FUN√á√ïES (delega√ß√£o):

            Classe pode chamar fun√ß√µes externas tranquilamente.

            EX:

                def calcular_imposto(valor):
                    return valor * 0.15


                class Produto:
                    def __init__(self, preco):
                        self.preco = preco

                    def preco_final(self):
                        return self.preco + calcular_imposto(self.preco)

            - A classe n√£o precisa saber como o imposto funciona ‚Äî s√≥ usa.

            Isso √©:

                baixo acoplamento

                c√≥digo mais limpo

                mais f√°cil de testar

        FUN√á√ÉO DENTRO DA CLASSE ‚â† M√âTODO DE INST√ÇNCIA

            Olha esse detalhe importante:

                class Exemplo:
                    def funcao(self):
                        print("Sou m√©todo")

            VS

                class Exemplo:
                    @staticmethod
                    def funcao():
                        print("Sou fun√ß√£o organizada na classe")

            Diferen√ßa:

                . M√©todo de inst√¢ncia ‚Üí usa self

                . Staticmethod ‚Üí √© s√≥ uma fun√ß√£o dentro da classe

        CLASSE COMO PAR√ÇMETRO DE FUN√á√ÉO

            Classe tamb√©m √© objeto em Python.

                class Pessoa:
                    pass


                def criar_instancia(classe):
                    return classe()

            Uso:

                p = criar_instancia(Pessoa)

            Isso √© base para:

                f√°bricas (factory)

                frameworks

                inje√ß√£o de depend√™ncia

        FUN√á√ïES QUE CRIAM OBJETOS:

            Muito usado em Python.

                class Usuario:
                    def __init__(self, nome):
                        self.nome = nome


                def criar_usuario(nome):
                    return Usuario(nome)

            - Em Python, nem sempre voc√™ precisa de factory class como em Java.

        QUANDO VIRAR M√âTODO?

            - Se a l√≥gica depende do estado do objeto ‚Üí m√©todo
            - Se a l√≥gica √© geral ‚Üí fun√ß√£o

            Compara√ß√£o clara:

                Ruim:

                    def sacar(conta, valor):
                        conta.saldo -= valor

                Bom:

                    class Conta:
                        def sacar(self, valor):
                            self.saldo -= valor

    ==========================================================================

    atributos e propriedades de classe:

        - Atributo √© uma informa√ß√£o associada a um objeto ou a uma classe

        Existem dois tipos principais:

            Atributo de inst√¢ncia

            Atributo de classe

        ATRIBUTOS DE INST√ÇNCIA:

            Pertencem a cada objeto

            Criados normalmente no __init__

            Cada objeto tem o seu

            EX:

                class Pessoa:
                    def __init__(self, nome):
                        self.nome = nome

            Uso:

                p1 = Pessoa("Renato")
                p2 = Pessoa("Ana")

                print(p1.nome)  # Renato
                print(p2.nome)  # Ana

            - self.nome vive dentro do objeto.

        ATRIBUTOS DE CLASSE:

            Pertencem √† classe

            S√£o compartilhados por todos os objetos

            EX:

                class Pessoa:
                    especie = "Humano"

            Uso:

                p1 = Pessoa()
                p2 = Pessoa()

                print(p1.especie)
                print(p2.especie)

            Ambos veem o mesmo valor.

            Regra importante:

                Pessoa.especie   # forma correta
                p1.especie       # s√≥ um atalho

            - O dono real √© a classe, n√£o o objeto.

        AGORA ENTRA A PARTE NOBRE: PROPRIEDADES (@property):

            O problema que a propriedade resolve:

                Imagine isso:

                    class Produto:
                        def __init__(self, preco):
                            self.preco = preco

                Algu√©m pode fazer:

                    p = Produto(-100)

                Pre√ßo negativo ‚Üí objeto inv√°lido.

            PROPRIEDADE = ATRIBUTO COM CONTROLE

                Voc√™ acessa como atributo,
                mas executa c√≥digo por tr√°s.

                Exemplo com @property:

                    class Produto:
                        def __init__(self, preco):
                            self._preco = preco

                        @property
                        def preco(self):
                            return self._preco

                Uso:

                    p = Produto(10)
                    print(p.preco)

                - Parece atributo, mas √© m√©todo.

            SETTER ‚Äî CONTROLANDO MODIFICA√á√ÉO:

                class Produto:
                    def __init__(self, preco):
                        self._preco = preco

                    @property
                    def preco(self):
                        return self._preco

                    @preco.setter
                    def preco(self, valor):
                        if valor < 0:
                            raise ValueError("Pre√ßo n√£o pode ser negativo")
                        self._preco = valor

                Uso:

                    p = Produto(10)
                    p.preco = 20      # ok
                    p.preco = -5      # erro

                - Encapsulamento real, sem quebrar a interface.

        POR QUE USAR _preco E N√ÉO __preco:

            _preco ‚Üí conven√ß√£o (uso interno) (IDEIA DE ATRIBUTO PROTEGIDO)

            __preco ‚Üí name mangling (mais r√≠gido) (IDEIA DE ATRIBUTO PRIVADO)

            - Em Python, _ √© o padr√£o mais usado.

    ==========================================================================

    Encapsulamento:

        Encapsulamento √© esconder a implementa√ß√£o interna e expor apenas o que 
        pode ser usado com seguran√ßa.

        Em portugu√™s direto:

            voc√™ protege o estado interno

            controla como os dados s√£o acessados

            evita uso errado do objeto

        Analogia perfeita:

            Voc√™ dirige um carro usando:

                volante

                pedais

            Voc√™ n√£o mexe diretamente:

                no motor

                nos pist√µes

                no sistema el√©trico

            Isso √© encapsulamento.

        POR QUE ENCAPSULAMENTO √â T√ÉO IMPORTANTE?

            Sem encapsulamento:

                qualquer parte do c√≥digo pode quebrar o objeto

                bugs silenciosos

                manuten√ß√£o dif√≠cil

            Com encapsulamento:

                regras centralizadas

                menos bugs

                c√≥digo previs√≠vel

                refatora√ß√£o segura

            Encapsulamento √© sobre seguran√ßa e clareza.

        COMO O PYTHON IMPLEMENTA ENCAPSULAMENTO?

            Aqui vem a parte que confunde muita gente

            Python n√£o usa private, protected, public como Java.

            Python usa:

                Conven√ß√µes
                Name mangling
                Propriedades (@property)

        ATRIBUTOS P√öBLICOS (SEM PROTE√á√ÉO):

            EX:

                class Pessoa:
                    def __init__(self, idade):
                        self.idade = idade

            Uso:

                p = Pessoa(20)
                p.idade = -50   # N√£o permitido

            Isso n√£o √© encapsulamento.

        ATRIBUTO ‚ÄúPROTEGIDO‚Äù (_atributo):

            - Conven√ß√£o mais usada em Python

                class Pessoa:
                    def __init__(self, idade):
                        self._idade = idade

            O _ significa:

                ‚ÄúIsso √© interno. Use com cuidado.‚Äù

            N√£o impede acesso, mas avisa.

                p._idade = -10  # tecnicamente poss√≠vel, mas errado

        ENCAPSULAMENTO REAL COM @property:

            Aqui come√ßa a POO de verdade em Python.

                class Pessoa:
                    def __init__(self, idade):
                        self._idade = idade

                    @property
                    def idade(self):
                        return self._idade

                    @idade.setter
                    def idade(self, valor):
                        if valor < 0:
                            raise ValueError("Idade n√£o pode ser negativa")
                        self._idade = valor

                Uso:

                    p = Pessoa(20)
                    p.idade = 30     # ok
                    p.idade = -5     # erro
            
            Voc√™:

                protege o estado

                mant√©m interface simples

                evita acesso direto

        ATRIBUTO ‚ÄúPRIVADO‚Äù (__atributo) ‚Äî NAME MANGLING:

            EX:

                class Pessoa:
                    def __init__(self, idade):
                        self.__idade = idade

            Internamente, Python transforma em:

                _Pessoa__idade

            Isso √© chamado name mangling.

            Acesso direto N√ÉO funciona:

                p.__idade  # AttributeError

            Mas ainda √© poss√≠vel (n√£o recomendado):

                p._Pessoa__idade

            - __ n√£o √© seguran√ßa absoluta, √© prote√ß√£o contra uso acidental.

        _ vs __ ‚Äî QUAL USAR?

            | Situa√ß√£o                  | Use          |
            | ------------------------- | ------------ |
            | Uso interno comum         | `_atributo`  |
            | Evitar colis√£o em heran√ßa | `__atributo` |
            | API p√∫blica               | sem `_`      |

        ENCAPSULAMENTO N√ÉO √â ‚ÄúESCONDER TUDO‚Äù:

            Erro comum:

                ‚ÄúVou deixar tudo privado‚Äù

            Isso vira c√≥digo:

                r√≠gido

                chato de usar

                cheio de getters in√∫teis

            Encapsulamento bom:

                esconde o que pode quebrar

                exp√µe o que faz sentido

        EXEMPLO REALISTA (ANTES vs DEPOIS):

            . Sem encapsulamento

                class Conta:
                    def __init__(self, saldo):
                        self.saldo = saldo

            . Com encapsulamento

                class Conta:
                    def __init__(self, saldo):
                        self._saldo = saldo

                    @property
                    def saldo(self):
                        return self._saldo

                    def sacar(self, valor):
                        if valor > self._saldo:
                            raise ValueError("Saldo insuficiente")
                        self._saldo -= valor

            - Agora ningu√©m ‚Äúfura‚Äù regra.

    ==========================================================================

    atributos privados, protegidos e p√∫blicos:

        PRIMEIRO: PYTHON N√ÉO TEM public / protected / private FORMAIS:

            Isso √© fundamental entender logo de cara.

            Python n√£o implementa controle de acesso r√≠gido como Java ou C++.

            O que existe em Python √©:

                conven√ß√£o

                sinaliza√ß√£o de inten√ß√£o

                prote√ß√£o contra uso acidental

                n√£o contra ataque deliberado

            Encapsulamento em Python √© social, n√£o policial.

        ATRIBUTOS P√öBLICOS:

            Sem _

            Parte da API oficial da classe

            Podem ser usados livremente

            EX:

                class Pessoa:
                    def __init__(self, nome):
                        self.nome = nome

            Uso:

                p = Pessoa("Renato")
                p.nome = "Ana"

            Quando usar?

                Dados simples

                Sem regra

                Sem impacto cr√≠tico

            - Atributo p√∫blico √© um contrato

            Se voc√™ mudar depois, quebra c√≥digo de quem usa.

        ATRIBUTOS PROTEGIDOS (_atributo):

            - O MAIS USADO EM PYTHON

                class Pessoa:
                    def __init__(self, idade):
                        self._idade = idade

            O _ significa:

                ‚ÄúIsso √© interno. Voc√™ pode usar, mas n√£o deveria.‚Äù

                Python n√£o bloqueia:

                    p._idade = -10  # poss√≠vel, mas errado

            Por que isso existe ent√£o?

                Comunica√ß√£o entre desenvolvedores

                Leitura de c√≥digo clara

                Base para @property

                Compatibilidade com heran√ßa

            - _ √© design, n√£o seguran√ßa.

        ATRIBUTOS PRIVADOS (__atributo) ‚Äî NAME MANGLING:

            Aqui come√ßa a confus√£o.

                class Pessoa:
                    def __init__(self, idade):
                        self.__idade = idade

            Python transforma isso internamente em:

                _Pessoa__idade

            Isso √© name mangling.

            O que o name mangling faz?

                Evita colis√£o de nomes em heran√ßa

                Dificulta acesso acidental

                N√ÉO √© criptografia

            Acesso direto falha:

                p.__idade  # AttributeError

            Mas ainda existe:

                p._Pessoa__idade  # funciona, mas n√£o use isso de forma alguma

            Isso prova:

                __ n√£o √© privado de verdade, √© ‚Äúquase privado‚Äù.

            ENT√ÉO POR QUE __ EXISTE?

                Principal motivo real: EVITAR CONFLITO EM HERAN√áA

                    class A:
                        def __init__(self):
                            self.__valor = 10

                    class B(A):
                        def __init__(self):
                            super().__init__()
                            self.__valor = 20

                Aqui:

                    A.__valor ‚Üí _A__valor

                    B.__valor ‚Üí _B__valor

                . N√£o colidem.
                . Cada classe protege seu estado interno.

        _ vs __ ‚Äî REGRA PROFISSIONAL:

            | Caso                       | Use                    |
            | -------------------------- | ---------------------- |
            | Uso interno normal         | `_atributo`            |
            | Base para `@property`      | `_atributo`            |
            | C√≥digo OO comum            | `_atributo`            |
            | Evitar conflito em heran√ßa | `__atributo`           |
            | ‚ÄúEsconder‚Äù dado cr√≠tico    | `_atributo + property` |

        O MAIOR ERRO: ACHAR QUE __ √â ‚ÄúBOA PR√ÅTICA SEMPRE‚Äù:

            Errado:

                class Usuario:
                    def __init__(self):
                        self.__nome = "Renato"
                        self.__email = "x@y.com"
                        self.__idade = 30

            Isso causa:

                c√≥digo r√≠gido

                heran√ßa dif√≠cil

                testes mais chatos

                manuten√ß√£o pior

            Python n√£o foi feito para isso.

        ENCAPSULAMENTO CERTO EM PYTHON (PADR√ÉO REAL):

            O padr√£o mais usado na pr√°tica:

                class Produto:
                    def __init__(self, preco):
                        self._preco = preco

                    @property
                    def preco(self):
                        return self._preco

                    @preco.setter
                    def preco(self, valor):
                        if valor < 0:
                            raise ValueError("Pre√ßo inv√°lido")
                        self._preco = valor

            . Protege
            . Claro
            . Pythonic
            . F√°cil de manter

        REGRA DE OURO DEFINITIVA:

            P√∫blico:
            - faz parte da API
            - compromisso com o usu√°rio

            Protegido (_):
            - uso interno
            - padr√£o Python

            Privado (__):
            - evite conflito em heran√ßa
            - uso raro

    ==========================================================================

    m√©todos privados, protegidos e p√∫blicos:

        PRIMEIRO: M√âTODOS SEGUEM A MESMA L√ìGICA DOS ATRIBUTOS

            Em Python, n√£o existe palavra-chave para controle de acesso de 
            m√©todos.

            O que existe √©:

                conven√ß√£o

                inten√ß√£o

                encapsulamento por design

            Exatamente igual aos atributos.

        M√âTODOS P√öBLICOS:

            Sem _

            Parte da API oficial da classe

            Feitos para serem chamados de fora

            EX:

                class Conta:
                    def sacar(self, valor):
                        print(f"Sacando {valor}")

            Uso:

                c = Conta()
                c.sacar(100)

            Quando usar?

                a√ß√µes principais do objeto

                comportamento que o usu√°rio pode chamar

            M√©todo p√∫blico = contrato

                Se voc√™ mudar a assinatura, quebra c√≥digo externo.

        M√âTODOS PROTEGIDOS (_metodo):

            - O MAIS USADO EM PYTHON

                class Conta:
                    def sacar(self, valor):
                        if self._saldo_suficiente(valor):
                            self._debitar(valor)

                    def _saldo_suficiente(self, valor):
                        return True

                    def _debitar(self, valor):
                        print("Debitado")

            O _ significa:

                ‚ÄúM√©todo interno.
                Use apenas dentro da classe ou subclasses.‚Äù

            Python n√£o impede:

                c._debitar(50)  # tecnicamente poss√≠vel, mas errado

            - O _ √© aviso, n√£o trava.

            POR QUE M√âTODOS PROTEGIDOS S√ÉO IMPORTANTES?

                Eles permitem:

                    dividir l√≥gica complexa

                    esconder detalhes

                    facilitar manuten√ß√£o

                    permitir extens√£o por heran√ßa

                C√≥digo fica leg√≠vel sem expor implementa√ß√£o.

        M√âTODOS PRIVADOS (__metodo) ‚Äî NAME MANGLING:

            EX:

                class Cofre:
                    def abrir(self):
                        self.__verificar_senha()

                    def __verificar_senha(self):
                        print("Senha verificada")
            
            Uso:

                c = Cofre()
                c.abrir()

            Tentativa direta:

                c.__verificar_senha()  # AttributeError

            Internamente:

                _Cofre__verificar_senha

            PARA QUE SERVE M√âTODO PRIVADO DE VERDADE?

                - Evitar colis√£o em heran√ßa, n√£o esconder de usu√°rio malicioso.

                Exemplo cl√°ssico:

                    class A:
                        def __processar(self):
                            print("A")

                    class B(A):
                        def __processar(self):
                            print("B")

                Aqui:

                    _A__processar

                    _B__processar

                - N√£o entram em conflito.

        ERRO COMUM: USAR __ EM TUDO:

            M√° pr√°tica:

                class Usuario:
                    def __validar_email(self): ...
                    def __gerar_token(self): ...
                    def __logar(self): ...

            Problemas:

                heran√ßa quebrada

                testes dif√≠ceis

                manuten√ß√£o pior

                c√≥digo r√≠gido

            Python n√£o foi feito para isso.

        PADR√ÉO PYTHONIC (O QUE SE USA NA VIDA REAL):

            O padr√£o mais usado √©:

                m√©todos p√∫blicos ‚Üí interface

                m√©todos protegidos (_) ‚Üí implementa√ß√£o

                m√©todos privados (__) ‚Üí casos raros (heran√ßa)

            Exemplo profissional:

                class Pedido:
                    def finalizar(self):
                        self._calcular_total()
                        self._registrar()

                    def _calcular_total(self):
                        print("Total calculado")

                    def _registrar(self):
                        print("Pedido registrado")

            . Limpo
            . Claro
            . Seguro
            . Extens√≠vel

        M√âTODOS PRIVADOS + @property:

            Muito comum:

                class Produto:
                    def __init__(self, preco):
                        self._preco = preco

                    @property
                    def preco(self):
                        return self._preco

                    def _validar_preco(self, valor):
                        if valor < 0:
                            raise ValueError("Pre√ßo inv√°lido")

                    @preco.setter
                    def preco(self, valor):
                        self._validar_preco(valor)
                        self._preco = valor

            O m√©todo protegido organiza a regra.

        REGRA DE OURO DEFINITIVA (GUARDA ISSO)

            M√©todo p√∫blico:
            - API
            - usado de fora

            M√©todo protegido (_):
            - implementa√ß√£o
            - padr√£o Python

            M√©todo privado (__):
            - evitar conflito em heran√ßa
            - uso raro

    ==========================================================================

    m√©todos get e setter e property (mais afundo):

        PROBLEMA QUE GET / SET TENTAM RESOLVER:

            Sem encapsulamento:

                class Produto:
                    def __init__(self, preco):
                        self.preco = preco

            Problemas:

                qualquer valor entra

                regras espalhadas

                objeto pode ficar inv√°lido

                EX:

                    p = Produto(-100)

            Getter/Setter existem para proteger o estado interno.

        GET E SET ‚ÄúCL√ÅSSICOS‚Äù:

            Como seria:

                class Produto:
                    def __init__(self, preco):
                        self._preco = preco

                    def get_preco(self):
                        return self._preco

                    def set_preco(self, valor):
                        if valor < 0:
                            raise ValueError("Pre√ßo inv√°lido")
                        self._preco = valor

            Uso:

                p = Produto(10)
                p.set_preco(20)
                print(p.get_preco())

            Por que isso √© ruim em Python?

                verboso

                quebra a ideia de atributo

                c√≥digo feio para quem l√™ Python

            - Isso √© aceit√°vel, mas n√£o √© pythonic.

        O CONCEITO-CHAVE DO @property:

            - @property permite acessar m√©todo COMO SE FOSSE atributo

            Voc√™ escreve:

                p.preco

            Mas o Python executa:

                Produto.preco(p)

            Interface limpa + controle interno.

        GETTER COM @property (FORMA CERTA):

            ex:

                class Produto:
                    def __init__(self, preco):
                        self._preco = preco

                    @property
                    def preco(self):
                        return self._preco

            Uso:

                p = Produto(10)
                print(p.preco)

            Importante:

                nome do m√©todo = nome do atributo p√∫blico

                _preco √© o dado real

        SETTER COM @<property>.setter:

            EX:

                class Produto:
                    def __init__(self, preco):
                        self._preco = preco

                    @property
                    def preco(self):
                        return self._preco

                    @preco.setter
                    def preco(self, valor):
                        if valor < 0:
                            raise ValueError("Pre√ßo inv√°lido")
                        self._preco = valor

            Uso:

                p = Produto(10)
                p.preco = 20     # chama setter
                p.preco = -5     # erro

            Visualmente √© atributo, semanticamente √© m√©todo.

        O ERRO N¬∫ 1 COM @property

            Fazer isso:

                class Produto:
                    @property
                    def preco(self):
                        return self.preco   # recurs√£o infinita

            Sempre use atributo interno (_preco).

        PROPERTY SOMENTE LEITURA:

            - Encapsulamento forte sem setter:

                class Conta:
                    def __init__(self, saldo):
                        self._saldo = saldo

                    @property
                    def saldo(self):
                        return self._saldo

            Uso:

                c = Conta(100)
                c.saldo = 200  # AttributeError

            Muito usado para:

                IDs

                status

                valores calculados

        PROPERTY CALCULADA (N√ÉO EXISTE ATRIBUTO REAL):

            EX:

                class Retangulo:
                    def __init__(self, largura, altura):
                        self.largura = largura
                        self.altura = altura

                    @property
                    def area(self):
                        return self.largura * self.altura

            Uso:

                r = Retangulo(10, 5)
                print(r.area)

            area:

                n√£o √© armazenada

                √© sempre consistente

                n√£o pode ser ‚Äúsetada‚Äù

        PROPERTY + M√âTODOS PROTEGIDOS (PADR√ÉO PROFISSIONAL):

            class Usuario:
                def __init__(self, email):
                    self._email = email

                @property
                def email(self):
                    return self._email

                def _validar_email(self, valor):
                    if "@" not in valor:
                        raise ValueError("Email inv√°lido")

                @email.setter
                def email(self, valor):
                    self._validar_email(valor)
                    self._email = valor

        PROPERTY vs M√âTODO ‚Äî QUANDO USAR CADA UM?

            | Situa√ß√£o        | Use         |
            | --------------- | ----------- |
            | Leitura simples | `@property` |
            | Valor derivado  | `@property` |
            | Regra simples   | `@property` |
            | A√ß√£o / comando  | m√©todo      |
            | Opera√ß√£o pesada | m√©todo      |

        PROPERTY N√ÉO √â CAMUFLAGEM!

            Erro conceitual comum:

                ‚ÄúVou usar property pra esconder tudo‚Äù

            Use @property quando:

                conceitualmente √© um atributo

                n√£o quando √© uma a√ß√£o

        REGRA DE OURO DEFINITIVA:

            Dado interno ‚Üí _atributo
            Interface p√∫blica ‚Üí property
            Regra ‚Üí setter ou m√©todo protegido
            Nunca exponha estado cr√≠tico direto

    ==========================================================================

    Composi√ß√£o, heran√ßa (simples e m√∫ltipla) e delega√ß√£o:

        COMPOSI√á√ÉO:

            - Composi√ß√£o √© quando um objeto TEM outro objeto.

            . Rela√ß√£o ‚Äútem um‚Äù, n√£o ‚Äú√© um‚Äù.

            Exemplo do mundo real:

                Carro tem um motor

                Carro n√£o √© um motor

            Exemplo em Python:

                class Motor:
                    def ligar(self):
                        print("Motor ligado")


                class Carro:
                    def __init__(self):
                        self.motor = Motor()   # composi√ß√£o

                    def ligar(self):
                        self.motor.ligar()

            Uso:

                c = Carro()
                c.ligar()

            - Carro usa Motor, mas n√£o herda dele.

            Por que composi√ß√£o √© t√£o valorizada?

                baixo acoplamento

                f√°cil de trocar componentes

                heran√ßa n√£o explode

                c√≥digo mais flex√≠vel

            Regra de ouro da POO moderna:

                Prefira composi√ß√£o a heran√ßa.

        CLASSE PAI E CLASSE FILHA:

            - classe pai (base / superclasse)

                - define comportamento gen√©rico

            - Classe filha (subclasse)

                - especializa ou altera esse comportamento

            Rela√ß√£o ‚Äú√© um‚Äù.

            Exemplo simples:

                class Animal:          # classe pai
                    def falar(self):
                        print("Som gen√©rico")


                class Cachorro(Animal):   # classe filha
                    pass

        HERAN√áA SIMPLES ‚Äî ‚Äú√â UM‚Äù:

            - Heran√ßa √© quando uma classe √© uma especializa√ß√£o de outra.

            Rela√ß√£o ‚Äú√© um‚Äù.

            Exemplo correto:

                class Animal:
                    def falar(self):
                        print("Som gen√©rico")


                class Cachorro(Animal):
                    def falar(self):
                        print("Au au")

            Uso:

                a = Cachorro()
                a.falar()

            - Cachorro √© um Animal

            super() ‚Äî ponto cr√≠tico:

                EX:

                    class Funcionario:
                        def __init__(self, nome):
                            self.nome = nome


                    class Gerente(Funcionario):
                        def __init__(self, nome, bonus):
                            super().__init__(nome)
                            self.bonus = bonus

                - super() chama a implementa√ß√£o da classe pai.

        PROBLEMAS REAIS DA HERAN√áA:

            Heran√ßa mal usada gera:

                classes gigantes

                hierarquias profundas

                depend√™ncia forte

                c√≥digo fr√°gil

            Exemplo ruim:

                class Animal:
                    def voar(self): ...
                    def nadar(self): ...
                    def correr(self): ...

            - Nem todo animal faz tudo.

        HERAN√áA M√öLTIPLA ‚Äî PODEROSA E PERIGOSA:

            Python permite, mas exige maturidade.

                class PodeVoar:
                    def mover(self):
                        print("Voando")


                class PodeNadar:
                    def mover(self):
                        print("Nadando")


                class Pato(PodeVoar, PodeNadar):
                    pass

            Uso:

                p = Pato()
                p.mover()

            Qual m√©todo foi chamado?

                MRO ‚Äî Method Resolution Order

                Python segue a ordem:

                    Pato ‚Üí PodeVoar ‚Üí PodeNadar ‚Üí object

                Verificando o MRO:

                    print(Pato.mro())

                - Heran√ßa m√∫ltipla sem entender MRO = desastre.

        MIXINS ‚Äî O √öNICO USO SEGURO DE HERAN√áA M√öLTIPLA:

            Classe pequena, focada, sem estado, que adiciona comportamento.

            EX:

                class LogMixin:
                    def log(self, msg):
                        print(f"[LOG] {msg}")


                class Servico(LogMixin):
                    def executar(self):
                        self.log("Executando servi√ßo")

            Mixin:

                n√£o representa ‚Äú√© um‚Äù

                s√≥ adiciona habilidade

        HERAN√áA AUTOM√ÅTICA DE M√âTODOS:

            A classe filha herda tudo que n√£o redefinir.

                c = Cachorro()
                c.falar()   # vem da classe pai

            - Nenhum c√≥digo duplicado.
            - Isso √© reaproveitamento por heran√ßa.

        SOBRESCRITA (OVERRIDE) DE M√âTODOS:

            - Criar um m√©todo com o mesmo nome do m√©todo da classe pai.

            ex:

                class Cachorro(Animal):
                    def falar(self):
                        print("Au au")

            Uso:

                c = Cachorro()
                c.falar()   # "Au au"

            - Python chama o m√©todo da classe filha, n√£o o do pai.

            . ltima defini√ß√£o vence, seguindo o MRO.

        CLASSE FILHA PODE USAR M√âTODO DO PAI SEM super()?

            SIM. Totalmente poss√≠vel.

                class Cachorro(Animal):
                    def falar(self):
                        Animal.falar(self)
                        print("Au au")

            Aqui voc√™:

                chama explicitamente o m√©todo da classe pai

                passa self manualmente

            Isso FUNCIONA, mas n√£o √© o ideal.

        ENT√ÉO POR QUE EXISTE super():

            super() √© um proxy inteligente que chama o pr√≥ximo m√©todo na ordem 
            de resolu√ß√£o de m√©todos (MRO).

            Forma moderna (Python 3):

                class Cachorro(Animal):
                    def falar(self):
                        super().falar()
                        print("Au au")

            O Python decide qual classe chamar, n√£o voc√™.

        DIFEREN√áA CR√çTICA: super() vs chamada direta:

            Chamada direta (fr√°gil):

                Animal.falar(self)

            Problemas:

                quebra heran√ßa m√∫ltipla

                ignora MRO

                acoplamento forte

                dif√≠cil de manter

            super() (robusto):

                super().falar()

            Vantagens:

                respeita MRO
                
                funciona com heran√ßa m√∫ltipla
                
                desacoplado
                
                extens√≠vel

            - super() n√£o significa ‚Äúclasse pai‚Äù, significa ‚Äúpr√≥ximo da cadeia‚Äù.

        super() NO __init__ (CASO MAIS COMUM):

            EX:

                class Funcionario:
                    def __init__(self, nome):
                        self.nome = nome


                class Gerente(Funcionario):
                    def __init__(self, nome, bonus):
                        super().__init__(nome)
                        self.bonus = bonus

            Sem super():

                o __init__ do pai n√£o roda

                atributos podem faltar

                objeto nasce incompleto

        REAPROVEITAR SEM SOBRESCREVER:

            Se a classe filha n√£o precisa mudar nada, n√£o sobrescreva.

                class Gato(Animal):
                    pass

            . Menos c√≥digo
            . Menos bugs
            . Heran√ßa limpa

        SOBRESCRITA PARCIAL (PADR√ÉO PROFISSIONAL):

            Voc√™ reaproveita parte do comportamento e estende:

                class Servico:
                    def executar(self):
                        print("Executando servi√ßo base")


                class ServicoComLog(Servico):
                    def executar(self):
                        print("Iniciando log")
                        super().executar()
                        print("Finalizando log")

            Isso √© template method informal.

        HERAN√áA M√öLTIPLA E super() (MUITO IMPORTANTE):

            EX:

                class A:
                    def acao(self):
                        print("A")


                class B(A):
                    def acao(self):
                        print("B")
                        super().acao()


                class C(A):
                    def acao(self):
                        print("C")
                        super().acao()


                class D(B, C):
                    def acao(self):
                        print("D")
                        super().acao()

            Uso:

                d = D()
                d.acao()

            Sa√≠da:

                D
                B
                C
                A

            Isso s√≥ funciona porque todos usam super().

            Ver o MRO:

                print(D.mro())

            Sa√≠da:
                
                [D, B, C, A, object]

            - super() segue essa ordem, n√£o ‚Äúpai direto‚Äù.

        REGRA PROFISSIONAL FINAL SOBRE HERAN√áA:

            Classe pai:
            - define comportamento gen√©rico

            Classe filha:
            - especializa, n√£o bagun√ßa

            Reaproveitar:
            - n√£o sobrescreva se n√£o precisa

            Sobrescrever:
            - use super() sempre que poss√≠vel


        DELEGA√á√ÉO ‚Äî COMPOSI√á√ÉO + ENCAPSULAMENTO:

            Delega√ß√£o √© quando um objeto passa a responsabilidade para outro.

            Exemplo claro:

                class Impressora:
                    def imprimir(self, texto):
                        print(texto)


                class Relatorio:
                    def __init__(self):
                        self._impressora = Impressora()

                    def imprimir(self):
                        self._impressora.imprimir("Relat√≥rio pronto")

            - Relatorio n√£o sabe imprimir, ele delega.

        COMPARA√á√ÉO DIRETA (ESSENCIAL):

            | Conceito         | Rela√ß√£o        | Use quando                |
            | ---------------- | -------------- | ------------------------- |
            | Composi√ß√£o       | tem um         | padr√£o principal          |
            | Heran√ßa          | √© um           | especializa√ß√£o real       |
            | Heran√ßa m√∫ltipla | √© v√°rios       | mixins                    |
            | Delega√ß√£o        | passa a tarefa | separar responsabilidades |

        REGRA DE OURO PROFISSIONAL:

            Comece com composi√ß√£o
            Use delega√ß√£o naturalmente
            Use heran√ßa s√≥ quando for "√© um"
            Heran√ßa m√∫ltipla s√≥ com mixins

        ERRO MAIS COMUM DE INICIANTE:

            Usar heran√ßa para reaproveitar c√≥digo

            Criar hierarquia profunda

            Classe ‚ÄúDeus‚Äù (faz tudo)

            Achar que super() chama sempre o pai direto

            Esquecer super().__init__()

            Chamar m√©todo do pai diretamente em heran√ßa m√∫ltipla

            Sobrescrever m√©todo sem necessidade

            . Reaproveitamento ‚â† heran√ßa

            . Reaproveitamento = composi√ß√£o

    ==========================================================================

    Polimorfismo:

        Polimorfismo √© a capacidade de objetos diferentes responderem ao MESMO 
        m√©todo de formas diferentes.

        - Mesmo nome.

        - Comportamentos distintos.

        Exemplo do mundo real:

            Bot√£o ‚ÄúPlay‚Äù:

                Spotify ‚Üí toca m√∫sica

                YouTube ‚Üí toca v√≠deo

                DVD ‚Üí toca filme

            A a√ß√£o √© a mesma, a execu√ß√£o muda.

        POLIMORFISMO POR HERAN√áA (O MAIS CL√ÅSSICO):

            EX:

                class Animal:
                    def falar(self):
                        print("Som gen√©rico")


                class Cachorro(Animal):
                    def falar(self):
                        print("Au au")


                class Gato(Animal):
                    def falar(self):
                        print("Miau")

            Uso:

                animais = [Cachorro(), Gato()]

                for animal in animais:
                    animal.falar()

            Sa√≠da:

                Au au
                Miau

            . Mesmo m√©todo (falar)
            . Objetos diferentes
            . Comportamento diferente

        A CHAVE DO POLIMORFISMO:

            Repara nisso:

                animal.falar()

            O c√≥digo n√£o sabe se √© cachorro ou gato.
            
            E n√£o precisa saber.

            - Isso √© desacoplamento.
            - Isso √© design bom.

        POLIMORFISMO SEM HERAN√áA (DUCK TYPING):

            Agora vem o ponto onde Python brilha.

            Conceito:

                ‚ÄúSe anda como pato e faz quack como pato,
                ent√£o √© um pato.‚Äù

            Python n√£o liga para o tipo, liga para o comportamento.

            Exemplo:

                class Arquivo:
                    def abrir(self):
                        print("Abrindo arquivo")


                class Conexao:
                    def abrir(self):
                        print("Abrindo conex√£o")


            Fun√ß√£o polim√≥rfica:

                def iniciar(recurso):
                    recurso.abrir()

            Uso:

                iniciar(Arquivo())
                iniciar(Conexao())

            . Nenhuma heran√ßa
            . Nenhuma interface
            . Polimorfismo puro

        POR QUE ISSO √â T√ÉO IMPORTANTE EM PYTHON?

            Porque:

                reduz acoplamento

                evita hierarquias gigantes

                favorece composi√ß√£o

                deixa o c√≥digo flex√≠vel

            Duck typing √© polimorfismo din√¢mico.

        POLIMORFISMO COM FUN√á√ïES BUILT-IN

            Python j√° usa isso o tempo todo:

                len("Renato")
                len([1, 2, 3])
                len({"a": 1})

            Objetos diferentes

            Mesmo comportamento (__len__)

            - Polimorfismo por protocolo.

        POLIMORFISMO COM M√âTODOS M√ÅGICOS:

            EX:

                class Produto:
                    def __str__(self):
                        return "Produto"


                class Pedido:
                    def __str__(self):
                        return "Pedido"

            Uso:

                print(Produto())
                print(Pedido())

            - print() n√£o sabe o tipo
            - Chama __str__ de cada objeto

        POLIMORFISMO COM HERAN√áA + super():

            EX:

                class Forma:
                    def area(self):
                        raise NotImplementedError


                class Retangulo(Forma):
                    def area(self):
                        return 10 * 5


                class Circulo(Forma):
                    def area(self):
                        return 3.14 * 2 * 2

            Uso:

                formas = [Retangulo(), Circulo()]

                for f in formas:
                    print(f.area())

            - Interface comum
            - Implementa√ß√µes diferentes

        POLIMORFISMO COM ABC (INTERFACES EM PYTHON):

            Quando voc√™ quer garantir contrato, use ABC.

                from abc import ABC, abstractmethod

                class Pagamento(ABC):
                    @abstractmethod
                    def pagar(self):
                        pass

            Implementa√ß√µes:

                class Cartao(Pagamento):
                    def pagar(self):
                        print("Pago com cart√£o")


                class Pix(Pagamento):
                    def pagar(self):
                        print("Pago com PIX")

            Uso:

                pagamentos = [Cartao(), Pix()]

                for p in pagamentos:
                    p.pagar()

            - Polimorfismo + seguran√ßa de contrato.

        POLIMORFISMO N√ÉO √â if isinstance:

            Ruim:

                if isinstance(x, Cachorro):
                    ...
                elif isinstance(x, Gato):
                    ...

            Bom:

                x.falar()

            Se voc√™ precisa de isinstance, provavelmente n√£o usou polimorfismo 
            direito.

        POLIMORFISMO + COMPOSI√á√ÉO (N√çVEL PROFISSIONAL):

            EX:

                class EmailNotificador:
                    def enviar(self):
                        print("Email enviado")


                class SmsNotificador:
                    def enviar(self):
                        print("SMS enviado")


                class Sistema:
                    def __init__(self, notificador):
                        self.notificador = notificador

                    def alertar(self):
                        self.notificador.enviar()

            Uso:

                Sistema(EmailNotificador()).alertar()
                Sistema(SmsNotificador()).alertar()

            . Nenhuma heran√ßa
            . Polimorfismo total
            . Arquitetura limpa

        REGRA DE OURO DO POLIMORFISMO:

            C√≥digo deve depender do comportamento, n√£o do tipo concreto.

    ==========================================================================

    Sub-tipagem:

        Sub-tipagem √© quando um tipo pode ser substitu√≠do por outro sem quebrar 
        o comportamento esperado do programa.

        Ou seja:

            se B √© subtipo de A

            ent√£o B pode ser usado onde A √© esperado

            sem causar erro l√≥gico

        Forma curta (pra guardar):

            Se funciona com o pai, deve funcionar com o filho.

        SUB-TIPAGEM ‚â† HERAN√áA (ISSO √â CRUCIAL)

            Erro comum:

                ‚ÄúSe herda, √© subtipo‚Äù

            N√ÉO NECESSARIAMENTE.

                Heran√ßa:

                    . √© mecanismo sint√°tico

                Sub-tipagem:

                    . √© rela√ß√£o sem√¢ntica (de significado)

                - Toda sub-tipagem pode usar heran√ßa
                - Mas nem toda heran√ßa gera uma boa sub-tipagem

        EXEMPLO DE BOA SUB-TIPAGEM:

            EX:
                class Animal:
                    def falar(self):
                        print("Som gen√©rico")


                class Cachorro(Animal):
                    def falar(self):
                        print("Au au")

            Uso:

                def fazer_animal_falar(animal: Animal):
                    animal.falar()

            Funciona com:

                fazer_animal_falar(Animal())
                fazer_animal_falar(Cachorro())

            . Substitui√ß√£o segura
            . Polimorfismo correto
            . Sub-tipagem v√°lida

        EXEMPLO DE SUB-TIPAGEM QUEBRA (HERAN√áA ERRADA):

            Cl√°ssico erro OO:

                class Retangulo:
                    def set_largura(self, l):
                        self.largura = l

                    def set_altura(self, a):
                        self.altura = a

                    def area(self):
                        return self.largura * self.altura

            Agora:

                class Quadrado(Retangulo):
                    def set_largura(self, l):
                        self.largura = l
                        self.altura = l

                    def set_altura(self, a):
                        self.altura = a
                        self.largura = a

            Teste:

                def calcular_area(r: Retangulo):
                    r.set_largura(10)
                    r.set_altura(5)
                    return r.area()

            Resultado:

                Ret√¢ngulo ‚Üí 50

                Quadrado ‚Üí 25

            Heran√ßa existe, mas sub-tipagem quebrou.

            POR QUE ISSO QUEBRA?

                Porque o contrato impl√≠cito foi violado.

                O contrato do pai dizia:

                    largura e altura s√£o independentes

                O filho mudou isso.

                Quebrou expectativa do c√≥digo cliente.

        SUB-TIPAGEM E PRINC√çPIO DE LISKOV (LSP)

            Sub-tipagem correta segue:

                Princ√≠pio da Substitui√ß√£o de Liskov

            Em termos pr√°ticos:

                - N√£o exigir mais do que o pai
                - N√£o entregar menos do que o pai
                - N√£o mudar o significado dos m√©todos

        FORMAS DE SUB-TIPAGEM EM PYTHON

            Python aceita tr√™s grandes formas:

                1. Sub-tipagem nominal (heran√ßa)

                    EX:

                        class A:
                            pass

                        class B(A):
                            pass

                    - Baseada em heran√ßa expl√≠cita

                2. Sub-tipagem estrutural (duck typing)

                    EX:

                        class Impressora:
                            def imprimir(self):
                                print("Imprimindo")

                        def usar_impressora(obj):
                            obj.imprimir()

                    Qualquer objeto com imprimir() serve.

                    - Isso √© sub-tipagem sem heran√ßa.

                3. Sub-tipagem por contrato (ABC):

                    EX:

                        from abc import ABC, abstractmethod

                        class Pagamento(ABC):
                            @abstractmethod
                            def pagar(self):
                                pass

                    Implementa√ß√µes:

                        class Pix(Pagamento):
                            def pagar(self):
                                print("PIX")

                    . Sub-tipagem expl√≠cita
                    . Contrato garantido

        SUB-TIPAGEM + COMPOSI√á√ÉO (DESIGN MADURO):

            ex:

                class Email:
                    def enviar(self):
                        print("Email enviado")


                class SMS:
                    def enviar(self):
                        print("SMS enviado")


                class Sistema:
                    def __init__(self, canal):
                        self.canal = canal

                    def notificar(self):
                        self.canal.enviar()

            - Sistema depende do comportamento, n√£o do tipo.

            Isso √©:

                sub-tipagem estrutural

                polimorfismo

                baixo acoplamento

        ERROS CL√ÅSSICOS COM SUB-TIPAGEM:

            . Heran√ßa s√≥ para reaproveitar c√≥digo
            . Subclasse restringir comportamento do pai
            . Mudar significado de m√©todo herdado
            . For√ßar isinstance

        REGRA DE OURO DA SUB-TIPAGEM:

            Se voc√™ precisa perguntar "que tipo √© esse?", sua sub-tipagem est√° 
            errada.

        QUANDO N√ÉO USAR HERAN√áA?

            Quando:

                o ‚Äú√© um‚Äù n√£o √© verdadeiro

                comportamento muda semanticamente

                invariantes do pai s√£o quebradas

            Use composi√ß√£o.

    ==========================================================================

    M√©todos de classe:

        - M√©todo de classe √© um m√©todo que pertence √† classe, n√£o ao objeto.

        Ele:

            recebe cls (a classe)

            N√ÉO recebe self

            opera sobre atributos da classe

            pode criar objetos da classe

        Sintaxe b√°sica:

            class Exemplo:
                @classmethod
                def metodo(cls):
                    print(cls)

        - cls √© a classe, assim como self √© o objeto.

        COMPARA√á√ÉO R√ÅPIDA (ESSENCIAL):

            | Tipo                | Recebe | Atua sobre      |
            | ------------------- | ------ | --------------- |
            | M√©todo de inst√¢ncia | `self` | objeto          |
            | M√©todo de classe    | `cls`  | classe          |
            | M√©todo est√°tico     | nada   | nada espec√≠fico |

            Se voc√™ entende essa tabela, j√° evita 80% dos erros.

        EXEMPLO CL√ÅSSICO: ATRIBUTO DE CLASSE

            C√≥d:

                class Usuario:
                    total = 0

                    def __init__(self, nome):
                        self.nome = nome
                        Usuario.total += 1

                    @classmethod
                    def total_usuarios(cls):
                        return cls.total

            Uso:

                u1 = Usuario("Ana")
                u2 = Usuario("Renato")

                print(Usuario.total_usuarios())

            O m√©todo:

                n√£o depende de um usu√°rio espec√≠fico

                depende da classe Usuario

        POR QUE N√ÉO USAR M√âTODO DE INST√ÇNCIA AQUI?

            Ruim:

                def total_usuarios(self):
                    return Usuario.total

            Problemas:

                self n√£o faz sentido

                sugere que o m√©todo depende do objeto

                design confuso

            Sem√¢ntica importa em POO.

        M√âTODO DE CLASSE COMO ‚ÄúCONSTRUTOR ALTERNATIVO‚Äù:

            Esse √© o uso mais elegante de @classmethod.

                class Pessoa:
                    def __init__(self, nome, idade):
                        self.nome = nome
                        self.idade = idade

                    @classmethod
                    def criar_crianca(cls, nome):
                        return cls(nome, 0)

            Uso:

                p = Pessoa.criar_crianca("Lucas")

            Note:

                n√£o chama Pessoa(...) diretamente

                chama cls(...)

                funciona em subclasses

        POR QUE USAR cls E N√ÉO O NOME DA CLASSE?

            EX:

                return cls(nome, 0)

            E n√£o:

                return Pessoa(nome, 0)

            Porque assim:

                class Funcionario(Pessoa):
                    pass

                f = Funcionario.criar_crianca("Jo√£o")

            Retorna um Funcionario, n√£o Pessoa.

            Isso √©:

                polimorfismo

                sub-tipagem correta

                design robusto

        M√âTODOS DE CLASSE VS FUN√á√ïES DE F√ÅBRICA

            Fun√ß√£o f√°brica:

                def criar_pessoa(nome):
                    return Pessoa(nome, 0)

            M√©todo de classe:

                @classmethod
                def criar_crianca(cls, nome):
                    return cls(nome, 0)

            - Prefira m√©todo de classe quando:

                . a l√≥gica pertence ao conceito da classe

                . voc√™ quer respeitar heran√ßa

        M√âTODOS DE CLASSE EM HERAN√áA

            EX:

                class Config:
                    versao = "1.0"

                    @classmethod
                    def info(cls):
                        return f"Vers√£o {cls.versao}"

            Subclasse:

                class ConfigDev(Config):
                    versao = "1.0-dev"

            Uso:

                print(Config.info())
                print(ConfigDev.info())

            - O m√©todo se adapta automaticamente √† subclasse.

        ERRO COMUM: CONFUNDIR COM @staticmethod:

            Errado:

                @staticmethod
                def total():
                    return Usuario.total

            Problemas:

                perde polimorfismo

                ignora heran√ßa

                design pobre

            - Use @staticmethod s√≥ quando n√£o precisa nem de classe nem de 
            objeto.

        M√âTODO DE CLASSE + ENCAPSULAMENTO:

            - Muito usado para alterar configura√ß√£o global:

                class Sistema:
                    _modo = "producao"

                    @classmethod
                    def mudar_modo(cls, modo):
                        cls._modo = modo

            . Centraliza regras
            . Evita espalhar estado global

        QUANDO USAR @classmethod? (REGRA DE OURO)

            Use m√©todo de classe quando:

                - O m√©todo depende da classe, n√£o do objeto
                - Atua sobre atributos de classe
                - Cria inst√¢ncias de forma alternativa
                - Deve funcionar bem em subclasses

        QUANDO N√ÉO USAR?

            Quando:

                mexe em dados do objeto

                representa uma a√ß√£o individual

                poderia ser fun√ß√£o externa simples

    ==========================================================================

    M√©todos abstratos:

        - M√©todo abstrato √© um m√©todo que N√ÉO tem implementa√ß√£o e OBRIGA as 
        subclasses a implementarem.

        Ou seja:

            a classe pai define o contrato

            as classes filhas implementam o comportamento

        √â promessa, n√£o execu√ß√£o.

        POR QUE M√âTODOS ABSTRATOS EXISTEM?

            Eles resolvem um problema cl√°ssico:

                Sem m√©todo abstrato:

                    voc√™ espera que a subclasse implemente algo

                    mas nada obriga

                    erro aparece s√≥ em runtime (ou pior: l√≥gico)

                Com m√©todo abstrato:

                    contrato expl√≠cito

                    erro aparece cedo

                    arquitetura segura

                M√©todo abstrato = contrato de comportamento.

        CLASSE ABSTRATA ‚â† CLASSE NORMAL:

            Para ter m√©todos abstratos, usamos ABC (Abstract Base Class).

                from abc import ABC, abstractmethod

            Classe abstrata b√°sica:

                from abc import ABC, abstractmethod

                class Animal(ABC):

                    @abstractmethod
                    def falar(self):
                        pass

            Aqui:

                Animal √© abstrata

                falar √© m√©todo abstrato

                n√£o pode ser instanciada

                EX:

                    Animal()  # TypeError

        IMPLEMENTANDO O M√âTODO ABSTRATO NA SUBCLASSE:

            EX:

                class Cachorro(Animal):
                    def falar(self):
                        print("Au au")

            Agora sim:

                c = Cachorro()
                c.falar()

            A subclasse cumpriu o contrato.

        O QUE ACONTECE SE N√ÉO IMPLEMENTAR?

            EX:

                class Gato(Animal):
                    pass

            SA√çDA:

                Gato()  # TypeError

            Erro:

                Can't instantiate abstract class Gato with abstract method falar

            Python protege a arquitetura.

        M√âTODO ABSTRATO N√ÉO √â ‚ÄúM√âTODO VAZIO‚Äù:

            Erro comum:

                class Animal:
                    def falar(self):
                        pass

            . Isso n√£o √© m√©todo abstrato.
            . N√£o obriga ningu√©m.

            @abstractmethod √© obrigat√≥rio.

        M√âTODOS ABSTRATOS COM IMPLEMENTA√á√ÉO (SIM, PODE!):

            Pouca gente sabe disso:

                class Servico(ABC):

                    @abstractmethod
                    def executar(self):
                        print("Log base")

            Subclasse:

                class ServicoEmail(Servico):
                    def executar(self):
                        super().executar()
                        print("Email enviado")

            O m√©todo:

                tem implementa√ß√£o base

                mas continua obrigat√≥rio

            Isso √© template method.

        M√âTODOS ABSTRATOS + POLIMORFISMO:

            EX:

                class Pagamento(ABC):
                    @abstractmethod
                    def pagar(self):
                        pass

            Implementa√ß√µes:

                class Pix(Pagamento):
                    def pagar(self):
                        print("Pagamento via PIX")


                class Cartao(Pagamento):
                    def pagar(self):
                        print("Pagamento via cart√£o")

            Uso:

                def processar_pagamento(pagamento: Pagamento):
                    pagamento.pagar()

            - C√≥digo n√£o conhece a implementa√ß√£o
            - S√≥ conhece o contrato

        M√âTODOS ABSTRATOS VS DUCK TYPING:

            Duck typing:

                - flex√≠vel
                . sem contrato expl√≠cito

            M√©todos abstratos:

                - contrato claro
                - erro cedo
                . mais formal

            Em sistemas grandes, ABC ganha.

        ABC N√ÉO √â HERAN√áA POR REAPROVEITAMENTO:

            Regra de ouro:

                Classe abstrata n√£o existe para reaproveitar c√≥digo, mas para 
                definir regras.

            Se voc√™ quer reaproveitar:

                use composi√ß√£o

                ou mixins

        M√âTODOS ABSTRATOS EM M√âTODOS DE CLASSE E EST√ÅTICOS:

            Sim, isso existe:

                class Repositorio(ABC):
                    @abstractmethod
                    def salvar(self, dado):
                        pass

                    @classmethod
                    @abstractmethod
                    def criar(cls):
                        pass

            A subclasse √© obrigada a implementar ambos.

        ERROS COMUNS:

            . Achar que pass cria m√©todo abstrato
            . Esquecer de herdar de ABC
            . Criar ABC s√≥ para reaproveitar c√≥digo
            . Usar abstractmethod em tudo

        QUANDO USAR M√âTODOS ABSTRATOS?

            - Existe um contrato claro
            - M√∫ltiplas implementa√ß√µes poss√≠veis
            - C√≥digo cliente n√£o deve conhecer detalhes
            - Arquitetura precisa ser protegida

            N√£o use quando:

                s√≥ existe uma implementa√ß√£o

                o comportamento n√£o varia

                o custo de complexidade n√£o compensa    

    ==========================================================================

    M√©todos est√°ticos:

        M√©todo est√°tico √© uma fun√ß√£o colocada dentro da classe que N√ÉO depende 
        nem do objeto (self) nem da classe (cls).

        Ele:

            n√£o recebe self

            n√£o recebe cls

            n√£o acessa atributos de inst√¢ncia

            n√£o acessa atributos de classe (diretamente)

        √â uma fun√ß√£o organizada dentro da classe.

        Sintaxe:

            class Matematica:
                @staticmethod
                def somar(a, b):
                    return a + b

        Uso:

            Matematica.somar(2, 3)

        COMPARA√á√ÉO CLARA (ESSENCIAL):

            | Tipo      | Recebe | Depende de |
            | --------- | ------ | ---------- |
            | Inst√¢ncia | `self` | objeto     |
            | Classe    | `cls`  | classe     |
            | Est√°tico  | nada   | nada       |

            Se voc√™ entende essa tabela, n√£o erra mais.

        POR QUE ISSO EXISTE?

            Porque √†s vezes voc√™ quer:

                l√≥gica relacionada ao conceito

                mas que n√£o pertence ao estado

                nem da inst√¢ncia nem da classe

            Organiza√ß√£o sem acoplamento.

        EXEMPLO BOM DE USO (UTILIT√ÅRIO L√ìGICO):

            EX:

                class ValidadorCPF:
                    @staticmethod
                    def validar(cpf):
                        return len(cpf) == 11

            Uso:

                ValidadorCPF.validar("12345678901")

            A valida√ß√£o:

                faz sentido perto do conceito ‚ÄúCPF‚Äù

                n√£o depende de objeto

                n√£o precisa de heran√ßa

        EXEMPLO RUIM (ANTI-PADR√ÉO)

            Errado:

                class Usuario:
                    @staticmethod
                    def login(usuario, senha):
                        ...

            Problema:

                isso deveria ser m√©todo de inst√¢ncia

                ou fun√ß√£o externa

                ou m√©todo de classe

            Staticmethod aqui esconde erro de design.

        M√âTODOS EST√ÅTICOS VS FUN√á√ïES NORMAIS:

            Fun√ß√£o normal:

                def calcular_desconto(valor):
                    return valor * 0.9

            M√©todo est√°tico:

                class Desconto:
                    @staticmethod
                    def calcular(valor):
                        return valor * 0.9

            Diferen√ßa N√ÉO √© t√©cnica, √© sem√¢ntica.

            Use m√©todo est√°tico quando:

                a fun√ß√£o pertence conceitualmente √† classe

                melhora leitura e organiza√ß√£o

        M√âTODO EST√ÅTICO EM HERAN√áA (CUIDADO!):

            EX:

                class A:
                    @staticmethod
                    def info():
                        return "A"


                class B(A):
                    pass

            Uso:

                B.info()

            . Funciona
            . Mas n√£o √© polim√≥rfico

            @staticmethod n√£o conhece cls, ent√£o:

                n√£o se adapta √† subclasse

                n√£o √© ideal para hierarquia OO

        STATICMETHOD VS CLASSMETHOD (REGRA DE OURO):

            Se precisa da classe ‚Üí classmethod
            Se n√£o precisa de nada ‚Üí staticmethod
            Se precisa do objeto ‚Üí m√©todo de inst√¢ncia

            ps: Nunca escolha pelo ‚Äúgosto‚Äù, escolha pelo acoplamento.

        USOS REAIS E LEG√çTIMOS:

            . valida√ß√µes
            . parsers
            . helpers conceituais
            . c√°lculos puros
            . convers√µes de formato

            Exemplo:

                class Conversor:
                    @staticmethod
                    def celsius_para_fahrenheit(c):
                        return c * 1.8 + 32

        ERROS CL√ÅSSICOS (ANOTA!):

            . Usar staticmethod para acessar atributo
            . Usar staticmethod para l√≥gica do objeto
            . Usar staticmethod para ‚Äúevitar self‚Äù
            . Criar classe s√≥ para ter staticmethods

            - Se virou ‚Äúclasse de fun√ß√µes‚Äù, algo est√° errado.

        REGRA PROFISSIONAL DEFINITIVA:

            @staticmethod:
                - fun√ß√£o pura
                - sem estado
                - ligada conceitualmente √† classe
                - uso pontual e consciente

    ==========================================================================

    self e cls:

        - self e cls N√ÉO s√£o palavras-chave do Python.

        Eles s√£o:

            . par√¢metros comuns
            . nomes por conven√ß√£o
            . escolhidos por clareza

        Voc√™ poderia escrever:

            def metodo(banana):
                ...

        Mas ningu√©m faz isso porque:
            
            - OO √© comunica√ß√£o entre humanos, n√£o s√≥ com a m√°quina.

        O QUE √â self (CONCEITO, N√ÉO SINTAXE):

            Defini√ß√£o correta:

                self √© a refer√™ncia ao objeto que est√° chamando o m√©todo.

            Quando voc√™ escreve:

                obj.metodo()

            O Python executa:

                Classe.metodo(obj)

            - obj vira o self.

            Exemplo claro:

                class Pessoa:
                    def falar(self):
                        print(self)

            Uso:

                p1 = Pessoa()
                p2 = Pessoa()

                p1.falar()
                p2.falar()

            Resultado:

                self em p1.falar() ‚Üí p1

                self em p2.falar() ‚Üí p2

            . O m√©todo √© o mesmo, o self muda.

            POR QUE self EXISTE?

                Sem self, isso seria imposs√≠vel:

                    class Conta:
                        def depositar(self, valor):
                            self.saldo += valor

                Como o m√©todo saberia qual saldo alterar?

                self resolve isso:

                    cada objeto carrega seu pr√≥prio estado

                    o m√©todo sabe em qual objeto atuar

            ERRO CONCEITUAL COMUM SOBRE self:

                Errado:

                    ‚Äúself √© o objeto‚Äù

                Errado:

                    ‚Äúself cria o objeto‚Äù

                Correto:

                    self √© uma REFER√äNCIA para o objeto j√° criado

                O objeto nasce antes do m√©todo rodar.

            self N√ÉO √â OPCIONAL (EM M√âTODO DE INST√ÇNCIA)

                Errado:

                    class Teste:
                        def metodo():
                            pass

                Isso gera erro ao chamar:

                    Teste().metodo()  # TypeError

                O Python sempre passa o objeto automaticamente.

        O QUE √â cls (CONCEITO REAL):

            cls √© a refer√™ncia √† classe que chamou o m√©todo de classe.

            Quando voc√™ escreve:

                Classe.metodo()

            O Python executa:

                Classe.metodo(Classe)

            A classe vira o cls.

            Exemplo simples:

                class Exemplo:
                    @classmethod
                    def quem_sou_eu(cls):
                        print(cls)

            Uso:

                Exemplo.quem_sou_eu()

            Sa√≠da:

                <class '__main__.Exemplo'>

            cls √© a classe, n√£o uma inst√¢ncia.

            cls EM HERAN√áA (PONTO CR√çTICO):

                ex:

                    class Base:
                        @classmethod
                        def quem_sou(cls):
                            print(cls)


                    class Filha(Base):
                        pass

                Uso:

                    Base.quem_sou()
                    Filha.quem_sou()

                Sa√≠da:

                    <class '__main__.Base'>
                    <class '__main__.Filha'>

                O mesmo m√©todo se adapta √† subclasse

                Isso √©:

                    polimorfismo

                    sub-tipagem

                    design correto

            POR QUE N√ÉO USAR O NOME DA CLASSE NO LUGAR DE cls?

                Errado:

                    class Pessoa:
                        @classmethod
                        def criar(cls):
                            return Pessoa()

                Problema:

                    class Funcionario(Pessoa):
                        pass

                    Funcionario.criar()  # cria Pessoa, n√£o Funcionario

                Certo:

                    return cls()

                . cls respeita heran√ßa.
                . Nome fixo da classe quebra OO.

        SELF VS CLS (DIFEREN√áA DEFINITIVA):

            | Aspecto                  | `self`            | `cls`                |
            | ------------------------ | ----------------- | -------------------- |
            | Refer√™ncia               | objeto            | classe               |
            | Tipo de m√©todo           | inst√¢ncia         | classe               |
            | Atua sobre               | estado individual | estado compartilhado |
            | Polim√≥rfico              | sim               | sim                  |
            | Recebido automaticamente | sim               | sim                  |

        ONDE self E cls N√ÉO APARECEM?

            M√©todos est√°ticos

            Porque:

                n√£o dependem de objeto

                n√£o dependem de classe

        ERRO CL√ÅSSICO: USAR self QUANDO DEVERIA SER cls:

            Errado:

                class Sistema:
                    modo = "prod"

                    def mudar_modo(self, modo):
                        self.modo = modo

            Isso cria:

                atributo de inst√¢ncia

                bug silencioso

            Certo:

                @classmethod
                def mudar_modo(cls, modo):
                    cls.modo = modo

        REGRA DE OURO ABSOLUTA:

            self ‚Üí objeto ‚Üí estado individual
            cls  ‚Üí classe ‚Üí estado compartilhado

            - Se voc√™ errar isso, o design quebra, mesmo que o c√≥digo rode.

        VIS√ÉO MENTAL (MUITO IMPORTANTE)

            M√©todo n√£o pertence ao objeto

            M√©todo pertence √† classe

            self / cls dizem quem est√° usando o m√©todo

        RESUMO DE CADERNO (VERS√ÉO CONCEITUAL)

            self:
            - refer√™ncia ao objeto
            - passado automaticamente
            - usado em m√©todos de inst√¢ncia

            cls:
            - refer√™ncia √† classe
            - passado automaticamente
            - usado em m√©todos de classe

            N√£o s√£o palavras-chave
            S√£o conven√ß√µes fundamentais

    ==========================================================================

    classes como objetos:

    ==========================================================================

    classes aninhadas:

    ==========================================================================

    mixins:

    ==========================================================================

    M√©todos m√°gicos:

    ==========================================================================

    factory:

    ==========================================================================

    DataClass:

    ==========================================================================

    Setups, interfaces e Managers:

    ==========================================================================

    SOLID:

    ==========================================================================

    Lib dataclasses:

    ==========================================================================

Um pouco sobre Estruturas de dados:

    caracteres e strings

    listas / vetores e arrays n√£o ordenadas

    listas / vetores e arrays ordenadas

    circularidade e rotacionamento:

    matrizes

    Torre de Hanoi

    algoritmos de busca

    algoritmo de Ordena√ß√µes

    BFS √ó DFS

    pilhas

    filas

    fila de prioridade

    fila circular

    fila de extremidade dupla

    deques

    Lista encadeada

    √°vores

    hash tables

    LRU Cache

    grafos

    Busca em profundidade

    Busca em largura

    Busca gulosa

    Busca A*

    Algoritmo de Dijkstra

Um pouco de python em baixo n√≠vel:

    bytes

    bytearray

    struct

    operadores bitwise


Um pouco de ambientes:

    Python com terminal:

    Python com ambientes virtuais (virtualenv, poetry, pdb):

    Banco de dados e ORM com Python:

    C√≥digo limpo com python:

    Padr√µes de projeto com python:

    Python com VMs:

    Python com DOCKER:

    Usando python com outras linguagens:
